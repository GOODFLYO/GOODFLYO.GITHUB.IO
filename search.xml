<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>区块链学习第一期</title>
    <url>/2022/11/01/202_zyn_01/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a></p>
<h1 style="font-size:32px;text-align:center;color:red">区块链基础入门</h1>
[toc]

<hr>
<h3 id="说到区块链，我想我们听到最多的就是比特币"><a href="#说到区块链，我想我们听到最多的就是比特币" class="headerlink" title="说到区块链，我想我们听到最多的就是比特币"></a>说到区块链，我想我们听到最多的就是比特币</h3><blockquote>
<p>每当同学聚餐问我学的什么的时候，我一说区块链，他们就说自己知道：是比特币！<br>但是很明显，他们只是了解一丢丢。</p>
</blockquote>
<span id="more"></span>
<hr>
<h3 id="区块链是什么？"><a href="#区块链是什么？" class="headerlink" title="区块链是什么？"></a>区块链是什么？</h3><blockquote>
<p>官方定义已经足够充分，但我不认为好理解。<br><img src="https://gitee.com/goodflyo/cdn/raw/master/01/define.png" alt="区块链定义"></p>
</blockquote>
<p><strong>谈谈个人理解（错误不可避免，今后将会修正）</strong></p>
<ul>
<li>区块链是一个数据库的集合（超大链表），每个区块之间可以通过哈希指针连接起来</li>
<li>区块链=区块+链（其中“链”是一个区块到另一个区块链的”指针”）</li>
<li>区块=区块头+区块体<br><img src="https://gitee.com/goodflyo/cdn/raw/master/01/myknow.png" alt="区块链自我理解"></li>
<li>区块体里面则包含了我们要存储的数据，区块头则：<img src="https://gitee.com/goodflyo/cdn/raw/master/01/body.png" alt="区块体"></li>
<li>如上所示，区块链并不是什么复杂的概念，反而像个一步步迭代过来的新型数据库，只不过这个数据库搭载了很多其他领域的知识</li>
</ul>
<hr>
<h3 id="区块链的应用实现"><a href="#区块链的应用实现" class="headerlink" title="区块链的应用实现"></a>区块链的应用实现</h3><ul>
<li>比特币：区块链 1.0<ul>
<li>闪电网络</li>
<li>数字钱包</li>
<li>挖矿（PoW、PoS、DPoS）</li>
</ul>
</li>
<li>以太坊：区块链 2.0<ul>
<li>雷电网络</li>
<li>数字钱包</li>
<li>挖矿</li>
<li>智能合约</li>
</ul>
</li>
<li>EOS：区块链 3.0<ul>
<li>数字钱包</li>
<li>挖矿</li>
</ul>
</li>
</ul>
<blockquote>
<p>当然，以上只是最经典的应用的例举，还有很多的现代区块链落地产品。但是我们始终要知道，区块链是比特币的底层技术，比特币是区块链的应用实现。</p>
</blockquote>
<p>区块链大致结构框架<br><img src="https://gitee.com/goodflyo/cdn/raw/master/01/fabric.jpg" alt="区块链框架"></p>
<hr>
<h1 style="font-size:32px;text-align:center;color:red">智能合约知识</h1>

<h3 id="关键字-constan、view、pure、payable？"><a href="#关键字-constan、view、pure、payable？" class="headerlink" title="关键字 constan、view、pure、payable？"></a>关键字 constan、view、pure、payable？</h3><hr>
<p>Solidity 中变量按作用域划分有三种，分别是</p>
<blockquote>
<p>前提：</p>
</blockquote>
<ul>
<li><p><strong>状态变量（state variable）</strong></p>
</li>
<li><p><strong>局部变量（local variable）</strong></p>
</li>
<li><p><strong>全局变量（global variable）</strong></p>
<ul>
<li><p><strong>状态变量</strong><br>状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，gas 消耗高。状态变量在合约内、函数外声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sol contract Variables &#123;</span><br><span class="line">     uint public x = 1;</span><br><span class="line">     uint public y;</span><br><span class="line">     string public z; &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在函数里更改状态变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function foo() external&#123;</span><br><span class="line">         // 可以在函数里更改状态变量的值</span><br><span class="line">         x = 5;</span><br><span class="line">         y = 2;</span><br><span class="line">         z = &quot;0xAA&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>局部变量</strong><br>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas 低。局部变量在函数内声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar() external pure returns(uint)&#123;</span><br><span class="line">uint xx = 1;</span><br><span class="line">uint yy = 3;</span><br><span class="line">uint zz = xx + yy;</span><br><span class="line">return(zz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>全局变量</strong><br>全局变量是全局范围工作的变量，都是 solidity 预留关键字。他们可以在函数内不声明直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function global() external view returns(address, uint, bytes memory)&#123;</span><br><span class="line">address sender = msg.sender;</span><br><span class="line">uint blockNum = block.number;</span><br><span class="line">bytes memory data = msg.data;</span><br><span class="line">return(sender, blockNum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<ol>
<li><p>view 修饰的函数，是 constant 的别名，只能读取 storage 变量的值，不能写入。（不能改变状态）</p>
<blockquote>
<p>这里特别提到 <strong>状态变量</strong></p>
</blockquote>
</li>
<li><p>pure 修饰的函数 ，不能对 storage 变量进行读写</p>
</li>
<li><p>payable 当一个函数被 payable 修饰，表示调用这个函数时，可以附加发送一些 ETH（当然也可以不发）。<br>没有加 payable 的函数，则没有方法接受 ETH， 附加 ETH 调用会出错。<br><strong>remix 的界面</strong><br><img src="https://gitee.com/goodflyo/cdn/raw/master/01/payableShow.png" alt="支付展示"></p>
</li>
</ol>
<h1 style="font-size:32px;text-align:center;color:red">计划</h1>

<ol>
<li><a href="https://solidity-cn.readthedocs.io/zh/develop/index.html">solidity 官方文档</a></li>
<li><a href="https://search.bilibili.com/all?keyword=dapp&from_source=webtop_search&spm_id_from=333.1007&search_source=5">了解去中心化应用程序（DAPP）</a></li>
<li><a href="https://www.zhihu.com/search?type=content&q=%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0">参考计划</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>区块链学习第二期</title>
    <url>/2022/11/15/202_zyn_02/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a></p>
<h1 style="font-size:32px;text-align:center;color:red">前端基础知识</h1>
[toc]

<hr>
<h3 id="html-中标签的定义"><a href="#html-中标签的定义" class="headerlink" title="html 中标签的定义"></a>html 中标签的定义</h3><blockquote>
<p>我们都知道，html 中可以使用&lt;p&gt;&lt;/p&gt;这些标签去定义内容，但是如何能定义自己的标签呢？例如我想用“ZYN”这个名字作为一个标签，怎么办呢？</p>
</blockquote>
<span id="more"></span>
<p>此时就需要 js 了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 周亚男 <span class="keyword">extends</span> <span class="title class_">THMLElement</span>&#123;</span><br><span class="line">    ...内容</span><br><span class="line">&#125;</span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&quot;ZYN&quot;</span>,周亚男);</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ZYN</span>&gt;</span><span class="tag">&lt;/<span class="name">ZYN</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><table>
<thead>
<tr>
<th></th>
<th>语法</th>
<th>数量</th>
<th>位置</th>
<th>类与元素</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>伪类</td>
<td>:</td>
<td>多个</td>
<td>前后方</td>
<td>修饰（基于 dom）</td>
<td>多</td>
</tr>
<tr>
<td>伪元素</td>
<td>::</td>
<td>单个</td>
<td>后方</td>
<td>创建对象</td>
<td>少（关键）</td>
</tr>
</tbody></table>
<hr>
<h3 id="form-表单与-php（这是我认为最重要的）"><a href="#form-表单与-php（这是我认为最重要的）" class="headerlink" title="form 表单与 php（这是我认为最重要的）"></a>form 表单与 php（这是我认为最重要的）</h3><blockquote>
<p><strong><em>form 能给我一个最直观的前后端数据交互的体验</em></strong></p>
</blockquote>
<blockquote>
<p>表单：在网页中主要负责数据采集功能，基本正常网页都有这样一个控件</p>
</blockquote>
<p><strong>表单</strong>：可以看作是一个表单容器。</p>
<ul>
<li>一个或者多个输入框</li>
<li>一个提交按钮或者一个重置按钮</li>
<li>通过 dom 对象拓展的 forms 属性拿到具体表单</li>
<li>HTMLFormElement：<table>
<thead>
<tr>
<th>属性</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>请求的 URL，等价于 html 中的 action,提交到哪里</td>
</tr>
<tr>
<td>elements</td>
<td>表单中所有控件的 HTMLCollection</td>
</tr>
<tr>
<td>method</td>
<td>HTTP 请求的方法类型</td>
</tr>
<tr>
<td>reset</td>
<td>设置表单默认值</td>
</tr>
<tr>
<td>submit</td>
<td>提交表单</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>数据收集<ul>
<li>表单单域内部的输入控件获得用户输入的值<ul>
<li>常见输入控件：input、textarea、select</li>
<li>type 属性的值决定了唤起的键盘是什么类型：number、password、text、file（传文件）···</li>
<li>当然 html5 还有更多关于时间、颜色 type 的更新</li>
</ul>
</li>
</ul>
</li>
<li>数据校验</li>
<li>数据提交</li>
</ol>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><blockquote>
<p>不管是一般的企业网站还是复杂的网络应用，都离不开数据的添加。通过 php 服务器脚本语言，程序可以处理那些通过服务器对 web 应用进行数据调用或添加的请求。</p>
<ul>
<li>web 邮箱</li>
<li>qq 留言</li>
</ul>
</blockquote>
<blockquote>
<p>虽然 form 是 html 的,但是 php 与 form 的衔接是无缝的。<strong>php 关心怎么获得和使用 form 的数据</strong>。</p>
</blockquote>
<blockquote>
<p><strong>处理表单的基本过程</strong>：</p>
<ol>
<li>数据从 web 表单发送到 php 代码（action=“xxx.php”）</li>
<li>经过处理在生成 html 输出</li>
<li>php 会检查 url、表单数据、上传文件、可用 cookie、web 服务器和环境变量</li>
<li>如果有可用信息，就可以通过 php 访问自动全局变量数组$_XXX</li>
</ol>
</blockquote>
<hr>
<h3 id="标签区分"><a href="#标签区分" class="headerlink" title="标签区分"></a>标签区分</h3><p><a href="https://blog.csdn.net/MIMOSA9716/article/details/100991228">行内块级行内块</a></p>
<hr>
<h3 id="标签权重"><a href="#标签权重" class="headerlink" title="标签权重"></a>标签权重</h3><p>权重的大小</p>
<ol>
<li>!important,加在样式属性值后，权重值为 10000</li>
<li>内联样式，如：style=””，权重值为 1000</li>
<li>ID 选择器，如：# content 权重为 100</li>
<li>类，伪类，属性选择器如：content、：hover 权值为 10</li>
<li>标签选择器和伪元素选择器，如：div、p、：before 权值为 1</li>
<li>通用选择器(*)、子类选择器(&gt;)、相邻选择器(+)、同胞选择器(~)权值为 0</li>
</ol>
<hr>
<h3 id="jquery-的顶级对象"><a href="#jquery-的顶级对象" class="headerlink" title="jquery 的顶级对象$"></a>jquery 的顶级对象$</h3><blockquote>
<ul>
<li>$是 jq 的别称，为了方便</li>
<li>是 jq 的顶级对象，相当于原生 js 的 window，包装成 jq 对象。利用$对 dom 对象包装后产生的对象（伪数组存储对象）bow</li>
</ul>
</blockquote>
<hr>
<h3 id="json-and-ajax"><a href="#json-and-ajax" class="headerlink" title="json and ajax?"></a>json and ajax?</h3><p><strong>ajax</strong>:一种用于创建更好更快以及交互性更强的 web 应用程序技术。它无需刷新页面便可以从服务器获取数据</p>
<p><strong>json</strong>:一种用户数据交互的格式<br>对比一下：很明显，json简单得多</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>周亚男<span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;<span class="name">sex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>21<span class="tag">&lt;<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;student&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;周亚男&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 style="font-size:32px;text-align:center;color:red">区块链知识</h1>

<h3 id="对区块链矿工以及挖矿上链的思考"><a href="#对区块链矿工以及挖矿上链的思考" class="headerlink" title="对区块链矿工以及挖矿上链的思考"></a>对区块链矿工以及挖矿上链的思考</h3><p>在做完第一次简单的区块链实验后，不禁加深了对区块链的思考。我还有很多基础知识没有学透或者学的混杂了。</p>
<blockquote>
<p>实验：</p>
<ul>
<li>获取一个地址的 CBI 余额；</li>
<li>获取一个区块的哈希值；</li>
<li>获取上一个区块的哈希值；</li>
<li>获取当前的时间戳；</li>
<li>获取当前区块的高度；</li>
<li>获取当前区块的难度(difficulty)；</li>
<li>获取当前区块的 gas limit；</li>
<li>获取当前区块的 coinbase 账户；</li>
<li>部署合约到内部教学链；</li>
<li>在 Remix IDE 中调用合约的所有方法，查看数据；</li>
</ul>
</blockquote>
<p><strong>测试结果</strong>：<br><img src="https://gitee.com/goodflyo/cdn/raw/master/02/result.png" alt="第一次运行"><br><img src="https://gitee.com/goodflyo/cdn/raw/master/02/result2.png" alt="第二次运行"></p>
<p><strong>解释一下</strong>：本次实验是老师提供的<strong>测试链</strong>和<strong>测试币</strong></p>
<p><strong>实验疑问</strong>：（提问方式）</p>
<ol>
<li><p style="color:red"> 老师的链是自己写的吗？用什么写的？是不是很厉害？</p>
>可以可以。应该是自己的写的，不过这种链去太坊fork一块也可以。任何语言都可以，但一般用go语言写，然后部署在云服务器上</li>
<li><p style="color:red">我们班明明就几十个人，为什么我部署合约查到的区块高度已经是6813了呀？</p>
>首先你不是把整个合约部署到链上，而是把部署合约这笔交易的哈希记录在链上，而高度那么高，是因为有 **空区块** 的存在
  - 区块头主要用来记录说明信息，而区块体则是用来记录交易。真正的数据记录在客户端的数据库列表中</li>
<li><p style="color:red">空区块怎么来的啊？还有那个coinbase有什么用啊？矿工怎么挖出来的？我们都在做交易，那矿工是谁？</p></li>
</ol>
<ol start="4">
<li><p style="color:red">梳理一下挖矿全过程</p></li>
</ol>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/37853021">区块链交易过程是怎样的</a></p>
</blockquote>
<p><img src="https://gitee.com/goodflyo/cdn/raw/master/02/transmine1.jpg" alt="mine1"></p>
<p><img src="https://gitee.com/goodflyo/cdn/raw/master/02/transmine2.jpg" alt="mine2"></p>
<p><img src="https://gitee.com/goodflyo/cdn/raw/master/02/transmine3.jpg" alt="mine3"></p>
<ol start="5">
<li><p style="color:red">交易怎么进入区块的？</p></li>
</ol>
<p> <strong>一直以来有困惑</strong></p>
<ol>
<li>私钥确定是完全不能重复的吗？虽然是256位二进制。</li>
<li>节点说的是矿工节点吗，还是所有的节点</li>
<li>矿工是如何一边打包交易一边破解随机数的，交易被确认的过程不是在网络中广播的过程吗？</li>
<li>比如，我在打包，你也在打包，咱们俩是打的同一个吗？<br>还是各自打包各自的，谁破解谜题了谁的区块就得到认可。<br>或者说咱们面对的是同一个交易池吗？</li>
<li>我不能理解的是交易是如何被打包进区块的，比如有一万笔交易，只有1000笔被确认，但是这一万笔都被广播了，莫非会有一些处于“未确认”的状态？等待着被打包进下一个区块？</li>
</ol>
<hr>
<ol>
<li>私钥并不是完全不重复，只是说在地球上，这种重复的概率几乎为0 ；<br>私钥是程序生成的256位二进制的随机数。他的大小是10^76这个量级的。宇宙所有原子的量级大概是10^80。重复的概率微乎其微。</li>
<li>节点就是矿工，你的电脑也可以作为一个节点，虽然算力很小；</li>
<li>交易在一个内存池（队列）里，矿工尝试打包，取出交易，计算难题，计算出来了，于是加上自己的签名，完成确认过程。没有准确的时间先后的问题。</li>
</ol>
<p>   <strong>但是我还有疑惑，是不是可以这样理解，在未找到答案之前，有许多区块，谁找到答案，谁的区块就被打到区块链中，进而区块中的交易被确认，并且可以进行下一步的交易。</strong></p>
<p>   <strong>接着就有了下面的回答</strong>：</p>
<ol>
<li>一个交易可能在不同的节点上的队列里 ，就像你在一班排第三，在三班可能排第九。</li>
<li>然后有一个区块打包会包含这个交易，其他节点处理是会把交易抛弃掉。所以，一个交易只能被包含到一个区块里。<br>区块提交后，其他节点进行同步，同步该区块，并对区块中的每个交易进行验证，如果发现有交易是本地队列已经有的，就将该交易从自己的队列里剔除。</li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>区块链学习第四期</title>
    <url>/2022/12/15/202_zyn_04/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a></p>
<h1 style="font-size:32px;text-align:center;color:red">学习ethers.js</h1>
[toc]

<hr>
<h2 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h2><blockquote>
<p>在说 etherjs 之前呢，先说一下<strong>web3js</strong></p>
</blockquote>
<ul>
<li>Web3.js 是一个库集合，允许您使用 HTTP、IPC 或 WebSocket 与本地或远程以太坊节点进行交互。<span id="more"></span></li>
<li>web3js 提供了用于和 geth 通信的 javascipt API，也就是用 web3js 连接 geth，在通过 geth 连接以太坊。</li>
<li>内部使用了 json-rpc 与 geth 通信</li>
<li><strong>json-rpc</strong>是一个无状态且轻量级的远程过程调用（rpc）协议。允许使用 socket、http 等协议进行通讯。使用 json 作为数据格式（rfc4627）==》被封装成了 jsapi</li>
<li>web3js 可以与所有支持 rpc 的节点进行通信。不仅支持以太坊相关的 api，还支持以太坊生态中其它系统的 api</li>
<li><hr>
</li>
</ul>
<h2 id="ethers-js"><a href="#ethers-js" class="headerlink" title="ethers.js"></a>ethers.js</h2><blockquote>
<p><strong>etherjs</strong>是一个完整而紧凑的开源库，用于与以太坊区块链及其生态系统进行交互（个人认为就是提供一个方便访问区块链的接口,是压缩版的 web3js）。<strong>如果要写 Dapp 前端，则需要用到它。</strong></p>
<p><strong>uer interface（frontend）</strong> &lt;–&gt; <strong>ethereum api</strong> &lt;–&gt; <strong>smart contract</strong></p>
</blockquote>
<h3 id="对-alchemy-的再理解"><a href="#对-alchemy-的再理解" class="headerlink" title="对 alchemy 的再理解"></a>对 alchemy 的再理解</h3><p>某一次实验需要注册 alchemy 获取一个 api key,但一直不懂为什么要。下面我用个对比法解释：</p>
<blockquote>
<p>我们一开始访问以太坊时，用的扩展类工具连接的以太坊：<strong>Metamask</strong></p>
<ol>
<li>提供连接到以太坊的网络（a Provider）</li>
<li>持有你的私钥并且可以进行签名（a Signer）</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(<span class="variable language_">window</span>.<span class="property">ethereum</span>);</span><br><span class="line"><span class="comment">//Metamask插件支持签名交易和信息，来发送交易信息改变区块链的状态</span></span><br><span class="line"><span class="comment">//因此需要一个账户联名</span></span><br><span class="line"><span class="keyword">const</span> signer = provider.<span class="title function_">getSigner</span>();</span><br></pre></td></tr></table></figure>

<p>但是我们不想下载扩展呢？我还能在不通过网页的形式下查看链上信息吗？</p>
<blockquote>
<p>RPC 全称 Remote Procedure Call，即远程过程调用）JSON-RPC API 接口，是另一个连接到以太坊的方法，可以在所有的主要的以太坊节点实现，他主要提供了</p>
<ol>
<li>提供连接到以太坊的网络（a Provider）</li>
<li>持有你的私钥并且可以进行签名（a Signer）<br>查询区块链一旦有了一个 Provider，就有了一个与区块链的连接，可以用它去查询当前状态，获取历史日志，查询部署的代码等</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//await 作用使异步方法变同步</span></span><br><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getBlockNumber</span>();</span><br><span class="line">ethers.<span class="property">utils</span>.<span class="title function_">formatEther</span>(balance);</span><br><span class="line">ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入区块</span></span><br><span class="line"><span class="comment">// Send 1 ether to an ens name.发送1以太到以太坊域名</span></span><br><span class="line"><span class="keyword">const</span> tx = signer.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">  <span class="comment">//签名，发送交易</span></span><br><span class="line">  <span class="attr">to</span>: <span class="string">&quot;ricmoo.firefly.eth&quot;</span>, <span class="comment">//发送至以太坊域名</span></span><br><span class="line">  <span class="attr">value</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;1.0&quot;</span>), <span class="comment">//格式化</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="web3js-和-ethersjs-对比"><a href="#web3js-和-ethersjs-对比" class="headerlink" title="web3js 和 ethersjs 对比"></a>web3js 和 ethersjs 对比</h3><ul>
<li><p>web3js 认为用户在本地部署以太坊节点，私钥和网络连接状态这个节点管理（事迹并不是这样）；ethersjs 中，provider 提供器管理网络连接状态，wallet 钱包类管理密钥，安全且灵活，原生支持 ens</p>
</li>
<li><p>Ethers.js 提供的状态和密钥管理。Web3 的设计场景是 DApp 应该连接到一个本地节点，由这个节点负责保存密钥、签名交易并与以太坊区块链交互。<strong>现实并不是这样的</strong>，绝大多数用户不会在本地运行一个 geth 节点。Metamask 在浏览器 应用中有效地模拟了这种节点环境，因此绝大多数 web3 应用需要使用 Metamask 来保存密钥、签名交易并完成与以太坊的交互。</p>
</li>
<li><p>Ethers.js 采取了不同的设计思路，它提供给开发者更多的灵活性。Ethers.js 将“节点”拆分为两个不同的角色：</p>
<p><strong>钱包</strong>：负责密钥保存和交易签名<br><strong>提供器</strong>：负责以太坊网络的匿名连接、状态检查和交易发送</p>
</li>
</ul>
<h3 id="本地使用-ethersjs，如何配置环境"><a href="#本地使用-ethersjs，如何配置环境" class="headerlink" title="本地使用 ethersjs，如何配置环境"></a>本地使用 ethersjs，如何配置环境</h3><ol>
<li>安装环境 nodejs</li>
<li>安装 ethersjs 包—npm i –save ethers</li>
<li>alchemy 申请一个 rpc 复制里面的 apikey</li>
<li><a href="https://learnblockchain.cn/docs/ethers.js/api.html">查看官方文档</a></li>
<li>当然单个网页也可以直接引入<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会导出一个全局的变量: ethers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdn.ethers.io/scripts/ethers-v4.min.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="本地如何使用使用呢？每一步到底做什么？"><a href="#本地如何使用使用呢？每一步到底做什么？" class="headerlink" title="本地如何使用使用呢？每一步到底做什么？"></a>本地如何使用使用呢？每一步到底做什么？</h3><blockquote>
<p>本次测试的目录结构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ethers-template</span><br><span class="line">    +compile.js</span><br><span class="line">    +contracts</span><br><span class="line">        -erc20.sol</span><br><span class="line">    +build</span><br><span class="line">        -ERC.json</span><br><span class="line">        -Context.json</span><br><span class="line">        -IERC20.sjon</span><br><span class="line">        -SafeMath.json</span><br><span class="line">   -package.json</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化一个文件夹<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li>
<li>创建一个 config.json 文件保存你的项目配置<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//账户私钥，将使用这个私钥对应的账户在指定网络上部署智能合约</span></span><br><span class="line"> <span class="attr">&quot;private_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24C4FE6063E62710EAD956611B71825B778B041B18ED53118CE5DA5F02E494BA&quot;</span><span class="punctuation">,</span></span><br><span class="line"> &lt;!--要接入的以太坊网络，ethers.js支持以下网络：</span><br><span class="line">     homestead：主网</span><br><span class="line">     rinkeby</span><br><span class="line">     ropsten</span><br><span class="line">     kovan</span><br><span class="line">     goerli --&gt;</span><br><span class="line"> <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kovan&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="comment">//声明要交互的已部署合约，可选</span></span><br><span class="line"> <span class="attr">&quot;ERC20&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0DEd9F7D82a24099F09AF7831CaB61B31Df10487&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="comment">//ERC20合约的参数</span></span><br><span class="line"> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fly&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;symbol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Zhou&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;total_supply&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;decimals&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>为了编译合约，还需要安装solc和fs-extra<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">npm install <span class="built_in">fs</span>-extra@<span class="number">8</span>.<span class="number">1</span>.<span class="number">0</span> solc@<span class="number">0</span>.<span class="number">5</span>.<span class="number">11</span> --save</span><br></pre></td></tr></table></figure></li>
<li>创建ERC20合约代码</li>
<li>编写合约编译脚本,下面代码将读入并编译contracts目录中的所有合约文件，然后将编译得到的abi和字节码保存为json文件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> solc = <span class="built_in">require</span>(<span class="string">&#x27;solc&#x27;</span>);</span><br><span class="line"><span class="comment">//这个读取的就是自己的配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceFolderPath = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;contracts&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buildFolderPath = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getContractSource</span> = contractFileName =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> contractPath = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;contracts&#x27;</span>, contractFileName);</span><br><span class="line">  <span class="keyword">const</span> source = fs.<span class="title function_">readFileSync</span>(contractPath, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sources = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdirSync</span>(sourceFolderPath).<span class="title function_">forEach</span>(<span class="function"><span class="params">contractFileName</span> =&gt;</span> &#123;</span><br><span class="line">  sources = &#123;</span><br><span class="line">    ...sources,</span><br><span class="line">    [contractFileName]: &#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="title function_">getContractSource</span>(contractFileName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;Solidity&#x27;</span>,</span><br><span class="line">    sources,</span><br><span class="line">    <span class="attr">settings</span>: &#123;</span><br><span class="line">        <span class="attr">outputSelection</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;*&#x27;</span>: [ <span class="string">&#x27;*&#x27;</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nCompiling contracts...&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> output = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(solc.<span class="title function_">compile</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(input)));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shouldBuild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (output.<span class="property">errors</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(output.<span class="property">errors</span>);</span><br><span class="line">  <span class="comment">// throw &#x27;nError in compilation please check the contractn&#x27;;</span></span><br><span class="line">  <span class="keyword">for</span>(error <span class="keyword">of</span> output.<span class="property">errors</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(error.<span class="property">severity</span> === <span class="string">&#x27;error&#x27;</span>) &#123;</span><br><span class="line">      shouldBuild = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Error found&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(shouldBuild) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nBuilding please wait...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">removeSync</span>(buildFolderPath);</span><br><span class="line">  fs.<span class="title function_">ensureDirSync</span>(buildFolderPath);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> contractFile <span class="keyword">in</span> output.<span class="property">contracts</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> output.<span class="property">contracts</span>[contractFile]) &#123;</span><br><span class="line">      fs.<span class="title function_">outputJsonSync</span>(</span><br><span class="line">        path.<span class="title function_">resolve</span>(buildFolderPath, <span class="string">`<span class="subst">$&#123;key&#125;</span>.json`</span>),</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">abi</span>: output.<span class="property">contracts</span>[contractFile][key][<span class="string">&quot;abi&quot;</span>],</span><br><span class="line">          <span class="attr">bytecode</span>: output.<span class="property">contracts</span>[contractFile][key][<span class="string">&quot;evm&quot;</span>][<span class="string">&quot;bytecode&quot;</span>][<span class="string">&quot;object&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">spaces</span>:<span class="number">2</span>,</span><br><span class="line">          <span class="attr">EOL</span>: <span class="string">&quot;n&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Build finished successfully!n&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nBuild failedn&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 运行node compile.js就可以对合约进行编译</li>
<li>创建文件deploy.js<ul>
<li>下面代码中的默认网络是<strong>configjs</strong>中的测试网</li>
<li>在这个测试网中，需要一些<strong>以太币来支付部署交易的手续费</strong></li>
<li>将使用config.json中的<strong>private_key</strong>来部署合约</li>
<li>运行deploy.js脚本时，需要在命令行传入要部署的合约名称ERC20 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node deploy.js ERC20</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> startTimestamp = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config.json&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(config[<span class="string">&quot;network&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(config[<span class="string">&quot;private_key&quot;</span>], provider);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Loaded wallet <span class="subst">$&#123;wallet.address&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compiled = <span class="built_in">require</span>(<span class="string">`./build/<span class="subst">$&#123;process.argv[<span class="number">2</span>]&#125;</span>.json`</span>);</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nDeploying <span class="subst">$&#123;process.argv[<span class="number">2</span>]&#125;</span> in <span class="subst">$&#123;config[<span class="string">&quot;network&quot;</span>]&#125;</span>...`</span>);</span><br><span class="line">  <span class="keyword">let</span> contract = <span class="keyword">new</span> ethers.<span class="title class_">ContractFactory</span>(</span><br><span class="line">    compiled.<span class="property">abi</span>,</span><br><span class="line">    compiled.<span class="property">bytecode</span>,</span><br><span class="line">    wallet</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> instance =  <span class="keyword">await</span> contract.<span class="title function_">deploy</span>(config[<span class="string">&quot;decimals&quot;</span>], config[<span class="string">&quot;symbol&quot;</span>], config[<span class="string">&quot;name&quot;</span>], config[<span class="string">&quot;total_supply&quot;</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`deployed at <span class="subst">$&#123;instance.address&#125;</span>`</span>)</span><br><span class="line">  config[<span class="string">`<span class="subst">$&#123;process.argv[<span class="number">2</span>]&#125;</span>`</span>] = instance.<span class="property">address</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Waiting for the contract to get mined...&quot;</span>)</span><br><span class="line">  <span class="keyword">await</span> instance.<span class="title function_">deployed</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Contract deployed&quot;</span>)</span><br><span class="line">  fs.<span class="title function_">outputJsonSync</span>(</span><br><span class="line">    <span class="string">&#x27;config.json&#x27;</span>,</span><br><span class="line">    config,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">spaces</span>:<span class="number">2</span>,</span><br><span class="line">      <span class="attr">EOL</span>: <span class="string">&quot;n&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="ethers-js-接口文档导读"><a href="#ethers-js-接口文档导读" class="headerlink" title="ethers.js 接口文档导读"></a>ethers.js 接口文档导读</h3><blockquote>
<p>其实整个文档可以看出四个大类 我把它们按照学习的先后顺序分为：</p>
<ul>
<li>provider（提供器：我习惯理解成提供给我信息的网络）</li>
<li>wallet（钱包）</li>
<li>contract（合约）</li>
<li>utils（工具包）</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>区块链学习第六期</title>
    <url>/2023/01/15/202_zyn_06/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a> </p>
<h1 style="font-size:32px;text-align:center;color:red">零知识证明基础</h1> 
[toc] 
<span id="more"></span>
--- 

<h1 id="零知识证明（Zero-Knowledge-Proofs-ZKP）"><a href="#零知识证明（Zero-Knowledge-Proofs-ZKP）" class="headerlink" title="零知识证明（Zero-Knowledge Proofs  ZKP）"></a>零知识证明（Zero-Knowledge Proofs  ZKP）</h1><blockquote>
<p>零知识证明技术是现代密码学三大基础之一，由 S.Goldwasser、S.Micali 及 C.Rackoff 在 20 世纪 80 年代初提出。早期的零知识证明由于其效率和可用性等限制，未得到很好的利用，仅停留在理论层面。直到近年来，零知识证明的理论研究才开始不断突破，同时区块链也为零知识证明创造了大展拳脚的机会，因而走进大众视野。<br>零知识证明这项“黑科技”随着它的热度逐渐增加，相关的学习资源也慢慢丰富起来了。但是由于，一方面零知识证明背后的原理颇为复杂，且内容繁多；另一方面，针对零知识证明的学习资源质量参差不齐，尚未形成系统。因此对绝大多数读者来说，学习零知识证明的难度依然很大。</p>
</blockquote>
<hr>
<h2 id="简单理解ZKP"><a href="#简单理解ZKP" class="headerlink" title="简单理解ZKP"></a>简单理解ZKP</h2><blockquote>
<p>通过间接方式证明某事物的存在。所谓的零知识，就是指验证方除了对论断判断的结果（错或对）之外，<strong>无法获取任何额外信息</strong>。</p>
</blockquote>
<h2 id="ZKP分类"><a href="#ZKP分类" class="headerlink" title="ZKP分类"></a>ZKP分类</h2><ul>
<li><p>交互式<br>  需要通过反复确认（比如验证者问我问题我每次都可以答对）</p>
</li>
<li><p>非交互式<br>  区块链更常使用的是「非交互式zk」，简称「NIZK」。区块链上的一个交易会分发给多个矿工进行验证，如果每个矿工都进行交互式的验证，那耗时将是难以想象的。而NIZK在证明者进行一次证明之后，能够取信多个验证者，所以更加适合区块链上的场景</p>
</li>
</ul>
<h2 id="零知识证明三大性质"><a href="#零知识证明三大性质" class="headerlink" title="零知识证明三大性质"></a>零知识证明三大性质</h2><ul>
<li>完备性（Completeness）：若一个证明方确实掌握了某论断的答案，则他肯定能找到方法向验证方证明他手中掌握的数据的正确性，即真的假不了。（对应上面药丸的例子，就是拥有药丸的证明方肯定能想办法说服验证方，证明他手里真的有药丸。）</li>
<li>可靠性（Soundness）：若一证明方根本不掌握某论断的答案，则他无法（或只能以极低概率）说服验证方他手中所谓答案的准确性，即假的真不了。（对应上面药丸的例子，就是证明方若手中无药丸则没法蒙混过关让验证方误以为他有药丸。）</li>
<li>零知识性（Zero-knowledgeness）：验证方除了知道证明的结果外，对其他信息一无所知。</li>
</ul>
<h2 id="零知识证明构造方法的三段论"><a href="#零知识证明构造方法的三段论" class="headerlink" title="零知识证明构造方法的三段论"></a>零知识证明构造方法的三段论</h2><ol>
<li>证明方先根据论断内容向验证方发个交底材料，这个样例论断需要是随机的或加密的；</li>
<li>验证方随机生成一个试探（学术名词是挑战，challenge），发给证明方；</li>
<li>证明方根据该试探和交底材料生成证明信息发给验证方。验证方自己将信息和交底材料一合计，判断证明方是否通过了该试探。</li>
</ol>
<h2 id="零知识证明的优点"><a href="#零知识证明的优点" class="headerlink" title="零知识证明的优点"></a>零知识证明的优点</h2><p><strong>安全</strong>，随着零知识证明的使用，安全性会大大提高。<br><strong>高效</strong>，零知识证明过程计算量小，双方交换的信息量会大大减少，因此较为高效。</p>
<h2 id="零知识证明的应用"><a href="#零知识证明的应用" class="headerlink" title="零知识证明的应用"></a>零知识证明的应用</h2><ul>
<li>身份验证</li>
<li>数字签名</li>
<li>认证协议</li>
</ul>
<h2 id="密码学常用公钥密码"><a href="#密码学常用公钥密码" class="headerlink" title="密码学常用公钥密码"></a>密码学常用公钥密码</h2><p>验证某人是否有<strong>私钥</strong></p>
<ol>
<li>用公钥加密某x</li>
<li>让对方出示加密的内容</li>
<li>如果正确则拥有公钥</li>
</ol>
<h2 id="零知识证明形象化举例"><a href="#零知识证明形象化举例" class="headerlink" title="零知识证明形象化举例"></a>零知识证明形象化举例</h2><p>A有一个开房间R的钥匙🔑，B怎么在不知道A有钥匙🔑的情况下相信A有钥匙呢？<br>答：A可以把门打开，拿出其中的一把椅子，B看了之后就知道，A肯定有钥匙，不然怎么开门呢。此时A并没有给B看到钥匙，仅仅是通过给出在有钥匙才能办到的事这个结果，让B相信有钥匙。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>区块链学习第五期</title>
    <url>/2022/12/31/202_zyn_05/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a> </p>
<h1 style="font-size:32px;text-align:center;color:red">ethers.js再探索</h1> 
[toc] 

<hr>
<p><strong>续上一期内容，阳了，失去产出能力</strong></p>
<span id="more"></span>
<h2 id="ethers-js-接口文档导读"><a href="#ethers-js-接口文档导读" class="headerlink" title="ethers.js 接口文档导读"></a>ethers.js 接口文档导读</h2><blockquote>
<p>其实整个文档可以看出四个大类 我把它们按照学习的先后顺序分为：</p>
<ul>
<li>provider（提供器：我习惯理解成提供给我信息的网络）</li>
<li>wallet（钱包）</li>
<li>contract（合约）</li>
<li>utils（工具包）</li>
</ul>
</blockquote>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><ul>
<li><p>在 Ethers.js 中，”provider” 是一个对象，用于与以太坊网络连接并进行通信。它提供了<strong>一组方法</strong>，用于从以太坊网络中读取数据和发送交易。</p>
</li>
<li><p>可以将 provider 看作是<strong>与以太坊网络的接口</strong>，通过它可以与以太坊网络进行交互。可以使用 Ethers.js 的 provider 对象来访问以太坊区块链数据、发送交易和调用智能合约。</p>
</li>
<li><p>可以使用 Ethers.js 的 provider 对象来连接到任何以太坊节点，包括本地节点和远程节点。可以使用它来连接到任何支持 JSON-RPC 的以太坊节点。</p>
</li>
</ul>
<h3 id="wallet"><a href="#wallet" class="headerlink" title="wallet"></a>wallet</h3><ul>
<li><p>Ethers.js 中的 wallet 是一个 JavaScript 对象，用于管理以太坊账户。它具有一组方法，用于签署和发送交易，以及访问和管理账户余额和交易历史记录。</p>
</li>
<li><p>在 Ethers.js 中，wallet 是一个抽象概念，用于表示一个以太坊账户。它可以是一个用户账户，也可以是智能合约账户。在任何情况下，wallet 都是用于管理以太坊账户的对象。</p>
</li>
<li><p>可以使用 Ethers.js 的 wallet 对象来签署和发送交易，访问账户余额和交易历史记录，以及使用钱包加密功能加密和解密私钥。</p>
</li>
<li><p>可以使用 Ethers.js 创建多种类型的钱包，包括用户账户钱包、智能合约钱包和测试钱包。每种类型的钱包都具有一些特定的功能，但所有类型的钱包都提供了基本的钱包功能。</p>
</li>
</ul>
<h3 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h3><ul>
<li><p>Ethers.js 中的 contract 是一个 JavaScript 对象，用于与以太坊智能合约进行交互。它具有一组方法，用于调用合约的函数和访问合约的数据。</p>
</li>
<li><p>在 Ethers.js 中，contract 是一个抽象概念，用于表示一个以太坊智能合约。它提供了一组方法，用于与合约进行交互，包括调用合约函数和访问合约数据。</p>
</li>
<li><p>可以使用 Ethers.js 的 contract 对象来调用智能合约函数，访问智能合约数据，并监听合约事件。你还可以使用它来部署新的智能合约。</p>
</li>
<li><p>要使用 Ethers.js 中的 contract 对象，你需要先定义合约的接口，即合约中可调用的函数和可访问的数据。可以使用 Solidity 编写合约并生成 ABI（应用程序二进制接口），然后使用 ABI 和合约地址来创建 contract 对象。</p>
</li>
</ul>
<h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><ul>
<li><p>Ethers.js 中的 utils 模块提供了一组实用程序函数，用于帮助你在使用 Ethers.js 时进行常见任务。这些函数包括格式化数据、转换数据类型、生成哈希值和执行其他常见任务。</p>
</li>
<li><p>可以使用 Ethers.js 的 utils 模块来执行各种各样的任务，包括：</p>
<ul>
<li><p>格式化数据：可以使用 utils 模块中的函数来格式化数据，例如将数字转换为十六进制字符串、将字节数组转换为字符串等。</p>
</li>
<li><p>转换数据类型：你可以使用 utils 模块中的函数来转换数据类型，例如将十六进制字符串转换为数字、将字符串转换为字节数组等。</p>
</li>
<li><p>生成哈希值：你可以使用 utils 模块中的函数来生成哈希值，例如使用 keccak256 算法生成数据的哈希值。</p>
</li>
<li><p>执行其他常见任务：你可以使用 utils 模块中的函数来执行其他常见任务，例如生成以太坊地址、计算以太坊交易费用等。</p>
</li>
</ul>
</li>
<li><p>可以在 Ethers.js 文档中找到有关 utils 模块的更多信息，包括可用函数的列表和使用示例。</p>
</li>
</ul>
<h2 id="那具体代码是怎样的呢？如何工作？"><a href="#那具体代码是怎样的呢？如何工作？" class="headerlink" title="那具体代码是怎样的呢？如何工作？"></a>那具体代码是怎样的呢？如何工作？</h2><h3 id="provider的具体使用"><a href="#provider的具体使用" class="headerlink" title="provider的具体使用"></a>provider的具体使用</h3>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 连接默认的provider</span></span><br><span class="line"><span class="comment">// 可以使用任何标准网络名称做参数：</span></span><br><span class="line"><span class="comment">//  - &quot;homestead&quot;</span></span><br><span class="line"><span class="comment">//  - &quot;rinkeby&quot;</span></span><br><span class="line"><span class="comment">//  - &quot;ropsten&quot;</span></span><br><span class="line"><span class="comment">//  - &quot;kovan&quot;</span></span><br><span class="line"><span class="comment">//  - &quot;goerli&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> provider = ethers.<span class="title function_">getDefaultProvider</span>(<span class="string">&#x27;ropsten&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接metamask</span></span><br><span class="line"><span class="comment">// 将自动检测网络;</span></span><br><span class="line"><span class="comment">// 如果在MetaMask中更改了网络，则会导致页面刷新。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> provider = <span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(web3.<span class="property">currentProvider</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>区块链学习第三期</title>
    <url>/2022/12/01/202_zyn_03/</url>
    <content><![CDATA[<p><a href="https://goodflyo.github.io/">myBlog</a></p>
<h1 style="font-size:32px;text-align:center;color:red">合约和网络知识</h1>
[toc]
---

<p><strong>绪论:在深入学习区块链的过程中，越来越觉得区块链不是一个简简单单的数据库了，它建立的可编程系统如果真正能运用在社会基层，那将解决许多的问题。例如：农民工工资被拖欠，如果一开始老板就将工资打入智能合约，当农民工完成后，这个钱自动的就打向农民工钱包。</strong></p>
<span id="more"></span>
<h3 id="receive-接收以太函数"><a href="#receive-接收以太函数" class="headerlink" title="receive 接收以太函数"></a>receive 接收以太函数</h3><ul>
<li>一个合约最多有一个 receive 函数, 声明函数为： receive() external payable { … } </li>
<li>不需要 function 关键字，也没有参数和返回值并且必须是　external　可见性和　payable 修饰． 它可以是 virtual 的，可以被重载也可以有 修改器modifier 。</li>
<li>在对合约没有任何附加数据调用（通常是对合约转账）是会执行 receive 函数．　例如　通过 .send() or .transfer() 如果 receive 函数不存在，　但是有payable　的 fallback 回退函数fallback 回退函数fallback 回退函数 那么在进行纯以太转账时，fallback 函数会调用．</li>
<li>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．</li>
<li>更糟的是，receive 函数可能只有 2300 gas 可以使用（如，当使用 send 或 transfer 时）， 除了基础的日志输出之外，进行其他操作的余地很小。</li>
</ul>
<h3 id="Fallback-回退函数"><a href="#Fallback-回退函数" class="headerlink" title="Fallback 回退函数"></a>Fallback 回退函数</h3><ul>
<li>合约可以最多有一个回退函数。函数声明为： fallback () external [payable] 或 fallback (bytes calldata _input) external [payable] returns (bytes memory _output)</li>
<li>没有　function　关键字。　必须是　external　可见性，它可以是 virtual 的，可以被重载也可以有 修改器modifier 。</li>
<li>如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配fallback会被调用． 或者在没有 receive 函数<br>　时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。</li>
<li>fallback　函数始终会接收数据，但为了同时接收以太时，必须标记为　payable 。</li>
<li>如果使用了带参数的版本，_input 将包含发送到合约的完整数据（等于 msg.data ），并且通过 _output 返回数据。 返回数据不是 ABI 编码过的数据，相反，它返回不经过修改的数据。</li>
<li>更糟的是，如果回退函数在接收以太时调用，可能只有 2300 gas 可以使用，参考　receive接收函数<br>与任何其他函数一样，只要有足够的 gas 传递给它，回退函数就可以执行复杂的操作。</li>
</ul>
<p><strong>竟然难度值取决于多少个0，那为什么不记录256个数字，数字是由 从一个0到256个0 组成的，挖矿的时候只需要按照难度值把这个随机数填进去就可以了</strong></p>
<h3 id="智能合约与DApp的关系与区别"><a href="#智能合约与DApp的关系与区别" class="headerlink" title="智能合约与DApp的关系与区别"></a>智能合约与DApp的关系与区别</h3><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序（Decentralized App，简称DApp)。DApp的目标是（或者应该是）让智能合约有一个友好的界面，外加一些额外的东西，例如IPFS(可以存储和读取数据的去中心化网络，不是出自以太坊团队，但有类似的精神）。DApp可以在一台与以太坊节点交互的中心化服务器上运行，也可以在任意一个以太坊平等节点上运行。</p>
<p><strong>提示</strong>:与一般的网站不同，DApp不能在普通的服务器上运行。它需要提交交易到区块链并且从区块链而不是中心化数据库读取重要数据。相对于典型的用户登录系统，用户有可能被表示成一个“钱包”地址而其他用户数据保存在本地。许多事情都会与目前的Web应用有着不同的架构。</p>
<p>DApp流程如下。</p>
<ol>
<li><p>用Solidity(或其他语言）编写智能合约（后缀为.sol)。</p>
</li>
<li><p>用sole编译器将.sol合约编译成EVM字节码。</p>
</li>
<li><p>编译好的字节码回送给DApp前端。</p>
</li>
<li><p>前端将编译好的智能合约部署到区块链中。</p>
</li>
<li><p>区块链返回智能合约地址+ABI(合约接口的二进制表示。合约接口用JS0N表示，包括变量、事件和可以调用的方法）。</p>
</li>
<li><p>前端通过Address+ABI+nonce，调用智能合约。</p>
</li>
<li><p>智能合约开始处理。</p>
</li>
</ol>
<p>智能合约技术的产生对互联网变革非常重要，但是不能直接用于支撑DApp应用生态环境。侧链、VM也撑不起应用生态，因为我们知道应用运行于0S之上，而不是直接运行在裸机之上。一定程度上讲，VM、侧链可以类比图灵等价的裸机。</p>
<h3 id="互联网是如何运作的"><a href="#互联网是如何运作的" class="headerlink" title="互联网是如何运作的"></a>互联网是如何运作的</h3><p>互联网所有的传输都通过RCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p>
<h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h4><p><strong>有四层</strong></p>
<ul>
<li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li>
<li>网络控制层   发送数据包到计算机上使用特定的端口号的应用程序</li>
<li>网络层   使用IP地址将数据包发送到特定的计算</li>
<li>链路层  将二进制数据包与网络信号相互之间转换</li>
</ul>
<p><strong>TCP的可靠</strong></p>
<p>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p>
<p><strong>IP的传输</strong></p>
<p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p>
<p><strong>TCP传输的质量和顺序</strong></p>
<p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p>
<p><strong>IP和IP地址的区别</strong></p>
<p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p>
<p>IP地址是一串数字192.0.0.1</p>
<p><strong>网络传输</strong></p>
<ol>
<li>个人电脑</li>
<li>猫</li>
<li>local ISP   互联网服务提供商</li>
<li>regional ISP   经过多个主干网络</li>
<li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li>
<li>NAP   每个NSP连接到至少三个网络访问点</li>
<li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li>
</ol>
<p><strong>DNS服务</strong></p>
<p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h3><ul>
<li>JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。</li>
<li>是一种认证授权机制。</li>
<li>JWT 是为了在网络应用环境间传递声明而执行的一种基于 </li>
<li>JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>
<li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>
</ul>
<h3 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h3><p><img src="https://gitee.com/goodflyo/cdn/raw/master/03/jwt.jpg" alt="jwt流程"></p>
<ul>
<li>JWT 认证流程：</li>
<li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li>
<li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li>
<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authorization：bearer：&lt;token&gt;</span><br></pre></td></tr></table></figure></li>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</li>
<li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li>
<li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
<li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li>
</ul>
<h3 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h3><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<ul>
<li>方式一<ul>
<li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</li>
<li>GET /calendar/v1/events</li>
<li>Host: <a href="http://api.example.com/">http://api.example.com</a></li>
<li>Authorization: Bearer <token></li>
<li>用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制</li>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li>
<li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li>
<li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li>
<li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
</ul>
</li>
<li>方式二<br>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li>
<li>方式三<br>通过 URL 传输<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.example.com/user?token=xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见的前后端鉴权方式"><a href="#常见的前后端鉴权方式" class="headerlink" title="常见的前后端鉴权方式"></a>常见的前后端鉴权方式</h3><ul>
<li>Session-Cookie</li>
<li>Token 验证（包括 JWT，SSO）</li>
<li>OAuth2.0（开放授权）</li>
</ul>
<h3 id="只要关闭浏览器-，session-真的就消失了吗"><a href="#只要关闭浏览器-，session-真的就消失了吗" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了吗"></a>只要关闭浏览器 ，session 真的就消失了吗</h3><p>  不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>mysql入门</title>
    <url>/2021/10/05/mysql%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><p><strong>层次数据库</strong>是按记录来存取数据的；</p>
<p><strong>网状数据库</strong>是采用网状原理和方法来存储数据；</p>
<span id="more"></span>

<p><strong>关系型数据库</strong>是以行和列的形式存储数据。</p>
<ol>
<li> 规范化是为了解决数据库中数据的插入、删除、修改异常等问题的一组规则</li>
<li> 关系数据库管理系统应能实现的专门关系运算包括 选择、投影、连接</li>
<li> 属于数据完整性约束的是：实体完整性、参照完整性、用户定义的完整性</li>
<li> DML是数据操纵语言，包括select、insert、delete、update，后三个动作会改变数据，可以创建触发器来捕获动作。 DDL是数据定义语言，创建库、表、触发器、存储过程、视图等命令，均属于此范畴。 综上，创建触发器是DDL，触发器工作依靠DML。</li>
</ol>
<hr>
<h2 id="一、SQL简介"><a href="#一、SQL简介" class="headerlink" title="一、SQL简介"></a>一、SQL简介</h2><p>SQL<strong>介绍</strong></p>
<blockquote>
<p>SQL全称是 Structured Query Language（结构化查询语言）是用于访问和操作数据库中的数据的标准数据库编程语言<br>SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言</p>
</blockquote>
<ol>
<li> SQL 能做什么？</li>
</ol>
<p>   SQL可以创建新的数据库及其对象（表，索引，视图，存储过程，函数和触发器）<br>   SQL可以TRUNCATE（删除）表中的所有记录<br>   SQL可以在数据库中设置用户的GRANT和REVOKE权限<br>   注意：<br>   虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。<br>   然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p>
<p><strong>注释</strong>： 除SQL标准之外，大多数SQL数据库程序还具有自己的专有扩展名！</p>
<ol start="2">
<li> <strong>在您的网站中使用 SQL</strong></li>
</ol>
<p>   要创建一个显示数据库中数据的网站，您需要：</p>
<p>   一个RDBMS数据库程序（即MS Access，SQL Server，MySQL）。<br>   使用服务器端脚本语言，如PHP或ASP。<br>   使用SQL来获取所需的数据。<br>   使用HTML / CSS来设置页面的样式</p>
<ol start="3">
<li> RDBMS</li>
</ol>
<p>   RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。</p>
<p>   RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</p>
<p>   RDBMS 中的数据存储在被称为表的数据库对象中。</p>
<p>   表是相关的数据项的集合，它由列和行组成。</p>
<p>   代码示例：</p>
<p>   SELECT * FROM Customers;</p>
<h2 id="二、SQL-语法"><a href="#二、SQL-语法" class="headerlink" title="二、SQL 语法"></a>二、SQL 语法</h2><ol>
<li> SQL<strong>语法规则</strong></li>
</ol>
<p>   SQL语句总是以关键字开始。<br>   SQL语句以分号结尾。<br>   SQL不区分大小写，意味着更新与UPDATE相同</p>
<ol start="2">
<li> <strong>一些最重要的 SQL 命令</strong></li>
</ol>
<p>   CREATE DATABASE - 创建新数据库<br>   ALTER DATABASE - 修改数据库<br>   CREATE TABLE - 创建新表<br>   ALTER TABLE - 变更（改变）数据库表<br>   DROP TABLE - 删除表//删除一列<br>   SELECT - 从数据库中提取数据<br>   UPDATE - 更新数据库中的数据<br>   DELETE - 从数据库中删除数据//删除一行<br>   INSERT INTO - 向数据库中插入新数据<br>   CREATE INDEX - 创建索引（搜索键）<br>   DROP INDEX - 删除索引<br>3.  SQL Select <strong>（选择） 语法</strong></p>
<p>   SELECT 语法用于从数据库中选择数据。</p>
<p>   返回的数据存储在结果表中，称为结果集。</p>
<ol start="4">
<li> SQL WHERE Clause <strong>（查询子句）</strong></li>
</ol>
<p>   WHERE 子句用于过滤记录。</p>
<p>   注意： WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等！</p>
<ol start="5">
<li> WHERE 子句中的运算符</li>
</ol>
<p>   WHERE子句中可以使用以下运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于。 注意 ：在某些版本的SQL中，这个操作符可能写成！=</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>搜索某种模式</td>
</tr>
<tr>
<td>IN</td>
<td>为列指定多个可能的值</td>
</tr>
<tr>
<td>6.  SQL AND, OR and NOT <strong>（与，或非运算符）</strong></td>
<td></td>
</tr>
</tbody></table>
<p>   AND&amp;OR运算符用于根据一个以上的条件过滤记录。</p>
<p>   NOT<strong>语法</strong></p>
<p>   SELECT column1, column2, …<br>   FROM table_name<br>   WHERE NOT condition;</p>
<p>   以下SQL语句选择来自”Customers” 的国家不是 “Germany” 且不是 “USA”的所有字段：</p>
<p>   代码示例：</p>
<p>   SELECT * FROM Customers<br>   WHERE NOT Country=’Germany’ AND NOT Country=’USA’;</p>
<ol start="7">
<li> SQL ORDER BY Keyword<strong>（按关键字排序）</strong></li>
</ol>
<p>   ORDER BY 关键字用于对结果集进行排序。关键字默认情况下按升序排序记录。</p>
<p>   SQL ORDER BY 语法</p>
<p>   SELECT column1, column2, …<br>   FROM table_name<br>   ORDER BY column1, column2, … ASC|DESC;</p>
<ol start="8">
<li> SQL INSERT INTO 语句（在表中插入）</li>
</ol>
<p>   INSERT INTO 语句用于向表中插入新记录。</p>
<ol start="9">
<li> <strong>什么是SQL NULL值？</strong></li>
</ol>
<p>   SQL 中， NULL 用于表示缺失的值。数据表中的 NULL 值表示该值所处的字段为空。</p>
<p>   具有NULL值的字段是没有值的字段。</p>
<p>   如果表中的字段是可选的，则可以插入新记录或更新记录而不向该字段添加值。然后，该字段将被保存为NULL值。</p>
<p>   值为 NULL 的字段没有值。尤其要明白的是，NULL 值与 0 或者包含空白（spaces）的字段是不同的。</p>
<ol start="10">
<li> <strong>如何测试NULL值？</strong></li>
</ol>
<pre><code>使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。

我们将不得不使用IS NULL和IS NOT NULL运算符。

IS NULL**语法**

SELECT column_names
FROM table_name
WHERE column_name IS NULL;

IS NOT NULL**语法**

SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;

创建表的时候，NULL 的基本语法如下：

SQL&gt; CREATE TABLE CUSTOMERS(
ID INT NOT NULL,
NAME VARCHAR (20) NOT NULL,
AGE INT NOT NULL,
ADDRESS CHAR (25) ,
SALARY DECIMAL (18, 2),
PRIMARY KEY (ID)
);
</code></pre>
<ol start="11">
<li> SQL UPDATE 语句（更新表中的记录）</li>
</ol>
<pre><code>UPDATE 语句用于更新表中的现有记录。
</code></pre>
<ol start="12">
<li> SQL UPDATE 语句</li>
</ol>
<pre><code>UPDATE 语句用于更新表中已存在的记录。

SQL UPDATE 语法

UPDATE table_name
SET column1 = value1, column2 = value2, …
WHERE condition;

请注意

更新表中的记录时要小心！ 要注意SQL UPDATE 语句中的 WHERE 子句！ WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！
</code></pre>
<ol start="13">
<li> SQL Delete 语句（删除表中的记录）</li>
</ol>
<pre><code>DELETE语句用于删除表中现有记录。
</code></pre>
<ol start="14">
<li> SQL DELETE 语句</li>
</ol>
<pre><code>DELETE 语句用于删除表中的行。

SQL DELETE 语法

DELETE FROM table_name
WHERE condition;

请注意 删除表格中的记录时要小心！ 注意SQL DELETE 语句中的 WHERE 子句！ WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！

删除所有数据

您可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变：

DELETE FROM table_name;

或者

DELETE * FROM table_name;

注意： 在没有备份的情况下，删除记录要格外小心！因为你删除了不能重复！
</code></pre>
<ol start="15">
<li> SQL SELECT TOP, LIMIT, ROWNUM(<strong>一样的效果</strong>)</li>
</ol>
<pre><code>SELECT TOP 子句用于指定要返回的记录数量。
SELECT TOP子句在包含数千条记录的大型表上很有用。返回大量记录会影响性能。
注： 并不是所有的数据库系统都支持SELECT TOP子句。MySQL支持LIMIT子句来选择有限数量的记录，而Oracle使用ROWNUM。

SQL SELECT TOP PERCENT 实例

以下SQL语句从 “Customers” 表中选择前50%的记录：

实例

SELECT TOP 50 PERCENT * FROM Customers;

SQL TOP**，LIMIT和ROWNUM示例**

以下SQL语句从”Customers”表中选择前三个记录：

SELECT TOP 3 * FROM Customers;

以下SQL语句显示了使用LIMIT子句的等效示例：

SELECT * FROM Customers
LIMIT 3;

以下SQL语句显示了使用ROWNUM的等效示例：

SELECT * FROM Customer
WHERE ROWNUM &lt;= 3;
</code></pre>
<ol start="16">
<li> SQL LIKE 运算符</li>
</ol>
<pre><code>在WHERE子句中使用LIKE运算符来搜索列中的指定模式。

SQL LIKE 操作符

LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。

有两个通配符与LIKE运算符一起使用：

％ - 百分号表示零个，一个或多个字符
_ - 下划线表示单个字符
注意： MS Access使用问号（?）而不是下划线（_）。

百分号和下划线也可以组合使用！
</code></pre>
<ol start="17">
<li> SQL LIKE 语法</li>
</ol>
<pre><code>SELECT column1, column2, …
FROM table_name
WHERE columnN LIKE pattern;

提示 ：您还可以使用AND或OR运算符组合任意数量的条件。

下面是一些使用’％’和’_’通配符显示不同LIKE运算符的例子：

LIKE 运算符    描述
WHERE CustomerName LIKE ‘a%’    查找以“a”开头的任何值
WHERE CustomerName LIKE ‘%a’    查找以“a”结尾的任何值
WHERE CustomerName LIKE ‘%or%’    在任何位置查找任何具有“or”的值
WHERE CustomerName LIKE ‘_r%’    在第二个位置查找任何具有“r”的值
WHERE CustomerName LIKE ‘a%%’    查找以“a”开头且长度至少为3个字符的值
WHERE ContactName LIKE ‘a%o’    找到以”a”开头，以”o”结尾的值
</code></pre>
<ol start="18">
<li> <strong>使用 SQL [charlist] 通配符</strong></li>
</ol>
<pre><code>以下SQL语句选择所有客户City以”b”、”s”或”p”开头：

实例

SELECT * FROM Customers
WHERE City LIKE ‘[bsp]%’;

以下SQL语句选择“City”以“a”、“b”或“c”开头的所有客户：

实例

SELECT * FROM Customers
WHERE City LIKE ‘[a-c]%’;

以下SQL语句选择所有客户City不以”b”、”s”或”p”开头：

实例

SELECT * FROM Customers
WHERE City LIKE ‘[!bsp]%’;
</code></pre>
<ol start="19">
<li><p>SQL IN 运算符</p>
<p> IN运算符允许您在WHERE子句中指定多个值。</p>
<p> IN运算符是多个OR条件的简写。</p>
<p> SQL IN 语法</p>
<p> SELECT column_name(s)<br> FROM table_name<br> WHERE column_name IN (value1, value2, …);</p>
<p> 或者</p>
<p> SELECT column_name(s)<br> FROM table_name<br> WHERE column_name IN (SELECT STATEMENT);</p>
</li>
<li><p>IN 操作符实例</p>
<p>以下SQL语句选择位于“Germany”，“France”和“UK”的所有客户：</p>
<p>代码示例：</p>
<p>SELECT * FROM Customers<br>WHERE Country IN (‘Germany’, ‘France’, ‘UK’);</p>
<p>以下SQL语句选择不在“Germany”，“France”或“UK”中的所有客户：</p>
<p>代码示例：</p>
<p>SELECT * FROM Customers<br>WHERE Country NOT IN (‘Germany’, ‘France’, ‘UK’);</p>
<p>以下SQL语句选择来自同一国家的所有客户作为供应商：</p>
<p>代码示例：</p>
<p>SELECT * FROM Customers<br>WHERE Country IN (SELECT Country FROM Suppliers);</p>
</li>
<li><p>SQL BETWEEN<strong>运算符</strong></p>
</li>
</ol>
<p>BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。</p>
<p>BETWEEN运算符选择给定范围内的值。值可以是数字，文本或日期。</p>
<p>BETWEEN运算符是包含性的：包括开始和结束值。</p>
<p>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name BETWEEN value1 AND value2;</p>
<ol start="22">
<li>NOT BETWEEN 操作符实例</li>
</ol>
<p>要显示前面示例范围之外的产品，请使用NOT BETWEEN：</p>
<p>实例</p>
<p>SELECT * FROM Products<br>WHERE Price NOT BETWEEN 10 AND 20;</p>
<p>以下SQL语句选择所有带有ProductName BETWEEN’Carnarvon Tigers’和’Mozzarella di Giovanni’的产品：</p>
<p>实例</p>
<p>SELECT * FROM Products<br>WHERE ProductName BETWEEN ‘Carnarvon Tigers’ AND ‘Mozzarella di Giovanni’<br>ORDER BY ProductName;</p>
<p>以下 SQL 语句选取 OrderDate 介于 ‘04-July-1996’ 和 ‘09-July-1996’ 之间的所有订单：</p>
<p>实例</p>
<p>SELECT * FROM Orders<br>WHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#;</p>
<p>**请注意，在不同的数据库中，BETWEEN 操作符会产生不同的结果！</p>
<p>在一些数据库中，BETWEEN 选取介于两个值之间但不包括两个测试值的字段。 在一些数据库中，BETWEEN 选取介于两个值之间且包括两个测试值的字段。 在一些数据库中，BETWEEN 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段</p>
<ol start="23">
<li>SQL 通用数据类型</li>
</ol>
<p>数据库表中的每一列都需要有一个名称和数据类型。</p>
<p>SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。数据类型是一个标签，是便于 SQL 了解每个列期望存储什么类型的数据的指南，它也标识了 SQL 如何与存储的数据进行交互。</p>
<p>下面的表格列出了 SQL 中通用的数据类型：</p>
<p>数据类型    描述<br>CHARACTER(n)    字符/字符串。固定长度 n。<br>VARCHAR(n) 或 CHARACTER VARYING(n)    字符/字符串。可变长度。最大长度 n。<br>BINARY(n)    二进制串。固定长度 n。<br>BOOLEAN    存储 TRUE 或 FALSE 值<br>VARBINARY(n) 或 BINARY VARYING(n)    二进制串。可变长度。最大长度 n。<br>INTEGER(p)    整数值（没有小数点）。精度 p。<br>SMALLINT    整数值（没有小数点）。精度 5。<br>INTEGER    整数值（没有小数点）。精度 10。<br>BIGINT    整数值（没有小数点）。精度 19。<br>DECIMAL(p,s)    精确数值，精度 p，小数点后位数 s。例如：decimal(5,2) 是一个小数点前有 3 位数小数点后有 2 位数的数字。<br>NUMERIC(p,s)    精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同）<br>FLOAT(p)    近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。<br>REAL    近似数值，尾数精度 7。<br>FLOAT    近似数值，尾数精度 16。<br>DOUBLE PRECISION    近似数值，尾数精度 16。<br>DATE    存储年、月、日的值。<br>TIME    存储小时、分、秒的值。<br>TIMESTAMP    存储年、月、日、小时、分、秒的值。<br>INTERVAL    由一些整数字段组成，代表一段时间，取决于区间的类型。<br>ARRAY    元素的固定长度的有序集合<br>MULTISET    元素的可变长度的无序集合<br>XML    存储 XML 数据<br>CREATE INDEX    \CREATE INDEX index_name ON table_name (column_name) or CREATE UNIQUE INDEX index_name ON table_name (column_name)**<br>CREATE VIEW    \CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition**<br>DROP INDEX    ALTER TABLE table_name DROP INDEX index_name (MySQL)`<br>INNER JOIN    \SELECT column_name(s) FROM table_name1 INNER JOIN table_name2 ON table_name1. column_name=table_name2. column_name**<br>LEFT JOIN    SELECT column_name(s) FROM table_name1 LEFT JOIN table_name2 ON table_name1. column_name=table_name2. column_name<br>RIGHT JOIN    SELECT column_name(s) FROM table_name1 RIGHT JOIN table_name2 ON table_name1. column_name=table_name2. column_name<br>FULL JOIN    SELECT column_name(s) FROM table_name1 FULL JOIN table_name2 ON table_name1. column_name=table_name2. column_name<br>LIKE    SELECT column_name(s) FROM table_name WHERE column_nameLIKE pattern<br>TRUNCATE TABLE    \TRUNCATE TABLE table_name**<br>UNION    SELECT column_name(s) FROM table_name1 UNION SELECT column_name(s) FROM table_name2<br>UNION ALL    SELECT column_name(s) FROM table_name1 UNION ALL SELECT column_name(s) FROM table_name2</p>
<hr>
<h2 id="三、SQL-连接（Joins）"><a href="#三、SQL-连接（Joins）" class="headerlink" title="三、SQL 连接（Joins）"></a>三、<strong>SQL 连接（Joins）</strong></h2><p>SQL join 用于把来自两个或多个表的行结合起来。</p>
<ol>
<li>SQL JOIN</li>
</ol>
<p>SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p>
<p>最常见的 JOIN 类型： SQL INNER JOIN<strong>（简单的 JOIN</strong>） 。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。</p>
<ol start="2">
<li><strong>不同的 SQL JOIN</strong></li>
</ol>
<p>在我们继续讲解实例之前，我们先列出您可以使用的不同的 SQL JOIN 类型：</p>
<p>INNER JOIN ：如果表中有至少一个匹配，则返回行<br>LEFT JOIN ：即使右表中没有匹配，也从左表返回所有的行<br>RIGHT JOIN ：即使左表中没有匹配，也从右表返回所有的行<br>FULL JOIN ：只要其中一个表中存在匹配，则返回行<br>注释： INNER JOIN 与 JOIN 是相同的。<br>以下是 “Customers” 表中的数据：</p>
<p>CustomerID    CustomerName    ContactName    Address    City    PostalCode    Country<br>1    Alfreds Futterkiste    Maria Anders    Obere Str.  57    Berlin    12209    Germany<br>2    Ana Trujillo Emparedados y helados    Ana Trujillo    Avda.  de la Constitución 2222    México D. F.     05021    Mexico<br>3    Antonio Moreno Taquería    Antonio Moreno    Mataderos 2312    México D. F.     05023    Mexico<br>选自 “Orders” 表的数据：</p>
<p>OrderID    CustomerID    EmployeeID    OrderDate    ShipperID<br>10308    2    7    1996-09-18    3<br>10309    37    3    1996-09-19    1<br>10310    77    8    1996-09-20    2<br>SQL INNER JOIN 实例</p>
<p>以下SQL语句将返回所有下订单的客户：</p>
<p>示例</p>
<p>SELECT Customers. CustomerName, Orders. OrderID<br>FROM Customers<br>INNER JOIN Orders<br>ON Customers. CustomerID=Orders. CustomerID<br>ORDER BY Customers. CustomerName;</p>
<p>注释： 如果表中至少有一个匹配项，INNER JOIN 关键字将返回一行。如果 “Customers” 表中的行与”Orders” 不匹配，则不会列出行。</p>
<p>以下SQL语句选择包含客户和货运单信息的所有订单：</p>
<p>示例：</p>
<p>SELECT Orders. OrderID, Customers. CustomerName, Shippers. ShipperName<br>FROM ((Orders<br>INNER JOIN Customers ON Orders. CustomerID = Customers. CustomerID)<br>INNER JOIN Shippers ON Orders. ShipperID = Shippers. ShipperID);</p>
<p>让我们看看选自 “Orders” 表的数据：</p>
<p>OrderID    CustomerID    OrderDate<br>10308    2    1996-09-18<br>10309    37    1996-09-19<br>10310    77    1996-09-20<br>然后，看看选自 “Customers” 表的数据：</p>
<p>CustomerID    CustomerName    ContactName    Country<br>1    Alfreds Futterkiste    Maria Anders    Germany<br>2    Ana Trujillo Emparedados y helados    Ana Trujillo    Mexico<br>3    Antonio Moreno Taquería    Antonio Moreno    Mexico<br>请注意，”Orders” 表中的 “CustomerID” 列指向 “Customers” 表中的客户。上面这两个表是通过 “CustomerID” 列联系起来的。</p>
<p>然后，如果我们运行下面的 SQL 语句（包含 INNER JOIN）：</p>
<p>实例</p>
<p>SELECT Orders. OrderID, Customers. CustomerName, Orders. OrderDate<br>FROM Orders<br>INNER JOIN Customers<br>ON Orders. CustomerID=Customers. CustomerID;</p>
<p>运行结果如下所示：</p>
<p>OrderID    CustomerName    OrderDate<br>10308    Ana Trujillo Emparedados y helados    1996-09-18<br>SQL LEFT JOIN 实例</p>
<p>以下SQL语句将选择所有客户以及他们可能拥有的任何订单：</p>
<p>实例</p>
<p>SELECT Customers. CustomerName, Orders. OrderID<br>FROM Customers<br>LEFT JOIN Orders ON Customers. CustomerID = Orders. CustomerID<br>ORDER BY Customers. CustomerName;</p>
<p>注释： LEFT JOIN 关键字返回左表（Customers）中的所有行，即使在右边表（Orders）中没有匹配。</p>
<p><em>结果只会显示符合</em><em><strong>where</strong>子句的数据，只要没有符合的都不会显示，因为它是筛选连接后的临时表中的数据，而</em><em>on</em> <em>只是连接，如果右边没有符合的数据，就显示<strong>null</strong>，而左边的数据都会显示，不会被过滤，这就是<strong>where</strong>和<strong>on</strong>最大的区别**</em></p>
<p>SQL RIGHT JOIN 实例</p>
<p>以下SQL语句将返回所有雇员以及他们可能已经放置的任何订单：</p>
<p>实例</p>
<p>SELECT Orders. OrderID, Employees. LastName, Employees. FirstName<br>FROM Orders<br>RIGHT JOIN Employees ON Orders. EmployeeID = Employees. EmployeeID<br>ORDER BY Orders. OrderID;</p>
<p>注释： RIGHT JOIN 关键字返回右表（Employees）的所有行，即使在左表（Orders）中没有匹配。</p>
<p>以下是”Customers” 表中的数据：</p>
<p>CustomerID    CustomerName    ContactName    Address    City    PostalCode    Country<br>1    Alfreds Futterkiste    Maria Anders    Obere Str.  57    Berlin    12209    Germany<br>2    Ana Trujillo Emparedados y helados    Ana Trujillo    Avda.  de la Constitución 2222    México D. F.     05021    Mexico<br>3    Antonio Moreno Taquería    Antonio Moreno    Mataderos 2312    México D. F.     05023    Mexico<br>选自 “Orders” 表的数据：</p>
<p>OrderID    CustomerID    EmployeeID    OrderDate    ShipperID<br>10308    2    7    1996-09-18    3<br>10309    3    3    1996-09-19    1<br>10310    77    8    1996-09-20    2<br>SQL FULL OUTER JOIN 实例</p>
<p>当左（表1）或右（表2）表记录匹配时，FULL OUTER JOIN关键字将返回所有记录。</p>
<p>注意： FULL OUTER JOIN可能会返回非常大的结果集！</p>
<p>以下SQL语句选择所有客户和所有订单：</p>
<p>SELECT Customers. CustomerName, Orders. OrderID<br>FROM Customers<br>FULL OUTER JOIN Orders ON Customers. CustomerID=Orders. CustomerID<br>ORDER BY Customers. CustomerName;</p>
<p>从这套结果中选择的数据如下：</p>
<p>CustomerName    OrderID<br>Alfreds Futterkiste<br>Ana Trujillo Emparedados y helados    10308<br>Antonio Moreno Taquería    10365<br>10382<br>10351<br>注意 ： FULL OUTER JOIN关键字返回左表（Customers）中的所有行，以及右表（Orders）中的所有行。如果 “Customers”中的行中没有”Orders”中的匹配项，或者”Orders”中的行中没有 “Customers”中的匹配项，那么这些行也会列出。</p>
<ol start="3">
<li>SQL<strong>自联接</strong></li>
</ol>
<p>自联接是一种常规联接，但表本身是连接的。</p>
<p>就是可以把一张表看成两张表 取不同的名字暂时使用</p>
<p>Self JOIN<strong>语法</strong></p>
<p>SELECT column_name(s)<br>FROM table1 T1, table1 T2<br>WHERE condition;</p>
<ol start="4">
<li>SQL UNION 运算符</li>
</ol>
<p>UNION运算符用于组合两个或更多SELECT语句的结果集。</p>
<p>UNION中的每个SELECT语句必须具有相同的列数<br>这些列也必须具有相似的数据类型<br>每个SELECT语句中的列也必须以相同的顺序排列<br>SQL UNION 语法</p>
<p>SELECT column_name(s) FROM table1<br>UNION<br>SELECT column_name(s) FROM table2;</p>
<p>注释： 默认情况下，UNION 运算符选择一个不同的值。如果允许重复值，请使用 UNION ALL。</p>
<p>SQL UNION ALL 语法</p>
<p>SELECT column_name(s) FROM table1<br>UNION ALL<br>SELECT column_name(s) FROM table2;</p>
<p>注释： UNION结果集中的列名总是等于UNION中第一个SELECT语句中的列名。</p>
<ol start="5">
<li>SQL SELECT INTO 语句（这是列的插入复制）</li>
</ol>
<p>SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。***</p>
<p>我们可以把所有的列都复制到新表中：</p>
<p>SELECT *<br>INTO newtable [IN externaldb ]<br>FROM table1;</p>
<p>或者只复制希望的列插入到新表中：</p>
<p>SELECT <em>column_name(s)</em><br>INTO newtable [IN externaldb ]<br>FROM table1;</p>
<p>提示： 将使用SELECT语句中定义的列名和类型创建新表。您可以使用AS子句来应用一个新名称。</p>
<p>创建 Customers 的备份复件：</p>
<p>SELECT *<br>INTO CustomersBackup2013<br>FROM Customers;</p>
<p>请使用 IN 子句来复制表到另一个数据库中：</p>
<p>SELECT *<br>INTO CustomersBackup2013 IN ‘Backup. mdb’<br>FROM Customers;</p>
<p>只复制一些列插入到新表中：</p>
<p>SELECT CustomerName, ContactName<br>INTO CustomersBackup2013<br>FROM Customers;</p>
<ol start="6">
<li>SQL INSERT INTO SELECT 语句（这是列的插入复制）</li>
</ol>
<p>INSERT INTO SELECT 语句从表中复制数据，并将数据插入现有的表中。目标表中的任何现有行都不会受到影响</p>
<p>我们可以将所有列从一个表中复制到另一个已经存在的表中：</p>
<p>INSERT INTO table2<br>SELECT * FROM table1;</p>
<p>或者我们可以把想要的列复制到另一个现有的表中：</p>
<p>INSERT INTO table2<br><em>(column_name(s))</em><br>SELECT <em>column_name(s)</em><br>FROM table1;</p>
<p>把 “Suppliers” 一栏复制到 “Customers” 一栏：</p>
<p>实例</p>
<p>INSERT INTO Customers (CustomerName, Country)<br>SELECT SupplierName, Country FROM Suppliers;</p>
<hr>
<h2 id="四、SQL-子查询"><a href="#四、SQL-子查询" class="headerlink" title="四、SQL 子查询"></a>四、<strong>SQL 子查询</strong></h2><p>子查询（Sub Query）或者说内查询（Inner Query），也可以称作嵌套查询（Nested Query），是一种嵌套在其他 SQL 查询的 WHERE 子句中的查询。</p>
<p>子查询用于为主查询返回其所需数据，或者对检索数据进行进一步的限制。</p>
<p>子查询可以在 SELECT、INSERT、UPDATE 和 DELETE 语句中，同 =、&lt;、&gt;、&gt;=、&lt;=、IN、BETWEEN 等运算符一起使用。</p>
<p>使用子查询必须遵循以下几个规则：</p>
<p>子查询必须括在圆括号中。<br>子查询的 SELECT 子句中只能有一个列，除非主查询中有多个列，用于与子查询选中的列相比较。<br>子查询不能使用 ORDER BY，不过主查询可以。在子查询中，GROUP BY 可以起到同 ORDER BY 相同的作用。<br>返回多行数据的子查询只能同多值操作符一起使用，比如 IN 操作符。<br>SELECT 列表中不能包含任何对 BLOB、ARRAY、CLOB 或者 NCLOB 类型值的引用。<br>子查询不能直接用在集合函数中。<br>BETWEEN 操作符不能同子查询一起使用，但是 BETWEEN 操作符可以用在子查询中。</p>
<hr>
<h2 id="五、SQL函数"><a href="#五、SQL函数" class="headerlink" title="五、SQL函数"></a>五、<strong>SQL</strong>函数</h2><p>一、创建函数 语法：</p>
<p>create function 函数名(参数列表**)</p>
<p>retrurns 返回类型</p>
<p>begin 函数体 end</p>
<p>注意： 参数列表包含两部分： 参数名 参数类型函数体：肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不会报错，但不建议 return值；（建议放最后）函数体中仅有一句话，则可以省略begin end使用delimiter语句设置结束标记 学过的函数：LENGTH、SUBSTR、CONCAT等 二、调用语法 语法：</p>
<p>SELECT 函数名（参数列表） 即执行函数中的所有语句，并显示返回值 #函数的使用（案例演示） 无参有返回 #返回公司的员工个数</p>
<p>注：mysql的设置默认是不允许创建函数 这是我们开启了bin-log, 我们就必须指定我们的函数是否是</p>
<p>1 . DETERMINISTIC 不确定的</p>
<p>2 . NO SQL 没有SQl语句，当然也不会修改数据</p>
<p>3 . READS SQL DATA 只是读取数据，当然也不会修改数据</p>
<p>MODIFIES SQL DATA 要修改数据<br>CONTAINS SQL 包含了SQL语句 其中在function里面，只有 DETERMINISTIC, NO SQL 和 READS SQL DATA 被支持。<br>如果我们开启了 bin-log, 我们就必须为我们的function指定一个参数。</p>
<p>在MySQL中创建函数时出现这种错误的解决方法：</p>
<p>set global log_bin_trust_function_creators=TRUE;</p>
<p>或执行： set global log_bin_trust_function_creators=1;</p>
<p>举个例子\</p>
<p>– (3) 创建一个函数，输入出生日期，返回年龄。<br>drop function if EXISTS func_年龄;<br>delimiter $$<br>CREATE FUNCTION func_年龄(<br>inyear date<br>)<br>RETURNS integer<br>NO SQL – 表示方法体里里面没有关于sql的语句了<br>BEGIN<br>DECLARE a INT DEFAULT 0;<br>SET a = YEAR(now())-YEAR(inyear);<br>RETURN a;<br>END$$<br>delimiter;</p>
<p>SELECT func_年龄(‘2001-08-11’) 年龄;</p>
<p>顺序结构</p>
<p>先来一个简单的，创建一个函数将’2009-06-23 00:00:00’这样格式的datetime时间转化为‘2009年6月23日0时0分0秒’这样的格式：</p>
<h2 id="创建一个叫getdate的自定义函数"><a href="#创建一个叫getdate的自定义函数" class="headerlink" title="创建一个叫getdate的自定义函数"></a>创建一个叫getdate的自定义函数</h2><p>DELIMITER $$ DROP FUNCTION IF EXISTS testdb. fn_getdate$$ CREATE FUNCTION testdb. fn_getdate(gdate datetime)</p>
<p>RETURNS varchar(255) BEGIN DECLARE dt VARCHAR(255) DEFAULT ‘’; SET dt = date_format(gdate, ‘%Y年%m月%d日%h时%i分%s秒’); RETURN dt; END $$ DELIMITER ;</p>
<p>解析：</p>
<p>第一句DELIMITER 是定义一个结束标识符$$，因为MySQL默认是以分号作为SQL语句的结束符的，而函数体内部要用到分号，所以会跟默认的SQL结束符发生冲突，所以需要先定义一个其他的符号作为SQL的结束符；</p>
<p>第二句是如果这个函数已经存在了，就删除掉，testdb是数据库的名字，函数是跟数据库相关联的，getdate是函数的名字；</p>
<p>第三句是创建一个函数，（）里是参数的名字和类型，RETURNS 定义这个函数返回值的类型；</p>
<p>函数体必须放在BEGIN END之间；</p>
<p>DECLARE 是定义函数体的变量，这里定义一个变量x,默认是空，然后SET给x变量赋值；</p>
<p>RETURN 是返回值，这里把变量x返回，x的类型必须与第三句中定义的返回类型一致。</p>
<p>调用：<strong>SELECT</strong> fn_getdate(‘2009-06-23 00:00:00’）; //返回 ‘2009年06月23日00时00分00秒’</p>
<p>自定义函数分为二种，一种是标量值函数，另一种是表格值函数</p>
<p>一**.  标量值函数 ：返回一个标量值**</p>
<p>语法：</p>
<p>Create function 函数名（参数）<br>Returns 返回值数据类型<br>as<br>begin<br>SQL语句(必须有return 变量或值)<br>End</p>
<p>例子：</p>
<ol>
<li>创建函数：</li>
</ol>
<p>CREATE FUNCTION MySTR(@strs VARCHAR(50))<br>RETURNS VARCHAR(50)<br>AS<br>BEGIN<br>DECLARE @str2 VARCHAR(30)<br>SET @str2=@strs<br>RETURN @str2<br>END</p>
<ol start="2">
<li>执行函数：</li>
</ol>
<p>SELECT dbo. MySTR(‘aa’) AS result</p>
<p>在sql语句中执行：</p>
<p>DECLARE @str3 VARCHAR(30)<br>SET @str3=(select name from userinfo where huji=dbo. MySTR(‘邯郸’) and id=23 )<br>select @str3</p>
<p>函数的调用：</p>
<p>直接使用函数名()就可以调用【虽然这么说，但返回的是一个结果，<strong>sql中不使用select</strong>的话任何结果都无法显示出来（所以单纯调用会报错），】<br>如果想要传入参数可以使用函数名(参数)<br>调用方式【下面调用的函数都是上面中创建的。】：<br>– 无参调用<br>select myselect3();<br>– 传参调用<br>select myselect5(“python”);<br>select * from class where id=myselect5(“python”);</p>
<p>经典例子：</p>
<p>最简单的仅有一条sql的函数<br>create function myselect2() returns int return 666;<br>select myselect2(); – 调用函数</p>
<p>–<br>create function myselect3() returns int<br>begin<br>declare c int;<br>select id from class where cname=”python” into c;<br>return c;<br>end;<br>select myselect3();<br>– 带传参的函数<br>create function myselect5(name varchar(15)) returns int<br>begin<br>declare c int;<br>select id from class where cname=name into c;<br>return c;<br>end;<br>select myselect5(“python”);</p>
<p>二、 表格值函数 ，表格值函数有二种（内联表格值函数，多句表格值函数）</p>
<p>A<strong>、</strong>内联表格值函数：返回一个表格<br>语法：</p>
<p>create function 函数名（参数）<br>returns table<br>as<br>return(一条SQL语句)</p>
<p>例子：</p>
<ol>
<li>创建函数：</li>
</ol>
<p>CREATE FUNCTION tabcmess(@title VARCHAR(10))<br>RETURNS TABLE<br>AS<br>return(select title,des from product where title like ‘%‘+@title+’%’)</p>
<ol start="2">
<li>执行：</li>
</ol>
<p>SELECT * FROM tabcmess(‘aaa’)</p>
<p>B. <strong>多句表格值函数</strong><br>语法：</p>
<p>create function 函数名（参数）<br>returns 表格变量名table (表格变量定义)<br>as<br>begin<br>SQL语句<br>end</p>
<p>例子：</p>
<p>CREATE function tabcmessalot (@title varchar(10))<br>Returns @ctable table(title varchar(10) null,des varchar(100) null)<br>As<br>Begin<br>Insert @ctable Select title,des from product WHERE title LIKE ‘%‘+@title+’%’<br>return<br>End<br>–执行<br>SELECT * FROM tabcmessalot(‘aaa’)</p>
<p>六、<strong>SQL</strong>存储过程</p>
<p>七、<strong>SQL</strong>触发器</p>
<p>一、基本知识</p>
<p>0<strong>、什么是触发器</strong></p>
<p>触发器是与表有关的数据库对象，在对表进行insert/update/delete之前或之后，会触发并执行触发器中定义的SQL语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性,记录日志,校验数据等。</p>
<p>简单的说，就是一张表发生了某件事(插入、删除、更新操作)，然后自动触发了预先编写好的若干条SQL语句的执行;</p>
<p>１、<strong>MySQL</strong>触发器的创建语法：</p>
<p>CREATE[DEFINER = {‘user’| CURRENT_USER}]　<br>TRIGGER trigger_name<br>trigger_time trigger_event<br>ON table_name<br>FOR EACH ROW<br>[trigger_order]<br>trigger_body</p>
<p>2<strong>、MySQL创建语法中的关键词解释：</strong></p>
<p>字段    含义    可能的值<br>DEFINER=    可选参数，指定创建者，默认为当前登录用户（CURRENT_USER）； 该触发器将以此参数指定的用户执行，所以需要考虑权限问题；    DEFINER=‘root@%’ DEFINER=CURRENT_USER<br>trigger_name    触发器名称，最好由表名+触发事件关键词+触发时间关键词组成；<br>trigger_time    触发时间，在某个事件之前还是之后；    BEFORE、AFTER<br>trigger_event    触发事件，如插入时触发、删除时触发； 　　INSERT：插入操作触发器，INSERT、LOAD DATA、REPLACE时触发； 　　UPDATE：更新操作触发器，UPDATE操作时触发； 　　DELETE：删除操作触发器，DELETE、REPLACE操作时触发；    INSERT、UPDATE、DELETE<br>table_name    触发操作时间的表名；<br>trigger_order    可选参数，如果定义了多个具有相同触发事件和触法时间的触发器时（ 如：BEFORE UPDATE），默认触发顺序与触发器的创建顺序一致，可以 使用此参数来改变它们触发顺序。mysql 5. 7. 2起开始支持此参数。 　　FOLLOWS：当前创建触发器在现有触发器之后激活； 　　PRECEDES：当前创建触发器在现有触发器之前激活；    FOLLOWS、PRECEDES<br>trigger_body    触发执行的SQL语句内容，一般以begin开头，end结尾    begin . .  end<br>３、触发执行语句内容（<strong>trigger_body）中的OLD，NEW</strong>：</p>
<p>　　在trigger_body中，我们可以使用NEW表示将要插入的新行（相当于MS SQL的INSERTED），OLD表示将要删除的旧行（相当于MS SQL的DELETED）。通过OLD，NEW中获取它们的字段内容，方便在触发操作中使用，下面是对应事件是否支持OLD、NEW的对应关系：</p>
<p>事件    OLD    NEW<br>INSERT    ×    √<br>DELETE    √    ×<br>UPDATE    √    √<br>　　由于UPDATE相当于删除旧行（OLD），然后插入新行（NEW），所以UPDATE同时支持OLD、NEW；</p>
<p>４、<strong>MySQL分隔符（DELIMITER</strong>）：</p>
<p>　　MySQL默认使用“;”作为分隔符，SQL语句遇到“;”就会提交。而我们的触发器中可能会有多个“;”符，为了防止触发器创建语句过早的提交，我们需要临时修改MySQL分隔符，创建完后，再将分隔符改回来。使用DELIMITER可以修改分隔符，如下：</p>
<p>DELIMITER $. . . –触发器创建语句；$–提交创建语句；DELIMITER ;</p>
<p>二、<strong>MySQL</strong>触发器创建进阶：</p>
<p>1<strong>、MySQL触发器中使用变量：</strong></p>
<p>　　MySQL触发器中变量变量前面加‘@’，无需定义，可以直接使用：</p>
<p>– 变量直接赋值set<code> </code>@num=999; – 使用select语句查询出来的数据方式赋值，需要加括号：set<code> </code>@name=(select<code> </code>name<code> </code>from<code> </code>table);</p>
<p>2<strong>、MySQL触发器中使用if语做条件判断：</strong></p>
<p>– 简单的if语句：set<code> </code>sex = if (new. sex=1,‘男’,‘女’); – 多条件if语句：if old. type=1thenupdatetable…;elseif old. type=2thenupdatetable…;endif;</p>
<p>三、Ｍｙ<strong>SQL</strong>查看触发器：</p>
<p>　　可以使用“show triggers;”查看触发器。由于MySQL创建的触发器保存在“information_schema库中的triggers表中，所以还可以通过查询此表查看触发器：</p>
<p>– 通过information_schema. triggers表查看触发器：select<code> </code>*frominformation_schema. triggers;<code> </code>– mysql 查看当前数据库的触发器show triggers;<code> </code>– mysql 查看指定数据库”aiezu”的触发器show triggers fromaiezu;</p>
<p>四、<strong>MySQL</strong>删除触发器：</p>
<p>1<strong>、可以使用drop trigger删除触发器：</strong></p>
<p>droptriggertrigger_name;</p>
<p>2<strong>、删除前先判断触发器是否存在：</strong></p>
<p>droptriggerif exists trigger_name</p>
<p>五、<strong>Msql</strong>触发器用法举例：</p>
<p>1<strong>、MySQL触发器Insert触发更新同一张表：</strong></p>
<p>　　下面我们有一个表“tmp1”，tmp1表有两个整型字段：n1、n2。我们要通过触发器实现，在tmp插入记录时，自动将n2字段的值设置为n1字段的5倍。</p>
<p>　创建测试表和触发器：</p>
<p>– 创建测试表drop<code> </code>table<code> </code>if exists tmp1;createtabletmp1 (n1 int, n2 int);<code> </code>– 创建触发器DELIMITER $drop<code> </code>trigger<code> </code>if exists tmp1_insert$createtriggertmp1_insertbeforeinsertontmp1for<code> </code>each rowbeginsetnew. n2 = new. n1*5;end$DELIMITER ;</p>
<p>测试触发更新效果：</p>
<p>mysql&gt; insert<code> </code>tmp1(n1)values(18);Query OK, 1 row affected (0. 01 sec)<code> </code>mysql&gt;inserttmp1(n1) values(99);Query OK, 1 row affected (0. 00 sec)<br>mysql&gt; select<code> </code>*fromtmp1;+——+——+| n1 | n2 |+——+——+| 18 | 90 || 99 | 495 |+——+——+2 rowsinset(0. 00 sec)</p>
<p>多个执行语句的触发器语法结构：</p>
<p>CREATE TRIGGER 触发器名称,触发时机(before,after),触发事件(INSERT,UPDATE和DELETE)</p>
<p>ON 建立触发器的表名 FOR EACH ROW</p>
<p>BEGIN</p>
<p>触发器执行语句;</p>
<p>END;</p>
<p>使用触发器</p>
<p>八、复制表</p>
<ol>
<li><strong>复制表结构及其数据</strong></li>
</ol>
<p>下面这个语句会拷贝数据到新表中。</p>
<p>注意：这个语句其实只是把select语句的结果建一个表，所以新表不会有主键，索引。</p>
<p>create table table_name_new as (select * from table_name_old);</p>
<ol start="2">
<li><strong>只复制表结构</strong></li>
</ol>
<p>create table table_name_new as select * from table_name_old where 1=2;</p>
<p>或者</p>
<p>create table table_name_new like table_name_old;</p>
<p>注意：前一种方式是不会复制主键类型，索引的，而后一种方式是把旧表的所有字段类型都复制到新表。</p>
<ol start="3">
<li><strong>只复制表数据</strong></li>
</ol>
<p>如果两个表结构一样</p>
<p>insert into table_name_new select * from table_name_old;</p>
<p>如果两个表结构不一样</p>
<p>insert into table_name_new(column1,column2…) select column1,column2… from table_name_old;</p>
<p>注意：很多文章说可以通过如下语句进行数据复制，table_name_new表可以不存在，会在执行的过程中自动创建。其实该SELECT … INTO形式是使查询结果存储在变量或将其写入文件，即table_name_new是一个变量或者文件。</p>
<p>select column1,column2,….  into table_name_new from table_name_old;</p>
<p>需求：我有个表 table1，当我向 table1 insert 数据 xx,xx,5555,xx 的时候，触发建立一个新表 t5555</p>
<p>不能做到在TRIGGER中建立表，会提示</p>
<p>Explicit or implicit commit is not allowed in stored function or trigger. </p>
<p>存储函数中不允许有DDL语句，这样会导致隐式的 commit;</p>
<p>由于上面的原因，因此也不能在事务中使用DLL语言，因为他会隐式的commit;</p>
<p>——解决方案——————–</p>
<p>1、建议重新考虑你的数据库设计，一般很少会出现这种需求，在数据库设计完成后，不应该出现表结构上的变动。</p>
<p>2、这个在程序逻辑里判断比较好</p>
<p>九、<strong>SQL</strong>事务</p>
<p>SQL 事务</p>
<p>事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。</p>
<p>事务实际上就是对数据库的一个或者多个更改。当你在某张表上创建更新或者删除记录的时，你就已经在使用事务了。控制事务以保证数据完整性，并对数据库错误做出处理，对数据库来说非常重要。</p>
<p>实践中，通常会将很多 SQL 查询组合在一起，并将其作为某个事务一部分来执行。</p>
<p>事务的属性：</p>
<p>事务具有以下四个标准属性，通常用缩略词 ACID 来表示：</p>
<p>原子性： 保证任务中的所有操作都执行完毕；否则，事务会在出现错误时终止，并回滚之前所有操作到原始状态。<br>一致性： 如果事务成功执行，则数据库的状态得到了进行了正确的转变。<br>隔离性： 保证不同的事务相互独立、透明地执行。<br>持久性： 即使出现系统故障，之前成功执行的事务的结果也会持久存在。<br>事务控制：</p>
<p>有四个命令用于控制事务：</p>
<p>COMMIT<strong>：</strong> 提交更改；<br>ROLLBACK<strong>：</strong> 回滚更改；<br>SAVEPOINT<strong>：</strong> 在事务内部创建一系列可以 ROLLBACK 的还原点；<br>SET TRANSACTION<strong>：</strong> 命名事务；<br>COMMIT 命令：</p>
<p>COMMIT 命令用于保存事务对数据库所做的更改。</p>
<p>COMMIT 命令会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。</p>
<p>COMMIT 命令的语法如下所示：</p>
<p>COMMIT;</p>
<p>示例：</p>
<p>考虑 CUSTOMERS 表，表中的记录如下所示：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>下面的示例将会删除表中 age=25 的记录，然后将更改提交（COMMIT）到数据库中。</p>
<p>SQL&gt; DELETE FROM CUSTOMERS<br>WHERE AGE = 25;<br>SQL&gt; COMMIT;</p>
<p>上述语句将会从表中删除两行记录，再执行 SELECT 语句将会得到如下结果：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>ROLLBACK 命令：</p>
<p>ROLLBACK 命令用于撤销尚未保存到数据库中的事务。</p>
<p>ROLLBACK 命令只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。</p>
<p>ROLLBACK 命令的语法如下所示：</p>
<p>ROLLBACK;</p>
<p>示例：</p>
<p>考虑 CUSTOMERS 表，表中的记录如下所示：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>下面的示例将会从表中删除所有 age=25 的记录，然后回滚（ROLLBACK）对数据库所做的更改。</p>
<p>SQL&gt; DELETE FROM CUSTOMERS<br>WHERE AGE = 25;<br>SQL&gt; ROLLBACK;</p>
<p>结果是删除操作并不会对数据库产生影响。现在，执行 SELECT 语句将会得到如下结果：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>SAVEPOINT 命令：</p>
<p>SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。</p>
<p>SAVEPOINT 命令的记录如下所示：</p>
<p>SAVEPOINT SAVEPOINT_NAME;</p>
<p>该命令只能在事务语句之间创建保存点（SAVEPOINT）。ROLLBACK 命令可以用于撤销一系列的事务。</p>
<p>回滚至某一保存点的语法如下所示：</p>
<p>ROLLBACK TO SAVEPOINT_NAME;</p>
<p>下面的示例中，你计划从 CUSTOMERS 表中删除三条不同的记录，并在每次删除之前创建一个保存点（SAVEPOINT），从而使得你可以在任何任何时候回滚到任意的保存点，以恢复数据至其原始状态。</p>
<p>示例：</p>
<p>考虑 CUSTOMERS 表，表中的记录如下所示：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>操作序列如下所示：</p>
<p>SQL&gt; SAVEPOINT SP1;<br>Savepoint created.<br>SQL&gt; DELETE FROM CUSTOMERS WHERE ID=1;<br>1 row deleted.<br>SQL&gt; SAVEPOINT SP2;<br>Savepoint created.<br>SQL&gt; DELETE FROM CUSTOMERS WHERE ID=2;<br>1 row deleted.<br>SQL&gt; SAVEPOINT SP3;<br>Savepoint created.<br>SQL&gt; DELETE FROM CUSTOMERS WHERE ID=3;<br>1 row deleted. </p>
<p>现在，三次删除操作已经生效了，如果此时你改变主意决定回滚至名字为 SP2 的保存点，由于 SP2 于第一次删除操作之后创建，所以后两次删除操作将会被撤销。</p>
<p>SQL&gt; ROLLBACK TO SP2;<br>Rollback complete. </p>
<p>注意，由于你将数据库回滚至 SP2，所以只有第一次删除真正起效了：</p>
<p>SQL&gt; SELECT * FROM CUSTOMERS;<br>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+<br>6 rows selected. </p>
<p>RELEASE SAVEPOINT 命令：</p>
<p>RELEASE SAVEPOINT 命令用于删除先前创建的保存点。</p>
<p>RELEASE SAVEPOINT 的语法如下所示：</p>
<p>RELEASE SAVEPOINT SAVEPOINT_NAME;</p>
<p>保存点一旦被释放，你就不能够再用 ROLLBACK 命令来撤销该保存点之后的事务了。</p>
<p>SET TRANSACTION 命令：</p>
<p>SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。</p>
<p>例如，你可以将某个事务指定为只读或者读写。</p>
<p>SET TRANSACTION 命令的语法如下所示：</p>
<p>SET TRANSACTION [ READ WRITE | READ ONLY ];</p>
<p>游标</p>
<p>1、游标简介</p>
<p>SQL是一种集合操作语言，但有时候需要对单行操作怎么办呢？<br>也就是有时候会过滤出不止一行的数据，但是想一行行的处理；</p>
<p>—游标</p>
<p>游标：<br>从集合中依次提取单条记录，直接提取完最后一条；<br>类似于指针的作用；<br>尽管游标能遍历结果中的所有行，但一次只指向一行；<br>游标的适用场景：<br>存储过程<br>函数<br>触发器<br>游标的使用步骤：<br>定义游标<br>DECLARE 游标名称 CURSOR FOR SELECT子句;<br>打开游标<br>OPEN 游标名称<br>使用游标<br>FETCH 游标名称 INTO 变量名1,变量名2,变量名3[,…]<br>关闭游标<br>CLOSE 游标名称</p>
<p>2、游标使用的示例</p>
<p>##配合存储过程使用</p>
<p>CREATE PROCEDURE cursor_student()<br>BEGIN<br>DECLARE v_student_id varchar(50);<br>DECLARE v_student_name varchar(100);<br>DECLARE done INT DEFAULT false;</p>
<p>DECLARE mycursor CURSOR FOR SELECT student_id,student_name FROM student WHERE score &gt;= 90;<br>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;</p>
<p>OPEN mycursor;</p>
<p>FETCH mycursor INTO v_student_id,v_student_name;</p>
<p>WHILE(NOT done)<br>DO<br>SELECT v_student_id,v_student_name;<br>FETCH mycursor INTO v_student_id,v_student_name;<br>END WHILE;</p>
<p>CLOSE mycursor;<br>END;</p>
<p>3、游标的优缺点</p>
<p>优点：<br>提供了一种除集合操作外的行操作方式；</p>
<p>缺点：<br>性能一般，数据量比较大的时候，还可能会造成内存不足；</p>
<p>十、<strong>SQL的having</strong>语句</p>
<p>HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。</p>
<p>WHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。</p>
<p>语法：</p>
<p>下面可以看到 HAVING 子句在 SELECT 查询中的位置：</p>
<p>SELECT<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>ORDER BY</p>
<p>在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。带有 HAVING 子句的 SELECT 语句的语法如下所示：</p>
<p>SELECT column1, column2<br>FROM table1, table2<br>WHERE [ conditions ]<br>GROUP BY column1, column2<br>HAVING [ conditions ]<br>ORDER BY column1, column2</p>
<p>示例：</p>
<p>考虑 CUSTOMERS 表，表中的记录如下所示：</p>
<p>+—-+———-+—–+———–+———-+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+———-+—–+———–+———-+<br>| 1 | Ramesh | 32 | Ahmedabad | 2000. 00 |<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>| 3 | kaushik | 23 | Kota | 2000. 00 |<br>| 4 | Chaitali | 25 | Mumbai | 6500. 00 |<br>| 5 | Hardik | 27 | Bhopal | 8500. 00 |<br>| 6 | Komal | 22 | MP | 4500. 00 |<br>| 7 | Muffy | 24 | Indore | 10000. 00 |<br>+—-+———-+—–+———–+———-+</p>
<p>下面是一个有关 HAVING 子句使用的实例，该实例将会筛选出出现次数大于或等于 2 的所有记录。</p>
<p>SQL &gt; SELECT ID, NAME, AGE, ADDRESS, SALARY<br>FROM CUSTOMERS<br>GROUP BY age<br>HAVING COUNT(age) &gt;= 2;</p>
<p>其执行结果如下所示：</p>
<p>+—-+——–+—–+———+———+<br>| ID | NAME | AGE | ADDRESS | SALARY |<br>+—-+——–+—–+———+———+<br>| 2 | Khilan | 25 | Delhi | 1500. 00 |<br>+—-+——–+—–+———+———+</p>
<p>十一、<strong>MYSQL</strong>用户管理</p>
<p>MySQL 是一个多用户数据库，具有功能强大的访问控制系统，可以为不同用户指定不同权限。在前面的章节中我们使用的是 root 用户，该用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户密码等管理权限。</p>
<p>为了实际项目的需要，可以创建拥有不同权限的普通用户。</p>
<p>通过本章的学习，读者可以了解到 MySQL 中的各种权限表、登录数据库的详细内容、用户管理和密码管理等。本章内容涉及到了数据库的安全，是数据库管理中非常重要的内容。</p>
<ol>
<li>MySQL user<strong>权限表详解</strong></li>
</ol>
<p>MySQL 在安装时会自动创建一个名为 mysql 的数据库，mysql 数据库中存储的都是用户权限表。用户登录以后，MySQL 会根据这些权限表的内容为每个用户赋予相应的权限。</p>
<p>user 表是 MySQL 中最重要的一个权限表，用来记录允许连接到服务器的账号信息。需要注意的是，在 user 表里启用的所有权限都是全局级的，适用于所有数据库。</p>
<p>user 表中的字段大致可以分为 4 类，分别是用户列、权限列、安全列和资源控制列，下面主要介绍这些字段的含义。</p>
<p>用户列</p>
<p>用户列存储了用户连接 MySQL 数据库时需要输入的信息。需要注意的是 MySQL 5. 7 版本不再使用 Password 来作为密码的字段，而改成了 authentication_string。</p>
<p>MySQL 5. 7 版本的用户列如表 1 所示。</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Host    char(60)    NO    无    主机名<br>User    char(32)    NO    无    用户名<br>authentication_string    text    YES    无    密码<br>用户登录时，如果这 3 个字段同时匹配，MySQL 数据库系统才会允许其登录。创建新用户时，也是设置这 3 个字段的值。修改用户密码时，实际就是修改 user 表的 authentication_string 字段的值。因此，这 3 个字段决定了用户能否登录。</p>
<p>权限列</p>
<p>权限列的字段决定了用户的权限，用来描述在全局范围内允许对数据和数据库进行的操作。</p>
<p>权限大致分为两大类，分别是高级管理权限和普通权限：</p>
<p>高级管理权限主要对数据库进行管理，例如关闭服务的权限、超级权限和加载用户等；<br>普通权限主要操作数据库，例如查询权限、修改权限等。<br>user 表的权限列包括 Select_priv、Insert_ priv 等以 priv 结尾的字段，这些字段值的数据类型为 ENUM，可取的值只有 Y 和 N：Y 表示该用户有对应的权限，N 表示该用户没有对应的权限。从安全角度考虑，这些字段的默认值都为 N。</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Select_priv    enum(‘N’,’Y’)    NO    N    是否可以通过SELECT 命令查询数据<br>Insert_priv    enum(‘N’,’Y’)    NO    N    是否可以通过 INSERT 命令插入数据<br>Update_priv    enum(‘N’,’Y’)    NO    N    是否可以通过UPDATE 命令修改现有数据<br>Delete_priv    enum(‘N’,’Y’)    NO    N    是否可以通过DELETE 命令删除现有数据<br>Create_priv    enum(‘N’,’Y’)    NO    N    是否可以创建新的数据库和表<br>Drop_priv    enum(‘N’,’Y’)    NO    N    是否可以删除现有数据库和表<br>Reload_priv    enum(‘N’,’Y’)    NO    N    是否可以执行刷新和重新加载MySQL所用的各种内部缓存的特定命令，包括日志、权限、主机、查询和表<br>Shutdown_priv    enum(‘N’,’Y’)    NO    N    是否可以关闭MySQL服务器。将此权限提供给root账户之外的任何用户时，都应当非常谨慎<br>Process_priv    enum(‘N’,’Y’)    NO    N    是否可以通过SHOW PROCESSLIST命令查看其他用户的进程<br>File_priv    enum(‘N’,’Y’)    NO    N    是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令<br>Grant_priv    enum(‘N’,’Y’)    NO    N    是否可以将自己的权限再授予其他用户<br>References_priv    enum(‘N’,’Y’)    NO    N    是否可以创建外键约束<br>Index_priv    enum(‘N’,’Y’)    NO    N    是否可以对索引进行增删查<br>Alter_priv    enum(‘N’,’Y’)    NO    N    是否可以重命名和修改表结构<br>Show_db_priv    enum(‘N’,’Y’)    NO    N    是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库<br>Super_priv    enum(‘N’,’Y’)    NO    N    是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程；使用SET GLOBAL命令修改全局MySQL变量，执行关于复制和日志的各种命令。（超级权限）<br>Create_tmp_table_priv    enum(‘N’,’Y’)    NO    N    是否可以创建临时表<br>Lock_tables_priv    enum(‘N’,’Y’)    NO    N    是否可以使用LOCK TABLES命令阻止对表的访问/修改<br>Execute_priv    enum(‘N’,’Y’)    NO    N    是否可以执行存储过程<br>Repl_slave_priv    enum(‘N’,’Y’)    NO    N    是否可以读取用于维护复制数据库环境的二进制日志文件<br>Repl_client_priv    enum(‘N’,’Y’)    NO    N    是否可以确定复制从服务器和主服务器的位置<br>Create_view_priv    enum(‘N’,’Y’)    NO    N    是否可以创建视图<br>Show_view_priv    enum(‘N’,’Y’)    NO    N    是否可以查看视图<br>Create_routine_priv    enum(‘N’,’Y’)    NO    N    是否可以更改或放弃存储过程和函数<br>Alter_routine_priv    enum(‘N’,’Y’)    NO    N    是否可以修改或删除存储函数及函数<br>Create_user_priv    enum(‘N’,’Y’)    NO    N    是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户<br>Event_priv    enum(‘N’,’Y’)    NO    N    是否可以创建、修改和删除事件<br>Trigger_priv    enum(‘N’,’Y’)    NO    N    是否可以创建和删除触发器<br>Create_tablespace_priv    enum(‘N’,’Y’)    NO    N    是否可以创建表空间<br>如果要修改权限，可以使用 GRANT 语句为用户赋予一些权限，也可以通过 UPDATE 语句更新 user 表的方式来设置权限。</p>
<p>安全列</p>
<p>安全列主要用来判断用户是否能够登录成功，user 表中的安全列如表 3 所示：</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>ssl_type    enum(‘’,’ANY’,’X509’,’SPECIFIED’)    NO        支持ssl标准加密安全字段<br>ssl_cipher    blob    NO        支持ssl标准加密安全字段<br>x509_issuer    blob    NO        支持x509标准字段<br>x509_subject    blob    NO        支持x509标准字段<br>plugin    char(64)    NO    mysql_native_password    引入plugins以进行用户连接时的密码验证，plugin创建外部/代理用户<br>password_expired    enum(‘N’,’Y’)    NO    N    密码是否过期 (N 未过期，y 已过期)<br>password_last_changed    timestamp    YES        记录密码最近修改的时间<br>password_lifetime    smallint(5) unsigned    YES        设置密码的有效时间，单位为天数<br>account_locked    enum(‘N’,’Y’)    NO    N    用户是否被锁定（Y 锁定，N 未锁定）<br>注意：即使 password_expired 为“Y”，用户也可以使用密码登录 MySQL，但是不允许做任何操作。</p>
<p>通常标准的发行版不支持 ssl，读者可以使用 SHOW VARIABLES LIKE “have_openssl” 语句来查看是否具有 ssl 功能。如果 have_openssl 的值为 DISABLED，那么则不支持 ssl 加密功能。</p>
<p>资源控制列</p>
<p>资源控制列的字段用来限制用户使用的资源，user 表中的资源控制列如表 4 所示。</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>max_questions    int(11) unsigned    NO    0    规定每小时允许执行查询的操作次数<br>max_updates    int(11) unsigned    NO    0    规定每小时允许执行更新的操作次数<br>max_connections    int(11) unsigned    NO    0    规定每小时允许执行的连接操作次数<br>max_user_connections    int(11) unsigned    NO    0    规定允许同时建立的连接次数<br>以上字段的默认值为 0，表示没有限制。一个小时内用户查询或者连接数量超过资源控制限制，用户将被锁定，直到下一个小时才可以在此执行对应的操作。可以使用 GRANT 语句更新这些字段的值。</p>
<ol start="2">
<li>MYSQL<strong>其他权限表</strong></li>
</ol>
<p>db<strong>表</strong></p>
<p>db 表比较常用，是 MySQL 数据库中非常重要的权限表，表中存储了用户对某个数据库的操作权限。表中的字段大致可以分为两类，分别是用户列和权限列。</p>
<p>用户列</p>
<p>db 表用户列有 3 个字段，分别是 Host、User、Db，标识从某个主机连接某个用户对某个数据库的操作权限，这 3 个字段的组合构成了 db 表的主键。</p>
<p>db 表的用户列如下表所示：</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Host    char(60)    NO    无    主机名<br>Db    char(64)    NO    无    数据库名<br>User    char(32)    NO    无    用户名<br>权限列</p>
<p>db 表中的权限列和 user 表中的权限列大致相同，只是user 表中的权限是针对所有数据库的，而 db 表中的权限只针对指定的数据库。如果希望用户只对某个数据库有操作权限，可以先将 user 表中对应的权限设置为 N，然后在 db 表中设置对应数据库的操作权限。</p>
<p>tables_priv<strong>表和columns_priv表</strong></p>
<p>tables_priv 表用来对单个表进行权限设置，columns_priv 表用来对单个数据列进行权限设置。tables_priv 表结构如下表所示：</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Host    char(60)    NO    无    主机<br>Db    char(64)    NO    无    数据库名<br>User    char(32)    NO    无    用户名<br>Table_name    char(64)    NO    无    表名<br>Grantor    char(93)    NO    无    修改该记录的用户<br>Timestamp    timestamp    NO    CURRENT_TIMESTAMP    修改该记录的时间<br>Table_priv    set(‘Select’,’Insert’,’Update’,’Delete’,’ Create’,’Drop’,’Grant’,’References’, ‘Index’,’Alter’,’Create View’,’Show view’,’Trigger’)    NO    无    表示对表的操作权限，包括 Select、Insert、Update、Delete、Create、Drop、Grant、References、Index 和 Alter 等<br>Column_priv    set(‘Select’,’Insert’,’Update’,’References’)    NO    无    表示对表中的列的操作权限，包括 Select、Insert、Update 和 References<br>columns_priv 表结构如下表所示：</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Host    char(60)    NO    无    主机<br>Db    char(64)    NO    无    数据库名<br>User    char(32)    NO    无    用户名<br>Table_name    char(64)    NO    无    表名<br>Column_name    char(64)    NO    无    数据列名称，用来指定对哪些数据列具有操作权限<br>Timestamp    timestamp    NO    CURRENT_TIMESTAMP    修改该记录的时间<br>Column_priv    set(‘Select’,’Insert’,’Update’,’References’)    NO    无    表示对表中的列的操作权限，包括 Select、Insert、Update 和 References<br>procs_priv<strong>表</strong></p>
<p>procs_priv 表可以对存储过程和存储函数进行权限设置，procs_priv 的表结构如表所示：</p>
<p>字段名    字段类型    是否为空    默认值    说明<br>Host    char(60)    NO    无    主机名<br>Db    char(64)    NO    无    数据库名<br>User    char(32)    NO    无    用户名<br>Routine_name    char(64)    NO    无    表示存储过程或函数的名称<br>Routine_type    enum(‘FUNCTION’,’PROCEDURE’)    NO    无    表示存储过程或函数的类型，Routine_type 字段有两个值，分别是 FUNCTION 和 PROCEDURE。FUNCTION 表示这是一个函数；PROCEDURE 表示这是一个 存储过程。<br>Grantor    char(93)    NO    无    插入或修改该记录的用户<br>Proc_priv    set(‘Execute’,’Alter Routine’,’Grant’)    NO    无    表示拥有的权限，包括 Execute、Alter Routine、Grant 3种<br>Timestamp    timestamp    NO    CURRENT_TIMESTAMP    表示记录更新时间<br>3. MySQL<strong>创建用户（3种方式）</strong></p>
<p>MySQL 在安装时，会默认创建一个名为 root 的用户，该用户拥有超级权限，可以控制整个 MySQL 服务器。</p>
<p>在对 MySQL 的日常管理和操作中，为了避免有人恶意使用 root 用户控制数据库，我们通常创建一些具有适当权限的用户，尽可能地不用或少用 root 用户登录系统，以此来确保数据的安全访问。</p>
<p>MySQL 提供了以下 3 种方法创建用户。</p>
<p>使用 CREATE USER 语句创建用户<br>在 mysql. user 表中添加用户<br>使用 GRANT 语句创建用户<br>下面根据实例详细讲解这 3 种方法。</p>
<ol>
<li> 使用<strong>CREATE USER</strong>语句创建用户</li>
</ol>
<p>可以使用 CREATE USER 语句来创建 MySQL 用户，并设置相应的密码。其基本语法格式如下：</p>
<p>CREATE USER &lt;用户&gt; [ IDENTIFIED BY [ PASSWORD ] ‘password’ ] [ ,用户 [ IDENTIFIED BY [ PASSWORD ] ‘password’ ]]</p>
<p>参数说明如下：</p>
<ol>
<li>用户</li>
</ol>
<p>指定创建用户账号，格式为 user_name‘@’host_name。这里的user_name是用户名，host_name为主机名，即用户连接 MySQL 时所用主机的名字。如果在创建的过程中，只给出了用户名，而没指定主机名，那么主机名默认为“%”，表示一组主机，即对所有主机开放权限。</p>
<ol start="2">
<li>IDENTIFIED BY<strong>子句</strong></li>
</ol>
<p>用于指定用户密码。新用户可以没有初始密码，若该用户不设密码，可省略此子句。</p>
<ol start="3">
<li>PASSWORD ‘password’</li>
</ol>
<p>PASSWORD 表示使用哈希值设置密码，该参数可选。如果密码是一个普通的字符串，则不需要使用 PASSWORD 关键字。’password’ 表示用户登录时使用的密码，需要用单引号括起来。</p>
<p>使用 CREATE USER 语句时应注意以下几点：</p>
<p>CREATE USER 语句可以不指定初始密码。但是从安全的角度来说，不推荐这种做法。<br>使用 CREATE USER 语句必须拥有 mysql 数据库的 INSERT 权限或全局 CREATE USER 权限。<br>使用 CREATE USER 语句创建一个用户后，MySQL 会在 mysql 数据库的 user 表中添加一条新记录。<br>CREATE USER 语句可以同时创建多个用户，多个用户用逗号隔开。<br>新创建的用户拥有的权限很少，它们只能执行不需要权限的操作。如登录 MySQL、使用 SHOW 语句查询所有存储引擎和字符集的列表等。如果两个用户的用户名相同，但主机名不同，MySQL 会将它们视为两个用户，并允许为这两个用户分配不同的权限集合。</p>
<p>例 1</p>
<p>使用 CREATE USER 创建一个用户，用户名是 test1，密码是 test1，主机名是 localhost。SQL 语句和执行过程如下。</p>
<p>mysql&gt; CREATE USER ‘test1‘@’localhost’ IDENTIFIED BY ‘test1’;<br>Query OK, 1 rows affected (0. 06 sec)</p>
<p>结果显示，创建 test1 用户成功。</p>
<p>在实际应用中，我们应避免明文指定密码，可以通过 PASSWORD 关键字使用密码的哈希值设置密码。</p>
<p>例 2</p>
<p>在 MySQL 中，可以使用 password() 函数获取密码的哈希值，查看 test1 哈希值的 SQL 语句和执行过程如下：</p>
<p>mysql&gt; SELECT password(‘test1’);<br>+——————————————-+<br>| password(‘test1’) |<br>+——————————————-+<br>| *06C0BF5B64ECE2F648B5F048A71903906BA08E5C |<br>+——————————————-+<br>1 row in set, 1 warning (0. 00 sec)</p>
<p>“*06C0BF5B64ECE2F648B5F048A71903906BA08E5C”就是 test1 的哈希值。下面创建用户 test1，SQL 语句和执行过程如下：</p>
<p>mysql&gt; CREATE USER ‘test1‘@’localhost’IDENTIFIED BY PASSWORD ‘*06C0BF5B64ECE2F648B5F048A71903906BA08E5C’;<br>Query OK, 0 rows affected, 1 warning (0. 00 sec)</p>
<p>执行成功后就可以使用密码“test1”登录了。</p>
<ol start="2">
<li> 使用 INSERT 语句新建用户</li>
</ol>
<p>可以使用 INSERT 语句将用户的信息添加到 mysql. user 表中，但必须拥有对 mysql. user 表的 INSERT 权限。通常 INSERT 语句只添加 Host、User 和 authentication_string 这 3 个字段的值。</p>
<p>MySQL 5. 7 的 user 表中的密码字段从 Password 变成了 authentication_string，如果你使用的是 MySQL 5. 7 之前的版本，将 authentication_string 字段替换成 Password 即可。</p>
<p>使用 INSERT 语句创建用户的代码如下：</p>
<p>INSERT INTO mysql. user(Host, User, authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (‘hostname’, ‘username’, PASSWORD(‘password’), ‘’, ‘’, ‘’);</p>
<p>由于 mysql 数据库的 user 表中，ssl_cipher、x509_issuer 和 x509_subject 这 3 个字段没有默认值，所以向 user 表插入新记录时，一定要设置这 3 个字段的值，否则 INSERT 语句将不能执行。</p>
<p>例 3</p>
<p>下面使用 INSERT 语句创建名为 test2 的用户，主机名是 localhost，密码也是 test2。SQL 语句和执行过程如下：</p>
<p>mysql&gt; INSERT INTO mysql. user(Host, User, authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (‘localhost’, ‘test2’, PASSWORD(‘test2’), ‘’, ‘’, ‘’);<br>Query OK, 1 row affected, 1 warning (0. 02 sec)</p>
<p>结果显示，新建用户成功。但是这时如果通过该账户登录 MySQL 服务器，不会登录成功，因为 test2 用户还没有生效。</p>
<p>可以使用 FLUSH 命令让用户生效，命令如下：</p>
<p>FLUSH PRIVILEGES;</p>
<p>使用以上命令可以让 MySQL 刷新系统权限相关表。执行 FLUSH 命令需要 RELOAD 权限。</p>
<p>注意：user 表中的 User 和 Host 字段区分大小写，创建用户时要指定正确的用户名称或主机名。</p>
<ol start="3">
<li> 使用<strong>GRANT</strong>语句新建用户</li>
</ol>
<p>虽然 CREATE USER 和 INSERT INTO 语句都可以创建普通用户，但是这两种方式不便授予用户权限。于是 MySQL 提供了 GRANT 语句。</p>
<p>使用 GRANT 语句创建用户的基本语法形式如下:</p>
<p>GRANT priv_type ON database. table TO user [IDENTIFIED BY [PASSWORD] ‘password’]</p>
<p>其中：</p>
<p>priv_type 参数表示新用户的权限；<br>database. table 参数表示新用户的权限范围，即只能在指定的数据库和表上使用自己的权限；<br>user 参数指定新用户的账号，由用户名和主机名构成；<br>IDENTIFIED BY 关键字用来设置密码；<br>password 参数表示新用户的密码。<br>例 4</p>
<p>下面使用 GRANT 语句创建名为 test3 的用户，主机名为 localhost，密码为 test3。该用户对所有数据库的所有表都有 SELECT 权限。SQL 语句和执行过程如下：</p>
<p>mysql&gt; GRANT SELECT ON.  TO ‘test3‘@localhost IDENTIFIED BY ‘test3’;<br>Query OK, 0 rows affected, 1 warning (0. 01 sec)</p>
<p>其中，“. ” 表示所有数据库下的所有表。结果显示创建用户成功，且 test3 用户对所有表都有查询（SELECT）权限。</p>
<p>技巧：GRANT 语句是 MySQL 中一个非常重要的语句，它可以用来创建用户、修改用户密码和设置用户权限。教程后面会详细介绍如何使用 GRANT 语句修改密码、更改权限。</p>
<ol start="4">
<li>MySQL<strong>修改用户（RENAME USER）</strong></li>
</ol>
<p>在 MySQL 中，我们可以使用 RENAME USER 语句修改一个或多个已经存在的用户账号。</p>
<p>语法格式如下：</p>
<p>RENAME USER &lt;旧用户&gt; TO &lt;新用户&gt;</p>
<p>其中：</p>
<p>&lt;旧用户&gt;：系统中已经存在的 MySQL 用户账号。<br>&lt;新用户&gt;：新的 MySQL 用户账号。<br>使用 RENAME USER 语句时应注意以下几点：</p>
<p>RENAME USER 语句用于对原有的 MySQL 用户进行重命名。<br>若系统中旧账户不存在或者新账户已存在，该语句执行时会出现错误。<br>使用 RENAME USER 语句，必须拥有 mysql 数据库的 UPDATE 权限或全局 CREATE USER 权限。<br>例 1</p>
<p>使用 RENAME USER 语句将用户名 test1 修改为 testUser1，主机是 localhost。SQL 语句和执行过程如下。</p>
<p>mysql&gt; RENAME USER ‘test1‘@’localhost’<br>-&gt; TO ‘testUser1‘@’localhost’;<br>Query OK, 0 rows affected (0. 03 sec)</p>
<p>在 cmd 命令行工具中，使用 testUser1 用户登录数据库服务器，如下所示。</p>
<p>C:\Users\USER&gt;mysql -h localhost -u testUser1 -p<br>Enter password: *<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 7<br>Server version: 5. 7. 20-log MySQL Community Server (GPL)<br>Copyright (c) 2000, 2017, Oracle and/or its affiliates.  All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates.  Other names may be trademarks of their respective<br>owners.<br>Type ‘help;’ or ‘\h’ for help.  Type ‘\c’ to clear the current input statement. </p>
<hr>
<h2 id="十二、数据库三大模式"><a href="#十二、数据库三大模式" class="headerlink" title="十二、数据库三大模式"></a>十二、数据库三大模式</h2><p>人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括外模式、概念模式、内模式，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。用户级对应外模式，概念级对应概念模式，物理级对应内模式，使不同级别的用户对数据库形成不同的视图。所谓视图，就是指观察、认识和理解数据的范围、角度和方法，是数据库在用户“眼中”的反映，很显然，不同层次（级别）用户所“看到”的数据库是不相同的。</p>
<p>外模式 外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。</p>
<p>概念模式 概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。</p>
<p>内模式 内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。 在一个数据库系统中，只有唯一的数据库， 因而作为定义 、描述数据库存储结构的内模式和定义、描述数据库逻辑结构的模式，也是唯一的，但建立在数据库系统之上的应用则是非常广泛、多样的，所以对应的外模式不是唯一的，也不可能是唯一的。</p>
]]></content>
  </entry>
  <entry>
    <title>与我相关</title>
    <url>/2030/12/31/%E4%B8%8E%E6%88%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>一个普普通通的大学生 爱好前端 知识分享<br>希望我们能一起进步 一起为前端添砖加瓦！</p>
</blockquote>
<span id="more"></span>
<hr>
<h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><table>
<thead>
<tr>
<th>QQ</th>
<th>WecChat</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.jsdelivr.net/gh/GOODFLYO/CDN/blogConfig/self/ADDQQ.jpg" style="height:200px" /></td>
<td><img src="https://cdn.jsdelivr.net/gh/GOODFLYO/CDN/blogConfig/self/ADDWECHAT.jpg" style="height:200px" /></td>
</tr>
</tbody></table>
<hr>
<h3 id="个人推荐"><a href="#个人推荐" class="headerlink" title="个人推荐"></a>个人推荐</h3><p><strong>科学上网</strong></p>
<ol>
<li><a href="https://latiao.club/#/register?code=1qAt6V3N">点击此处注册账号</a></li>
<li>填入我的邀请码:1qAt6V3N  优惠码 8888</li>
<li>随便选择一个即可购买 <img src="https://cdn.jsdelivr.net/gh/GOODFLYO/CDN/images/techonline/image-20220501210419771.png"></li>
<li>一定要看<a href="https://latiao.club/#/knowledge">使用文档</a>哟 </li>
<li>使用 <strong>clash</strong> 的一定要勾选 <strong>system proxy</strong> <img src="https://cdn.jsdelivr.net/gh/GOODFLYO/CDN/images/techonline/image-20220501210921927.png"></li>
<li>当然，你有不会的地方 ，可以加我的联系方式询问</li>
<li>因为输入我的邀请码可以让我<strong>获得部分佣金</strong>且<strong>购买更便宜</strong> 介意的话可以输入别人的哟</li>
</ol>
]]></content>
      <categories>
        <category>与我相关</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>联系方式</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路线</title>
    <url>/2030/12/31/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>[toc]</p>
<blockquote>
<p><strong>学习方式各有不同，我只整理的自己的侧重点</strong></p>
</blockquote>
<span id="more"></span>

<h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h1><ul>
<li><input checked="" disabled="" type="checkbox"> html、css 核心基础</li>
<li><input checked="" disabled="" type="checkbox"> html5 语义化标签</li>
<li><input checked="" disabled="" type="checkbox"> html5 新增标签属性</li>
<li><input checked="" disabled="" type="checkbox"> 表单项新增属性</li>
<li><input checked="" disabled="" type="checkbox"> css 选择器</li>
<li><input checked="" disabled="" type="checkbox"> css3 伪类</li>
<li><input checked="" disabled="" type="checkbox"> css 伪元素</li>
<li><input disabled="" type="checkbox"> css 过渡</li>
<li><input disabled="" type="checkbox"> 线性渐变、径向渐变</li>
<li><input disabled="" type="checkbox"> css 都规划 animation</li>
<li><input checked="" disabled="" type="checkbox"> 弹性盒模型</li>
<li><input disabled="" type="checkbox"> 响应式布局</li>
</ul>
<hr>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 基本语法</li>
<li><input disabled="" type="checkbox"> 版本</li>
<li><input checked="" disabled="" type="checkbox"> 对象</li>
<li><input checked="" disabled="" type="checkbox"> 函数</li>
<li><input disabled="" type="checkbox"> 类</li>
<li><input checked="" disabled="" type="checkbox"> DOM</li>
<li><input checked="" disabled="" type="checkbox"> BOM</li>
<li><input disabled="" type="checkbox"> Web API</li>
<li><input disabled="" type="checkbox"> AJAX</li>
<li><input checked="" disabled="" type="checkbox"> JSON</li>
<li><input checked="" disabled="" type="checkbox"> jQuery</li>
</ul>
<hr>
<h1 id="ES6-Node-工程化"><a href="#ES6-Node-工程化" class="headerlink" title="ES6+Node+工程化"></a>ES6+Node+工程化</h1><ul>
<li><input disabled="" type="checkbox"> ES6/7/8</li>
<li><input checked="" disabled="" type="checkbox"> npm 常用命令</li>
<li><input checked="" disabled="" type="checkbox"> git 基础</li>
<li><input disabled="" type="checkbox"> git 高级</li>
<li><input disabled="" type="checkbox"> http 协议 &amp; cookie &amp; session</li>
<li><input disabled="" type="checkbox"> ES6+Node+工程化 MongoDB</li>
<li><input disabled="" type="checkbox"> 模块化</li>
<li><input disabled="" type="checkbox"> 构建工具 gulp</li>
<li><input disabled="" type="checkbox"> webpack</li>
<li><input disabled="" type="checkbox"> promise</li>
<li><input checked="" disabled="" type="checkbox"> Node.js 基础</li>
</ul>
<hr>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><ul>
<li><input checked="" disabled="" type="checkbox"> React 基础语法</li>
<li><input disabled="" type="checkbox"> react-router</li>
<li><input disabled="" type="checkbox"> React React Antd 使用</li>
<li><input disabled="" type="checkbox"> Redux</li>
<li><input disabled="" type="checkbox"> React 移动端项目</li>
</ul>
<hr>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul>
<li><input checked="" disabled="" type="checkbox"> Vue 基础</li>
<li><input disabled="" type="checkbox"> VueRouter</li>
<li><input disabled="" type="checkbox"> Vuex</li>
<li><input disabled="" type="checkbox"> Vue</li>
<li><input disabled="" type="checkbox"> Vue 源码</li>
<li><input disabled="" type="checkbox"> VuePC 项目</li>
<li><input disabled="" type="checkbox"> Vue 后台管理</li>
</ul>
<hr>
<h1 id="参考提供"><a href="#参考提供" class="headerlink" title="参考提供"></a>参考提供</h1><p><a href="https://objtube.github.io/front-end-roadmap/#/">前端学习路线</a></p>
]]></content>
  </entry>
  <entry>
    <title>APPilike</title>
    <url>/2022/12/14/APPilike/</url>
    <content><![CDATA[<p>[toc]</p>
<hr>
<h3 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a>Clash</h3><p>💕 科学上网必备💕<br>💕 <a href="https://goodflyo.github.io/2021/05/26/%E4%B8%8E%E6%88%91%E7%9B%B8%E5%85%B3/#more">clash详细信息</a>💕</p>
<hr>
<h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><span id="more"></span>
<table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
<th>图标</th>
</tr>
</thead>
<tbody><tr>
<td>win 自带画图工具</td>
<td>简洁的面板 多种工具</td>
<td><img src="https://img.onlinedown.net/download/202110/141352-6167caa016630.jpg" style="height:55px;" /></td>
</tr>
<tr>
<td>oCam</td>
<td>录屏软件 体积小 录屏质量高</td>
<td><img src="https://img2.baidu.com/it/u=1891138054,3556825058&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500" style="height:55px" /></td>
</tr>
<tr>
<td>快剪辑</td>
<td>剪辑方便基础功能丰富</td>
<td><img src="https://img2.baidu.com/it/u=708818509,1951590481&fm=253&fmt=auto&app=138&f=PNG?w=256&h=256" style="height:55px" /></td>
</tr>
<tr>
<td>洛雪音乐</td>
<td>千万音乐随便下载 非常无敌</td>
<td><img src="https://img0.baidu.com/it/u=2973469365,2346081691&fm=253&fmt=auto&app=138&f=PNG?w=220&h=150" style="height:55px" /></td>
</tr>
<tr>
<td>IDM 绿色版</td>
<td>超高速下载+配合百度网盘使用</td>
<td><img src="https://img2.baidu.com/it/u=3696265634,1526834780&fm=253&fmt=auto&app=138&f=PNG?w=256&h=256" style="height:55px" /></td>
</tr>
<tr>
<td>蓝奏云客户端</td>
<td>批量传输+批量转移</td>
<td><img src="https://img1.baidu.com/it/u=2073188427,2824667698&fm=253&fmt=auto&app=138&f=PNG?w=243&h=132" style="height:55px" /></td>
</tr>
<tr>
<td>阿里云盘</td>
<td>上传和下载都很快 可是不能自由分享</td>
<td><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp2.itc.cn%2Fq_70%2Fimages03%2F20211009%2F59c75745d3524163b9277c4006020ac0.jpeg&refer=http%3A%2F%2Fp2.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1673668758&t=5447eeb39099d7ebac4d8ab57621b747" style="height:55px" /></td>
</tr>
<tr>
<td>typora</td>
<td>简直无敌了 markdown编辑器—当然也支持各种格式</td>
<td><img src="https://img0.baidu.com/it/u=2788885325,377457777&fm=253&fmt=auto&app=138&f=PNG?w=256&h=256" style="height:55px" /></td>
</tr>
<tr>
<td>Fiddler Classic</td>
<td>电脑抓包工具 可以监听https</td>
<td><img src="https://img2.baidu.com/it/u=1346851621,972883484&fm=253&fmt=auto&app=138&f=PNG?w=256&h=256" style="height:55px" /></td>
</tr>
<tr>
<td>electerm</td>
<td>开源的远程连接工具</td>
<td><img src="https://img1.baidu.com/it/u=2723696682,2115268521&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500" style="height:55px" /></td>
</tr>
<tr>
<td>vsode</td>
<td>超级无敌宇宙噼里啪啦IDE</td>
<td><img src="https://img1.baidu.com/it/u=1636506776,3169403695&fm=253&fmt=auto&app=138&f=JPEG?w=752&h=500" style="height:55px" /></td>
</tr>
<tr>
<td>GOOGLE</td>
<td>配上各类插件和脚本 无敌的存在</td>
<td><img src="https://img1.baidu.com/it/u=1785270759,3943942543&fm=253&fmt=auto&app=120&f=JPEG?w=816&h=487" style="height:55px" /></td>
</tr>
<tr>
<td>网易云音乐</td>
<td>个人喜欢 不介绍</td>
<td><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.downza.cn%2Fxueyuan%2F202111%2F5fa12703a4057330ee5cc1512d159377.png&refer=http%3A%2F%2Fimg3.downza.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1673669014&t=bd5155d51f678d78e94cbb5c16d9e5ff" style="height:55px" /></td>
</tr>
<tr>
<td>小丸工具箱</td>
<td>处理视频的好工具–解码转换等等</td>
<td><img src="https://img1.baidu.com/it/u=1574076885,3181424076&fm=253&fmt=auto&app=138&f=PNG?w=256&h=256" style="height:55px" /></td>
</tr>
<tr>
<td>腾讯会议</td>
<td>通讯效果好 容量大</td>
<td><img src="https://img0.baidu.com/it/u=2387743273,1319507866&fm=253&fmt=auto&app=138&f=JPEG?w=400&h=267" style="height:55px" /></td>
</tr>
<tr>
<td>格式工厂</td>
<td>视频格式转化 功能很多 比较耗费gpu</td>
<td><img src="https://img0.baidu.com/it/u=2605668262,354975190&fm=253&fmt=auto&app=138&f=JPEG?w=170&h=170" style="height:55px" /></td>
</tr>
</tbody></table>
<hr>
<h3 id="Android端"><a href="#Android端" class="headerlink" title="Android端"></a>Android端</h3><table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
<th>图标</th>
</tr>
</thead>
<tbody><tr>
<td>bilibili</td>
<td>视频质量较高 奈何老板作死</td>
<td><img src="https://img2.baidu.com/it/u=3444794441,3761663944&fm=253&fmt=auto&app=120&f=JPEG?w=669&h=604" style="height:55px" /></td>
</tr>
<tr>
<td>豆果美食</td>
<td>各种原创食谱</td>
<td><img src="https://img1.baidu.com/it/u=2547362733,133834015&fm=253&fmt=auto&app=138&f=PNG?w=192&h=192" style="height:55px" /></td>
</tr>
<tr>
<td>listen1</td>
<td>必不可少的音乐神器</td>
<td><img src="https://img0.baidu.com/it/u=1569927342,4215404422&fm=253&fmt=auto&app=138&f=JPEG?w=766&h=386" style="height:55px" /></td>
</tr>
<tr>
<td>解压缩全能王</td>
<td>可以破解压缩密码 解压能力超强–7z rar</td>
<td><img src="https://img2.baidu.com/it/u=499996747,2707825643&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500" style="height:55px" /></td>
</tr>
<tr>
<td>小红书</td>
<td>找到自己的爱好 拒绝孤单</td>
<td><img src="https://img1.baidu.com/it/u=1943371915,3584795604&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500" style="height:55px" /></td>
</tr>
<tr>
<td>云闪付</td>
<td>集成各大银行 优惠活动多且大</td>
<td><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.sj33.cn%2Fuploads%2F202102%2F7-21022G32225U9.jpg&refer=http%3A%2F%2Fimg.sj33.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1673670193&t=e2f5288abd3a86a1e61210151e10b4fe" style="height:55px" /></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>加密货币</title>
    <url>/2022/05/20/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/</url>
    <content><![CDATA[<h1 id="加密货币复习"><a href="#加密货币复习" class="headerlink" title="加密货币复习"></a>加密货币复习</h1><h2 id="区块链发展历程"><a href="#区块链发展历程" class="headerlink" title="区块链发展历程"></a>区块链发展历程</h2><h3 id="区块链1-0-可编程货币"><a href="#区块链1-0-可编程货币" class="headerlink" title="区块链1.0 可编程货币"></a>区块链1.0 可编程货币</h3><span id="more"></span>

<p><strong>比特币为代表的货币区块链技术为1.0</strong></p>
<p>08年，中本聪详细描述了如何创建一套去中心化的电子交易体系，且这种体系不需要创建在交易双方相互信任的基础之上。分布式账本技术的实施导致其第一个明显的应用：加密货币。比特币用作“互联网现金”，一种数字支付系统，可以被视为“货币互联网”的推动者。相关数字货币：比特币BTC、莱特币LTC、</p>
<p>应用：利用密码学货币进行数字化支付，例如转账、汇款，起到公共账本的作用</p>
<p><strong>区块链2.0 可编程金融</strong></p>
<p>以太坊为代表的合同区块链技术为2.0</p>
<p>自比特币诞生后，人们认识到比特币的底层技术区块链天生可以为智能合约提供可信的执行环境。数字货币开始与智能合约相结合，使得该区块链技术在金融领域有了更广泛的应用场景，同时该技术应用下的交易流程得到了优化。</p>
<p>应用：可在以太坊中创建去中心化的程序、自治组织以及部署、使用智能合约</p>
<p><strong>区块链3.0 可编程社会</strong></p>
<p>实现完备权限控制和安全保障的Hyperledger项目代表3.0</p>
<p>区块链3.0是智能化物联网时代，不同于区块链1.0和区块链2.0只在金融领域被应用，区块链3.0超出金融领域，为各种行业提供去中心化解决方案。区块链的应用领域扩展到人类生活的方方面面，不再依靠某个第三人或者机构获取信任，实现信息的共享，提高整个系统的运转效率。</p>
<h3 id="为什么说区块链技术的应用是从信息互联网到价值互联网？"><a href="#为什么说区块链技术的应用是从信息互联网到价值互联网？" class="headerlink" title="为什么说区块链技术的应用是从信息互联网到价值互联网？"></a>为什么说区块链技术的应用是从信息互联网到价值互联网？</h3><p>区块链提供了一种加密安全的端到端支付流程，具有交易不变性和信息共享的一致性。价值互联网设想了一个价值移动和交换的世界。借助价值互联网，外币支付等价值交易可以立即发生。这不仅仅是金钱。价值互联网可以实现对某人有价值的任何资产的交换，包括证券、知识产权、音乐、科学发现等。区块链通过密码学、分布式共识、链式结构等机制实现了确权及允许任何类型的资产从一方直接转移到另一方，而无需中间人。转移是经过验证的、永久的并立即完成的。</p>
<p>有了“确权”和“交换”，价值就能完成了。而区块链正是解决了这两个问题，才成为了第三代互联网价值互联网的基石，让价值互联网成为可能和现实。</p>
<h3 id="区块链的部署有哪三种形势，每种部署形式的特点，国内区块链应用以哪种部署形势为主？"><a href="#区块链的部署有哪三种形势，每种部署形式的特点，国内区块链应用以哪种部署形势为主？" class="headerlink" title="区块链的部署有哪三种形势，每种部署形式的特点，国内区块链应用以哪种部署形势为主？"></a>区块链的部署有哪三种形势，每种部署形式的特点，国内区块链应用以哪种部署形势为主？</h3><p>公有链：全世界任何拥有联网计算机的用户都可以在任何时候加入或退出网络。</p>
<p>任意读取区块数据、执行交易，参与网络共识过程。共识算法：PoW、PoS等。</p>
<p>联盟链：由若干机构组成利益相关的联盟，共同参与并维护具有准入机制的多中心化区块链。区块数据读写、参与记账规则等需要由联盟成员节点共同决定。联盟链上的交易只需要少量节点达成共识即可，且节点间信任度比公有链要高。与公有链相比，其效率也有很大的提升。共识算法：PBFT、Raft等。</p>
<p>私有链：写入权限仅在一个组织手里的区块链，而读取权限或者对外开放，或者被任意程度地进行了限制。</p>
<p>国内区块链应用以联盟链为主。</p>
<p>以区块链六层参考架构为例说明每层主要功能及用途。<br>应用层：可编程货币，可编程合约，可编程社会<br>合约层：脚本代码，算法机制，智能合约—&gt;智能合约<br>激励层：发行机制，分配机制—&gt;经济激励<br>共识层：PoW，PoS，DPoS，PBFT—&gt;分布式信任，众包协作<br>网络层：P2P网络，传播机制，验证机制—&gt;分布式自治<br>数据层：数据区块，链式结构，时间戳，哈希函数，默克尔树，非对称加密—&gt;数据安全</p>
<h3 id="比特币与区块链的关系是什么？对比特币每个区块的数据结构进行说明，并给出block-header的每个字段长度及意义。"><a href="#比特币与区块链的关系是什么？对比特币每个区块的数据结构进行说明，并给出block-header的每个字段长度及意义。" class="headerlink" title="比特币与区块链的关系是什么？对比特币每个区块的数据结构进行说明，并给出block header的每个字段长度及意义。"></a>比特币与区块链的关系是什么？对比特币每个区块的数据结构进行说明，并给出block header的每个字段长度及意义。</h3><p>比特币是一种数字货币,而区块链是一种技术;区块链是比特币的底层技术,而比特币是区块链技术的第一个应用.</p>
<p>区块数据结构参考下图，对区块头的每个字段意义要求记住。</p>
<p>!</p>
<h3 id="简述比特币密钥和地址的生成过程，为什么能够从地址推导出公钥哈希值？"><a href="#简述比特币密钥和地址的生成过程，为什么能够从地址推导出公钥哈希值？" class="headerlink" title="简述比特币密钥和地址的生成过程，为什么能够从地址推导出公钥哈希值？"></a>简述比特币密钥和地址的生成过程，为什么能够从地址推导出公钥哈希值？</h3><p>私钥生成:私钥其本质就是一个256位的由0和1组成的随机数，这个随机数是怎么产生的不重要，只要是不可预测和不可重复的都可以，私钥的格式是将这个256位的随机数以64位十六进制数显示。</p>
<p>公钥生成:公钥是将私钥通过一个椭圆曲线乘法的算法计算得来，这是一个不可逆转的过程。</p>
<p>地址生成:比特币地址是由公钥经过一系列单向的哈希算法得到。哈希算法是一种单向函数，可以接收任意长度的输入产生指纹或哈希。由公钥生成比特币地址时使用的算法是SHA256和RIPEMD160。公钥先进行SHA256和RIPEMD160后得到公钥哈希,在经过Base58check编码就可以得到比特币地址。将地址经过逆向变换就可以得公钥的哈希值.</p>
<h3 id="简述比特币钱包的作用和种类？"><a href="#简述比特币钱包的作用和种类？" class="headerlink" title="简述比特币钱包的作用和种类？"></a>简述比特币钱包的作用和种类？</h3><p>广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。</p>
<p>简述比特币的交易流程，指出锁定脚本和解锁脚本放置的位置，并以P2PKH为例说明交易脚本的执行过程，并给出压栈出栈的顺序（可以手绘照相插入到word文档中）<br>1<strong>、比特币交易的创建：比特币交易可以被任何人在线上或线下创建，但要使交易有效，则需要由一个或多个私钥签名，表明具备交易中发送方地址所指向的比特币资金的所有权。2、比特币交易广播到整个P2P网络：一笔比特币交易数经过签名但不会泄露任何信息，可以被公开传播。每个节点都将从网络中收集交易数据并广播给相连接的其他节点。在传播交易前，节点均进行独立验证，确保有效性，异常交易无法传播。比特币网络是点对点网络，交易的扩散迅速，指数级扩散。3、比特币交易验证与挖矿：每个节点维护一个交易池，存放临时未经确认的交易。节点从交易池中选择一系列交易构成一个区块，基于自身算力找到一个具有足够难度的工作量证明，找到后向所有节点广播此区块。4、比特币交易确认：当包含在区块中的所有交易都是有效的且交易输入未动用，其他节点才会接受这个新的区块，链接到自己的区块链的尾部。5、交易记录：</strong>交易得到全网的6个确认之后，永久的记录在区块链中。</p>
<p>下图中指出了解锁脚本在输入列表里，锁定脚本在输出列表里</p>
<p>P2PKH脚本的执行指针执行过程和栈上变化如下：</p>
<h3 id="比特币的共识机制是什么？比特币挖矿的难度值如何调整能满足每10分钟产生一个区块，并说明如何调整区块头中字段来调整挖矿难度？区块头当中的哪些字段能够调整用于生成满足当前难度目标值的区块头哈希值？"><a href="#比特币的共识机制是什么？比特币挖矿的难度值如何调整能满足每10分钟产生一个区块，并说明如何调整区块头中字段来调整挖矿难度？区块头当中的哪些字段能够调整用于生成满足当前难度目标值的区块头哈希值？" class="headerlink" title="比特币的共识机制是什么？比特币挖矿的难度值如何调整能满足每10分钟产生一个区块，并说明如何调整区块头中字段来调整挖矿难度？区块头当中的哪些字段能够调整用于生成满足当前难度目标值的区块头哈希值？"></a>比特币的共识机制是什么？比特币挖矿的难度值如何调整能满足每10分钟产生一个区块，并说明如何调整区块头中字段来调整挖矿难度？区块头当中的哪些字段能够调整用于生成满足当前难度目标值的区块头哈希值？</h3><p>比特币区块链采用了PoW共识机制。</p>
<p>比特币每产生2016个区块调整一次挖矿难度，通过调整挖矿难度来调整出块时间，新难度值=旧难度值×（过去2016个区块花费时长/20160分钟），一个块10分钟，挖矿难度的计算公式：难度值= 最大目标值/难度目标值（或难度目标值 = 最大目标值/难度值），最大目标值= 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF，难度目标值越小，区块生成难度值就越大。 这个难度目标值被保存在比特币的区块头中Bits字段中。</p>
<p>SPV节点如何完成SPV验证（说明什么是Merkle Path Proof），Bloom Filter工作原理及SPV节点如何通过Bloom Filter完成指定交易的搜索。<br>Bloom过滤器数组里的每一个数的初始值为零。</p>
<p>关键词被加到Bloom过滤器中之前，会依次通过每个哈希函数运算一次。</p>
<p>关键词依次通过各哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。</p>
<p>Bloom过滤器正匹配代表着“可能是”，负匹配代表着“一定不是”。所以SPV节点若只关心某个支付到自己比特币地址的交易，则可通过建立布隆过滤器（布隆过滤器是一种基于哈希的高效查找结构，能够快速确定某个元素是否在一个集合内）限制只接收含有目标比特币地址的交易。一旦比特币网络中其他当节点探测到某个交易符合SPV节点设置的布隆过滤器条件时，其它节点将以Merkleblock消息的形式发送该区块，Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。</p>
<p>SPV节点需要验证交易，需要做2个检查：交易的存在性检查和交易是否重花的检查。</p>
<p>SPV节点通过该Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易（该过程被称为：Merkle Path Proof）。SPV节点所收到的Merkleblock数据量通常少于1KB，只有一个完整区块（大约1MB）大小的千分之一左右。</p>
<p>现在通过Merkle Path Proof，SPV节点确认了交易确实存在于区块链中，但是这个还是无法保证这笔交易（Transaction）的Input（引用的上一笔UTXO）没有被重花（双重支付）。</p>
<p>这时候SPV节点通过去看这笔交易所在区块之后的区块个数，Block个数越多说明该区块被全网更多节点共识，一般来说，一笔交易所属区块之后的区块个数达到6个时，就说明这笔交易是被大家核准过（达成共识）的，没有重花，而且被篡改的可能性也很低。</p>
<p>Merkle Path Proof是指假设区块链系统中某个区块中存在A，B，C，D四笔交易，则为了确认交易C是否存在，需要得到交易C到Merkle Tree根节点上整条路径中的其余哈希值，以下图为例就是需要得到N3，N4哈希值，通过验证根节点的哈希一致性确认交易C存在于区块中。</p>
<h3 id="什么是UTXO账本模型？如果我需要获得某个地址上的余额总数，该怎么做？和传统的账户模型有什么差别？"><a href="#什么是UTXO账本模型？如果我需要获得某个地址上的余额总数，该怎么做？和传统的账户模型有什么差别？" class="headerlink" title="什么是UTXO账本模型？如果我需要获得某个地址上的余额总数，该怎么做？和传统的账户模型有什么差别？"></a>什么是UTXO账本模型？如果我需要获得某个地址上的余额总数，该怎么做？和传统的账户模型有什么差别？</h3><p>比特币交易中的基础构建单元是交易输出。交易输出是比特币不可分割的基本组合，记录在区块上。比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”即UTXO；所有UTXO的集合被称为UTXO集。比特币“余额”：用户钱包中可用UTXO总和，分散在多个交易和区块中。通过钱包所控制的密钥控制UTXO花费行为。UTXO是面值为“聪”的离散且不可分割的价值单元，一个UTXO只能在一次交易中作为一个整体被消耗。一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。</p>
<p>UTXO 模型的优点：如果用户启用了新的地址用于转账和交易，新地址与原地址之间的关系很难被追踪，更好保证用户的隐私；UTXO 模型理论上来说可以并行地签发多笔交易，并广播到网络中；</p>
<h3 id="比特币区块链有哪几种分叉，每种分叉的原因是什么？"><a href="#比特币区块链有哪几种分叉，每种分叉的原因是什么？" class="headerlink" title="比特币区块链有哪几种分叉，每种分叉的原因是什么？"></a>比特币区块链有哪几种分叉，每种分叉的原因是什么？</h3><p>临时分叉：算法导致的分叉，通过最大工作量证明保证最终收敛性。</p>
<p>硬分叉：出现了旧规则禁止，新规则允许的行为。</p>
<p>软分叉：出现了旧规则允许，新规则禁止的行为。</p>
<p>举例说明比特币的链上扩容和链下扩容。<br>链上扩容是在区块链基层协议上实现的扩容解决方案，它需要通过改变区块容量或者数据结构来达到提高处理交易能力的目的。包括：比特币采用的隔离见证+2MB硬分叉，比特币现金升级区块容量，以及以太坊分片技术</p>
<p>链下扩容是不改变公链基础协议的一种应用层上的扩展方案。它不改动区块链本身的规则。包括状态通道、侧链等解决方案。</p>
<p>举例说明侧链的典型应用场景。<br>侧链技术就是为了方便数字资产在不同区块链间互相转移，在两条链完全独立的情况下，将不同的区块链互相连接在一起，以实现区块链的扩展，使两者能够“互相操作，实现交互”的一种跨区块链解决方案。</p>
<p>BTC Relay是一个典型应用场景，本质上是在以太坊上用合约重写了比特币的spv验证规则。其主要原理是把以太坊网络与比特币网络以一种安全去中心化的方式连接起来。通过使用以太坊的智能合约功能来验证比特币交易。BTC Relay使用区块头创建一种小型版本的比特币区块链，以太坊DApp开发者可以从智能合约向BTC Relay进行API调用来验证比特币网络活动。</p>
<h3 id="说明闪电网络解决了比特币系统的什么问题及其如何解决的？"><a href="#说明闪电网络解决了比特币系统的什么问题及其如何解决的？" class="headerlink" title="说明闪电网络解决了比特币系统的什么问题及其如何解决的？"></a>说明闪电网络解决了比特币系统的什么问题及其如何解决的？</h3><p>比特币的交易网络，全网每秒 7 笔的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认花费约 1 个小时的最终确认时间。闪电网络是将大量交易放到比特币区块链之外进行。闪电网络通过智能合约来完善链下的交易渠道。核心的概念主要有两个：RSMC和 HTLC。前者解决了链下交易的确认问题，后者解决了支付通道的问题。</p>
<h3 id="以太坊解决了比特币的哪些问题？"><a href="#以太坊解决了比特币的哪些问题？" class="headerlink" title="以太坊解决了比特币的哪些问题？"></a>以太坊解决了比特币的哪些问题？</h3><p>1.缺少图灵完备性，比特币不能支持所有的计算，如循环控制等。2价值盲，UTXO的不可分割性，使得其不能为账户的取款额度提供精细的控制。3缺少状态， UTXO只能用于建立简单的、一次性的合约，没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。4区块链盲，UTXO看不到区块链的数据5交易确认时间太长。</p>
<p>以太坊的发展经历过那几个阶段，每个阶段进行了哪些重大升级？<br>以太坊的发展分成四个阶段：Frontier、Homestead、Metropolis和Serenity。</p>
<h3 id="简述以太坊技术体系，每层提供哪些功能服务。"><a href="#简述以太坊技术体系，每层提供哪些功能服务。" class="headerlink" title="简述以太坊技术体系，每层提供哪些功能服务。"></a>简述以太坊技术体系，每层提供哪些功能服务。</h3><p>应用层：DApps，以太币钱包，以太币浏览器 合约层：Solidity，EVM，eWASM 激励层：以太币，Gas共识层：PoW，PoW和PoS混合，PoS 网络层：DEVp2p，RLPx，Discv4 数据层：数据结构，数据模型，分片技术，哈希函数，数字签名，非对称加密 存储层：LevelDB，ethdb模块，日志模块</p>
<h3 id="简述以太坊区块结构，并说明区块头中的三棵树是如何构建的？有哪些作用。"><a href="#简述以太坊区块结构，并说明区块头中的三棵树是如何构建的？有哪些作用。" class="headerlink" title="简述以太坊区块结构，并说明区块头中的三棵树是如何构建的？有哪些作用。"></a>简述以太坊区块结构，并说明区块头中的三棵树是如何构建的？有哪些作用。</h3><p>交易树：树叶里是交易<br>收据树：树叶里是交易生成的收据<br>状态数：树叶里是交易影响到的账户状态<br>基于Merkle Patricia Trie/tree（MPT）构建三棵树，通过三棵树根哈希，分别建立于区块头相应字段的映射关系<br>交易树根哈希：交易字典树根的RLP hash值（key：交易编号；Value：交易内容）<br>收据树根哈希：收据字典树根的RLP hash值（key：索引编号；Value：收据内容）<br>状态树根哈希：状态字典树根的RLP hash值（key：账户地址；Value：账户内容）</p>
<h3 id="什么是Merkle-Patricia-Tree-Trie？为什么不能用Merkle-Tree来存放以太坊账户状态？以太坊对其进行了哪些方面的优化？"><a href="#什么是Merkle-Patricia-Tree-Trie？为什么不能用Merkle-Tree来存放以太坊账户状态？以太坊对其进行了哪些方面的优化？" class="headerlink" title="什么是Merkle Patricia Tree/Trie？为什么不能用Merkle Tree来存放以太坊账户状态？以太坊对其进行了哪些方面的优化？"></a>什么是Merkle Patricia Tree/Trie？为什么不能用Merkle Tree来存放以太坊账户状态？以太坊对其进行了哪些方面的优化？</h3><p>Patricia Trie，又称基数树，是一种存储空间优化的Trie树。</p>
<p>MPT（Merkle Patricia Trie/Tree）融合了Patricia Trie和Merkle Tree的优点。其中Merkle树用于交易存在和完整性的校验，Patricia树用于优化字典树的空间利用率，同时提升读写效率。</p>
<p>如果直接将Merkle Tree来存放以太坊账户状态，那么存放全球账户数据太多，占内存和存储空间，账户状态多变，修改困难。</p>
<p>以太坊对其进行了以下方面的优化：1）提高操作效率：引入多种类型节点和压缩前缀2）安全性：每节点利用其哈希被引用，可在LevelDB中查询；而非内存地址。</p>
<p>Key：节点的RLP编码的SHA3哈希值。</p>
<p>Value：节点的RLP编码。</p>
<p>想获得一个非叶节点的子节点，只需要根据子节点的hash访问数据库获得节点的RLP编码，然后解码。</p>
<h3 id="以太坊账户类型有哪些？它们之间有何区别？"><a href="#以太坊账户类型有哪些？它们之间有何区别？" class="headerlink" title="以太坊账户类型有哪些？它们之间有何区别？"></a>以太坊账户类型有哪些？它们之间有何区别？</h3><p>对比项 外部拥有账户 合约账户<br>以太币余额 有 有<br>输内容 交易 交易或消息<br>控制 私钥 合约代码<br>地址 公钥决定 由合约创建者地址和Nonce计算得<br>代码 不包含代码 包含代码</p>
<h3 id="什么是GHOST协议？相较比特币而言，为什么以太坊当中要奖励叔区块，如何奖励？"><a href="#什么是GHOST协议？相较比特币而言，为什么以太坊当中要奖励叔区块，如何奖励？" class="headerlink" title="什么是GHOST协议？相较比特币而言，为什么以太坊当中要奖励叔区块，如何奖励？"></a>什么是GHOST协议？相较比特币而言，为什么以太坊当中要奖励叔区块，如何奖励？</h3><p>GHOST协议解决当前快速确认的区块链因区块高作废率而受到低安全性困扰的问题。GHOST协议是根据最重子树选择主链。</p>
<p>相较比特币而言，以太坊产生区块的间隔时间更短，更易出现区块链分叉产生孤块，通过将产生孤块的算力也被包含进来，有效的增强了安全性。同时通过给叔区块奖励，避免出现像比特币那样计算力高度集中的矿池。 产生叔区块的矿工将获得的奖励为：（叔区块ID+8-当前区块ID）×区块奖励/8。将叔区块链接到区块链上的奖励为：每链接一个叔区块获得区块奖励/32个以太币的奖励，最多链接两个叔区块。</p>
<h3 id="以太币和Gas有何关系？"><a href="#以太币和Gas有何关系？" class="headerlink" title="以太币和Gas有何关系？"></a>以太币和Gas有何关系？</h3><p>以太坊中两种不同的计量单位gas存在于EVM中；</p>
<p>ether存在于以太坊账户中。</p>
<p>gas用来衡量执行每一步操作所需要支付的费用，其价格由ether来表示。</p>
<p>用户可以通过向以太坊账户中充值以太币，由以太坊客户端自动购买用户指定操作最大支出的gas，同时在操作结束时将剩余的gas转换成以太币返还到用户的以太坊账户。gas与以太币两者分开，gas单位与具备自然成本的运算单位一致，而ether的价格通常会由于市场力量产生波动。</p>
<h3 id="以太坊虚拟机可访问存储数据的空间有哪些？-各自有何特点？"><a href="#以太坊虚拟机可访问存储数据的空间有哪些？-各自有何特点？" class="headerlink" title="以太坊虚拟机可访问存储数据的空间有哪些？ 各自有何特点？"></a>以太坊虚拟机可访问存储数据的空间有哪些？ 各自有何特点？</h3><p>Storage<strong>（账户存储）</strong>每个账户有一块保存在区块链上的持久性存储，称为 storage。这是一个将256位字映射到256位字的 key-value 存储区，均为32字节；未使用Key-Value值为0，非0值代表已占用。永久储存在区块链中，读写的 gas 开销也最大。</p>
<p>Memory<strong>（内存）</strong>每一次消息调用，会临时获取一块干净的内存空间。生命周期仅为整个方法执行期间，函数调用后回收，按照可寻址字节数组来存储，读写 gas 开销较小。</p>
<p>Stack<strong>（栈）</strong>EVM是基于栈的，几乎免费使用的内存，但有数量限制。栈中每个元素是32字节，最多容1024个元素。</p>
<h3 id="简述以太坊挖矿算法Ethash的过程，并说明为何它可做到ASIC-resistance？"><a href="#简述以太坊挖矿算法Ethash的过程，并说明为何它可做到ASIC-resistance？" class="headerlink" title="简述以太坊挖矿算法Ethash的过程，并说明为何它可做到ASIC resistance？"></a>简述以太坊挖矿算法Ethash的过程，并说明为何它可做到ASIC resistance？</h3><p>第一步：生成种子，根据区块块头信息计算出一个种子。</p>
<p>第二步：伪随机数据集，根据种子生成一个大小为16M的伪随机数据集，每30000个区块进行一次更新，用于轻客户端存储缓存。</p>
<p>第三步：DAG数据集，根据伪随机数据集生成大小1G的大规模数据集。该数据集中每项元素通过伪随机数据集中少量的几项计算得到。</p>
<p>第四步：挖矿，通过header及nonce计算出一个初始的哈希值映射到初始位置A，然后读取A位置元素和A的相邻后一个位置A’的元素，再通过（A和A’）计算出位置（B和B’），以此类推，迭代64次后，一共读取出128个数，最后计算这128个数的哈希值与目标值target比较，若满足target，则挖矿成功；否则重新尝试nonce。ASIC芯片主要优势是算力强，但在内存访问的性能上没有那么大的优势，所以能设计出一个对内存要求很高的puzzle，就能起到遏制ASIC芯片的作用。</p>
<h1 id="复习简化-from-confucian-e"><a href="#复习简化-from-confucian-e" class="headerlink" title="复习简化 from confucian-e"></a>复习简化 from confucian-e</h1><h3 id="BlockChian"><a href="#BlockChian" class="headerlink" title="BlockChian"></a>BlockChian</h3><p>为什么说区块链技术应用是从信息互联网到价值互联网</p>
<p>（围绕“不可复制”、“确权”、“价值交换”）。</p>
<p>区块链部署的三种形式，每种形式的特点，我国以哪种为主</p>
<p>公有链：节点加入无需准许，人人都可参与网络共识，任意读取数据，执行交易；PoW、PoS等。<br>联盟链：节点加入需要准许，多个机构组成联盟，数据读写等操作由联盟成员决定，效率高，节点可信度高；PBFT、Raft等。<br>私有链：写入权限掌握在一个组织内部，读取或开放或限制。<br>国内以联盟链为主。</p>
<p>区块链的六层架构</p>
<p>应用层：dapp<br>合约层：智能合约<br>激励层：挖矿<br>共识层：共识机制<br>网络层：P2P<br>数据层：数据结构，数据库<br>公有链激励层中的分配机制和发行机制</p>
<p>发行<br>ICO<br>IPO<br>IEO<br>公私募<br>分配<br>空投<br>流动性挖矿<br>质押挖矿<br>社区成员分配</p>
<h3 id="Bitcoin"><a href="#Bitcoin" class="headerlink" title="Bitcoin"></a>Bitcoin</h3><p>比特币区块头数据结构，每个字段长度及意义</p>
<p>区块头包含：上一个区块头哈希、默克尔树根哈希、版本号、时间戳、当前挖矿难度、随机数；共80个字节，前2个各32位，后4个各4位。</p>
<p>比特币密钥和地址生成过程，为什么通过地址推导公钥哈希</p>
<p>私钥：256位由0和1组成的随机数，以64位16进制显示。</p>
<p>公钥：私钥通过一个椭圆曲线算法(ECDSA)计算而来，不可逆，即不能根据公钥倒推私钥。</p>
<p>地址：公钥先通过单向哈希(SHA256, RIPEMD160)计算出公钥哈希，公钥哈希通过Base58check编码得到地址。</p>
<p>因为地址是公钥哈希通过Base58check编码得来的，所以地址逆向变换可得公钥哈希。</p>
<p>比特币交易流程</p>
<p>交易的创建：线上线下都可。<br>广播交易：广播到P2P网络，全网节点收到验证。<br>交易验证与挖矿：从交易池中选一系列交易，矿工挖出区块。<br>交易确认：待新块中全部交易验证完成后，各节点将该块添加到区块链尾部（上链）。<br>确认有效：经过6个区块（1个小时）确认后即有效，永久保存于链上。<br>锁定脚本与解锁脚本位置</p>
<p>锁定脚本在输入列表中，解锁脚本在输出列表中。</p>
<p>P2PKH执行过程，出入栈变化</p>
<p>签名(sig)入栈。<br>公钥(PubK)入栈。<br>复制栈顶的公钥(DUP)。<br>对栈顶的公钥进行哈希(HASH160)。<br>压入公钥哈希(PubKHash)。<br>判断栈顶的2个公钥哈希是否相等(EQUALVERIFY)，相等后这2个出栈。<br>根据公钥检验签名(CHECKSIG)，正确后都出栈，栈顶显示TRUE。<br>比特币分叉类型及原因</p>
<p>临时分叉：算法导致，同时挖出2个甚至多个块。<br>硬分叉：升级系统，新规则无法向前兼容，旧节点无法认可新节点的区块。<br>软分叉：升级系统，可以向前兼容。</p>
<h3 id="Ethereum"><a href="#Ethereum" class="headerlink" title="Ethereum"></a>Ethereum</h3><p>以太坊解决了比特币的哪些问题</p>
<p>缺少图灵完备：比特币脚本语言非图灵完备。<br>价值盲：UTXO不可分割，转账金额不能精细控制。<br>缺少状态：UTXO只有是否花费，不能构建复杂合约。<br>区块链盲：看不到区块链的数据<br>速度慢：交易确认时间长，TPS低<br>以太坊发展的4个阶段</p>
<p>前沿(Frontier)<br>家园(Homestead)<br>大都会(Metropolis)<br>宁静(Serenity)<br>以太坊区块头的三棵树及作用</p>
<p>交易树：存交易<br>收据树：存交易生成的收据<br>状态树：存账户状态<br>以太坊账户类型</p>
<p>外部拥有账户(EOA)和合约账户(CA)</p>
<p>以太币(ether)与gas的区别</p>
<p>以太坊中2种不同的计量单位。</p>
<p>gas存在于EVM中；ether存在于以太坊账户中，最小货币单位为wei。</p>
<p>gas用来衡量执行每一步操作所需要支付的费用，其价格由ether来表示。</p>
<p>以太坊虚拟机可访问存储数据的空间有哪些，各自特点</p>
<p>Storage：链上永久存储，gas开销大。<br>Memory：临时存储，生命周期为方法执行期间，gas开销小。<br>Stack：EVM不是基于寄存器，而是基于栈。</p>
]]></content>
  </entry>
  <entry>
    <title>股票入门</title>
    <url>/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="计算机网络复习资料"><a href="#计算机网络复习资料" class="headerlink" title="计算机网络复习资料"></a>计算机网络复习资料</h1><h2 id="一-计算机网络概述"><a href="#一-计算机网络概述" class="headerlink" title="一.计算机网络概述"></a>一.计算机网络概述</h2><h3 id="计算机网络的概念："><a href="#计算机网络的概念：" class="headerlink" title="计算机网络的概念："></a>计算机网络的概念：</h3><h4 id="1-计算机网络的定义："><a href="#1-计算机网络的定义：" class="headerlink" title="1.计算机网络的定义："></a>1.计算机网络的定义：</h4><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路链接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<span id="more"></span>

<h4 id="2-计算机网络的组成："><a href="#2-计算机网络的组成：" class="headerlink" title="2.计算机网络的组成："></a>2.计算机网络的组成：</h4><p><strong>终端系统/资源子网</strong>：提供共享的软件资源和硬件资源<br><strong>通信子网</strong>：提供信息交换的网络结点和通信线路。</p>
<h4 id="3-计算机网络的类型："><a href="#3-计算机网络的类型：" class="headerlink" title="3.计算机网络的类型："></a>3.计算机网络的类型：</h4><p><strong>按照拓朴分类</strong>： 星型结构 树形结构 总线型结构 环形结构 网状结构<br><strong>按照范围分类</strong>：局域网 LAN 城域网 MAN 广域网 WAN 补充：个人区域网 PAN 互联网 Internet<br><strong>按照传输方式分类</strong>：有线网络（IEEE802.3） 无线网络：（ IEEE802.11 WLAN 无线局域网（wireless） WPAN 无线个域网）</p>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="1-传输方式："><a href="#1-传输方式：" class="headerlink" title="1.传输方式："></a>1.传输方式：</h4><p><strong>按照传输的方向分</strong>：<br><strong>单工</strong>：只能单方向传输的工作模式<br><strong>双工</strong>：在同一时间，线路上只能允许一个方向的数据通过<br><strong>全双工</strong>：双方可以同时进行数据通信<br><strong>按照传输对象（方式）分</strong>：<br><strong>单播</strong>： 1 对 1<br><strong>多播</strong>：1 对多<br><strong>广播</strong>：1 对 all</p>
<h4 id="2-数据交换："><a href="#2-数据交换：" class="headerlink" title="2.数据交换："></a>2.数据交换：</h4><p><strong>电路交换</strong>：整个报文从源头到终点连续的传输<br><strong>报文交换</strong>：整个报文先传达到相邻节点，全部存储下来查找转发表，再转发到下一个节点<br><strong>分组交换</strong>：将一个报文分成多个分组，传送到相邻结点，在查找转发表，在转发到下一个结点</p>
<h4 id="3-通信协议和体系结构："><a href="#3-通信协议和体系结构：" class="headerlink" title="3.通信协议和体系结构："></a>3.通信协议和体系结构：</h4><p><strong>网络协议三要素</strong>：语法 语义 时序<br><strong>OSI 参考模型</strong>：<br><strong>应用层</strong>：使用应用程序通过网络服务。<br><strong>表示层</strong>：表示层用于处理交互数据的表示方式，例如格式转换，数据的加密和解密，数据压缩和回复等功能<br><strong>会话层</strong>：负责维护通信中两个结点之间的会话建立维护和断开，以及数据的交换<br><strong>传输层</strong>：提供端到端之间的数据传输服务，实现对数据进行控制和操作的功能。<br><strong>网络层</strong>：单位 分组，在数据链路层的基础之上，提供点到点之间的通信，提供路由功能，实现拥塞控制，网络互联等功能。<br><strong>数据链路层</strong>：单位 帧，在物理层的基础之上，提供结点到结点之间的服务，采取差错控制和流量控制的方法实现网路互联<br><strong>物理层</strong>：单位 bit，利用传输介质为通信的网络节点之间的建立<br>TCP/<strong>IP 参考模型</strong>：<br><strong>网络接口层</strong>：物理层和数据链路层<br><strong>网际层</strong>：网络层<br><strong>传输层</strong><br><strong>应用层</strong>：会话层，表示层，应用层</p>
<hr>
<h2 id="二-物理层"><a href="#二-物理层" class="headerlink" title="二.物理层"></a>二.物理层</h2><h3 id="1-物理层的基本概念："><a href="#1-物理层的基本概念：" class="headerlink" title="1.物理层的基本概念："></a>1.物理层的基本概念：</h3><h4 id="1-1-四大特性："><a href="#1-1-四大特性：" class="headerlink" title="1.1 四大特性："></a>1.1 四大特性：</h4><p>机械特性：接口是怎么样的<br>电气特性：用多少伏的电<br>功能特性：线路上电平电压的特性<br>过程特性：实现不同功能所发射信号的顺序</p>
<h4 id="1-2-两种信号："><a href="#1-2-两种信号：" class="headerlink" title="1.2 两种信号："></a>1.2 两种信号：</h4><p>模拟信号—特定频段的信号—有更加丰富的表现形式——抗干扰能力弱<br>数字信号—不是 1 就是 0——–抗干扰能力强</p>
<h4 id="1-3-调制和编码："><a href="#1-3-调制和编码：" class="headerlink" title="1.3 调制和编码："></a>1.3 调制和编码：</h4><p>调制：模拟信号转换<br>编码：<br>数字信号转换<br>编码的步骤：采样 量化 编码<br>区别：<br>数据可以通过编码手段转成数字信号，也可以通过调制手段将数据转成模拟型号。<br>数字数据可以通过数字发送器转化为数字信号（编码），也可以通过调制器转化为模拟信号。<br>模拟信号可以通过 PCM 编码器转化为数字信号（编码），也可以通过放大器调制器转化为模拟型号（调制）。</p>
<h4 id="1-4-传输介质："><a href="#1-4-传输介质：" class="headerlink" title="1.4 传输介质："></a>1.4 传输介质：</h4><p>双绞线：<br>传输距离 100-500（集线器 最多四个，超过就失真了）<br>屏蔽双绞线 STP：抗干扰强，贵一些<br>非屏蔽双绞线：便宜，抗干扰差<br>制作标准：<br>568B：橙白，橙，绿白，蓝，蓝白，绿，棕白，棕 ：八种<br>568A：12，26 调换—绿白，绿，绿白，蓝，蓝白，橙，棕白，棕<br>光纤：<br>多模光纤：<br>芯较粗（50 或 62.5）。可以传多种模式的光。但其模间色散较大，这就限制了传输数字信号的频率，而且随距离的增加会更加的严重。例如：600MB/KM 的光纤在 2KM 时只有 300MB 的宽带了。因此多模光纤传输距离就比较的近，一般只有几公里。<br>距离：2KM<br>单模光纤：<br>单模光纤：中间纤芯很细（芯径一般是 8-10），只能传一种模式的光，因此。其模间色散很小，适合语远程通讯，但还存在着材料色散和波导色散，这样单模光纤对光源的谱宽和稳定性有较高的要求，即谱宽要窄。稳定性要好。<br>距离：100KM<br>同轴电缆：淘汰了<br>无线：无线信号频率 IEEE802.11</p>
<h4 id="1-5-三大部分："><a href="#1-5-三大部分：" class="headerlink" title="1.5 三大部分："></a>1.5 三大部分：</h4><p>源系统：发送数据的一端<br>传输系统：传输过程中的各种传输介质<br>目的系统：接收数据的电脑</p>
<h3 id="2-物理层的基本通信技术"><a href="#2-物理层的基本通信技术" class="headerlink" title="2.物理层的基本通信技术"></a>2.物理层的基本通信技术</h3><h4 id="2-1-四种信道复用技术"><a href="#2-1-四种信道复用技术" class="headerlink" title="2.1 四种信道复用技术"></a>2.1 四种信道复用技术</h4><h5 id="2-1-1-复用技术"><a href="#2-1-1-复用技术" class="headerlink" title="2.1.1 复用技术"></a>2.1.1 复用技术</h5><p>复用技术是指一种在传输路径上综合多路道信道，然后恢复原机制或则解除终端各信道复用技术的过程<br>将多种不同的信号在同一信道上进行传输，复用技术主要是用来解决不同信号传输时应该如何区分。</p>
<h5 id="2-1-2-频分复用-FDM"><a href="#2-1-2-频分复用-FDM" class="headerlink" title="2.1.2 频分复用 FDM"></a>2.1.2 频分复用 FDM</h5><p>频分多路复用，是在适于某种传输媒介的传输频带内，若干个频谱互不重叠的信号一并传输的方式，简称 FDM。在每路信号进入传输频带前，先要以此搬移频率（调制），而在接收端，在搬回到原来的频段，恢复每路的原信号，从而使传输频带得到多路信号的复用。<br>划分不同频率来并行传输信号</p>
<h5 id="2-1-3-时分复用-TDM"><a href="#2-1-3-时分复用-TDM" class="headerlink" title="2.1.3 时分复用 TDM"></a>2.1.3 时分复用 TDM</h5><p>时分复用 TDM 是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的此目的。时分多路复用以时间作为信号分割的参量，故必须使各路信号在时间轴上互不重叠。时分复用 TDM 就是将提供给整个信道传输信息的时间划分为若干时间片（简称时隙），并将这些时隙分给每一个信号源使用<br>划分不同的时间段来传输信号</p>
<h5 id="2-1-4-波分复用-WDM（波）"><a href="#2-1-4-波分复用-WDM（波）" class="headerlink" title="2.1.4 波分复用 WDM（波）"></a>2.1.4 波分复用 WDM（波）</h5><p>是将两种或多种不 i 同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器）汇合在一起，并耦合到光线路的同一根光纤中进行传输技术<br>根据光波的波长进行传输（合波器耦合）</p>
<h5 id="2-1-5-码分复用"><a href="#2-1-5-码分复用" class="headerlink" title="2.1.5 码分复用"></a>2.1.5 码分复用</h5><p>码分复用 CDM 是靠不同的编码来区分各路原始信号的一种复用方式，主要和各种多址技术结合产生了各种接入技术，包括无线和有线接入。<br>在同一时间同一频率根据传输的数据码进行区分</p>
<h4 id="2-2-数据传输方式"><a href="#2-2-数据传输方式" class="headerlink" title="2.2 数据传输方式"></a>2.2 数据传输方式</h4><h5 id="2-2-1-通过同时间传输数量分为"><a href="#2-2-1-通过同时间传输数量分为" class="headerlink" title="2.2.1 通过同时间传输数量分为"></a>2.2.1 通过同时间传输数量分为</h5><p>串行传输<br>使用一条数据线，将数据一位一位的依次输入，每一位数据占据一个固定的时间长度。只需要少数几条先就可以在系统间交换信息，特别适用于计算机语计算机，外设之间的远距离通信。<br>并行传输<br>并行传输指的是数据以成组的方式，在多条并行信道上同时进行传输，是在传输中有多个数据位同时在设备之间进行的传输。</p>
<h5 id="2-2-2-通过数据报文的双方的行为分为"><a href="#2-2-2-通过数据报文的双方的行为分为" class="headerlink" title="2.2.2 通过数据报文的双方的行为分为"></a>2.2.2 通过数据报文的双方的行为分为</h5><p>同步传输<br>同步：在计算机网络中，定时的因素称为位同步。同步是要接收按照发送放放送的每个位的起止时刻和速率来接受数据，否则会产生误差。<br>同步传输的比特分组要大得多。他不会独立的发送每个字符，每个字符都有自己的开始位和停止位，而是把他们组合起来发送。我们将这些组合称为数据帧，或简称帧<br>异步传输：<br>异步传输将比特分成小组进行传输，小组可以是 8 位的 1 个字符或更长。发送方可以在任何时刻发送这些比特组，而接受方从不知道它们会在什么时候到达。</p>
<h4 id="3-3-通过传输的信号分"><a href="#3-3-通过传输的信号分" class="headerlink" title="3.3 通过传输的信号分"></a>3.3 通过传输的信号分</h4><p>基带传输：传输数字信号叫做基带传输<br>频带传输：传输模拟信号叫做频带传输（300-3400HZ）</p>
<h4 id="3-4-通过传输方向分"><a href="#3-4-通过传输方向分" class="headerlink" title="3.4 通过传输方向分"></a>3.4 通过传输方向分</h4><p>单工 半双工 全双工</p>
<h4 id="3-5-通过传输对象分"><a href="#3-5-通过传输对象分" class="headerlink" title="3.5 通过传输对象分"></a>3.5 通过传输对象分</h4><p>单播 组播 广播</p>
<hr>
<h2 id="三-数据链路层"><a href="#三-数据链路层" class="headerlink" title="三.数据链路层"></a>三.数据链路层</h2><h3 id="1-数据链路层的基础概念"><a href="#1-数据链路层的基础概念" class="headerlink" title="1.数据链路层的基础概念"></a>1.数据链路层的基础概念</h3><h4 id="1-1-数据链路层的概念"><a href="#1-1-数据链路层的概念" class="headerlink" title="1.1 数据链路层的概念"></a>1.1 数据链路层的概念</h4><p>数据链路层是在物理层和网际层之间的协议，提供相邻结点的可靠数据传输</p>
<h4 id="1-2-帧的概念"><a href="#1-2-帧的概念" class="headerlink" title="1.2 帧的概念"></a>1.2 帧的概念</h4><p>数据链路层的协议数据单元<br>组成：<br>帧头：源 MAC 地址，目的 MAC 地址，类型（MAC 地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址）<br>数据<br>帧尾：校验</p>
<p>1.3 以太网数据帧中的 MAC 和 LLC<br>MAC（一种协议，对接物理层）<br>MAC 介质控制访问<br>作用：数据帧的封装/卸载，帧的寻址和识别，帧的接收语发送，链路的管理，帧的差错控制等。MAC 子层的存在屏蔽了不同的物理链路层种类的差异性<br>LLC（对接网络层）<br>LLC 逻辑控制访问<br>作用：LLC 子层的主要功能为传输可靠性保障和控制，数据包的分段与重组。数据包的顺序传播。<br>注解：<br>该协议位于 OSI 七层协议中数据链路层，数据链路层分为上层 LLC（逻辑链路控制），和下层的 MAC（媒体访问控制），MAC 主要负责控制与链接物理层的物理介质。在发送数据的时候，MAC 协议可以事先判断是否发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；在接收数据的时候，MAC 协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至 LLC（逻辑链路控制）层。</p>
<p>1.4 数据链路层的两种传输方式<br>单播 广播<br>1.5 数据链路层的三个基本问题（***）<br>封装成帧（PPP）<br>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>透明传输<br>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传输<br>差错检测（奇数校验 偶数校验 CRC：需要计算）<br>收到正确的帧就要向发送端发送确认，发送算在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止，<br>1.6 局域网中的设备<br>网桥（在物理层和数据链路层之间）<br>两个端口的交换机<br>集线器（在物理层 共享带宽）<br>集线器的英文为：“HUB”是“中心”的意思，集线器的主要功能是对接受的信号进行再生整形放大，以扩大网络的传输距离，同时把所有结点集中在以它为中心的结点上。<br>交换机（数据链路层 独享带宽）<br>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络结点提供独享的电信号通路。最常见的交换机式以太网交换机。<br>2 数据链路层的通信协议<br>2.1 冲突域和广播域<br>冲突域<br>交换机的每一个端口都是一个冲突域；冲突域只能发生在一个网段<br>广播域<br>交换机的所有端口都在一个广播域；广播域在一个或多个网段内发生<br>区别<br>广播域可以跨网段<br>冲突域是基于第一层（物理层），而广播域是基于第二层（数据链路层）<br>HUB 所有端口都在同一个广播域，冲突域内，Switch 所有端口都在同意广播域内，而每一个端口就是一个冲突域。<br>同一冲突域共享宽带<br>2.2 虚拟局域网（实验）VLAN<br>VLAN（Virtual local Area Network）即虚拟局域网，是将一个物理的 LAN 在逻辑上划分成多个广播域的通信技术。VLAN 间不能直接通信，而 VLAN 间不能直接通信，从而将广播报文限制在一个 VLAN 内。<br>优点和目的<br>划分广播域：减少垃圾数据<br>增强局域网的安全性<br>提高健壮性<br>灵活构建工作组<br>划分 VLAN 的方式<br>基于端口<br>给交换机的每个接口配置不同的 PVID，当一个数据帧进入交换机接口时，如果没有带 VLAN 标签，且该接口上配置了 PVID。如果进入的帧已经带有 VLAN 标签，那么交换机不会在增加 VLAN 标签，即使接口已经配置了 PVID<br>Access：只允许通过一个 VLAN<br>Trunk：允许通过多个 VLAN<br>Hybird<br>基于子网<br>配置好子网域 VLAN 映射表，如果交换设备收到的是 untagged（不带 VLAN 标签）帧，交换设备根据报文中的源 IP 地址信息，确认添加的 VLAN iD。将指定网段或 IP 地址发出的报文在指定的 VLAN 中传输，减轻了网络管理着的任务量，且有利于管理<br>基于 MAC 地址<br>先配置好 MAC 地址和 VLAN 映射关系表，当终端用户的物理位置发生改变，不需要重新配置 VLAN。提高了终端用户的安全性和接入的灵活性<br>基于协议<br>将网络中提供的服务类型域 VLAN 相绑定，方便管理和维护。需要对网络中所有的协议类型和 VLAN ID 的映射关系表进行初始配置。需要分析各种协议的地址格式并进行相应的转换，消耗交换机较多的资源，速度上稍具劣势。<br>基于匹配策略<br>先在交换机上配置好终端的 MAC 地址和 IP 地址，并与 VLAN 并联。只有符合条件的终端才能加入指定 VLAN。符合策略的终端加入指定 VLAN 后，严禁修改 IP 地址和 MAC 地址，否则会导致终端从指定 VLAN 中退出。<br>2.3：CSMA/CD（总线型）<br>CSDN/CD 即载波侦听多路访问/冲突检测，是广播信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点，总线型网络传输数据<br>四大特点（重要）<br>先听再发<br>边听边发<br>冲突停止<br>延迟后发<br>2.4：PPP（单播）<br>点对点通信是一对一通道，因此不会发生碰撞，因此比较简单，采用 PPP 协议；其中 PPP 协议就是用户计算机和 ISP（互联网服务提供商）进行通信时使用的数据链路层的协议<br>PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。<br>2.5：CRC（需要单独的深入学习）<br>循环冗余校验<br>是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能。l<br>例题：要发送的数据为 1101011011，采用 CRC 的生成多项式是 P（x）=x^4+x+1.求余数。</p>
<h2 id="四-网络层"><a href="#四-网络层" class="headerlink" title="四.网络层"></a>四.网络层</h2><p>1.网络层的作用<br>提供端到端的服务 单位：分组<br>网络层的目的是实现两个端系统之间的数据透明传输，具体功能包括寻址和路由选择，连接的建立，保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。 2.网际层协议 IP<br>ARP 地址解析协议<br>根据 IP 地址获取物理地址<br>RARP 反地址解析协议<br>ICMP 网际控制报文协议<br>通过 ICMP 传输控制消息，控制消息是指网络通不通，主机是否可达，路由是否可用等网络本身的消息。<br>IGMP 网际组管理协议<br>适用于管理协议多播组成员的一种通信协议。IP 主机和相邻路由器利用 IGMP 来创建多播组的组成员。组播方式解决了单播情况下数据的重复拷贝及带宽的重复占用，也解决了广播方式下带宽资源的浪费<br>3.IP 地址<br>3.1IP 地址的概念<br>IP 地址使 IP 协议提供的一种统一的地址格式，他为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br>组成：一个 IP 地址由 4 个字节，32 位组成，一般用点分十进制的方式表现，<br>IP 地址和 MAC 地址的区别<br>IP 地址是一个逻辑地址，MAC 地址是物理地址<br>MAC 地址是唯一的但是 IP 地址不受唯一的<br>MAC 地址主要是工作在第二层，IP 地址在网际层<br>MAC 地址是 48 位，IP 地址一般是 32 位（v6 是 128 位）<br>IP 地址的分配取决于网络拓扑，MAC 地址分配取决于制造商<br>3.2IP 地址的组成<br>主机地址和网络地址组成的<br>主机地址/主机号<br>标识某一台设备的地址<br>网络地址/网络号<br>标识某一网段的地址<br>子网掩码<br>子网掩码用于区分网络号和主机号<br>它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码只能有一个作用，就是将某一个 IP 地址划分成为网络地址和主机地址两部分<br>3.3IP 地址的分类<br>3.3.1A 类<br>一个 A 类 IP 地址是指，在 IP 地址的四段号码中，第一段号为网络号码，剩下的三段号码为本地计算机的号码。A 类 IP 地址中网络的标识长度为 8 位，主机标识的长度为 24 位，A 类网络地址数量较少，有 126 个网络，每一个网络可以容纳主机数量高达 1600 多万台. A 类 IP 地址 地址范围 1.0.0.1 到 127.255.255.254<br>第一个字节为网络号，第一个字节第一位为 0<br>3.3.2B 类<br>一个 B 类地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。B 类 IP 地址中网络的标识长度为 16 位，主机标识的长度为 16 位，B 类网络地址适用于中等规模的网络，有 16384 个网络，每个网络所能容纳的计算机数 6 万多台。 B 类 IP 地址 地址范围 128.0.01-191.255.255.254<br>前两个字节为网络号，第一个字节前两位是 10<br>3.3.3C 类<br>一个 C 类 IP 地址是指，在 IP 地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位，C 网络地址数量较多，有 209 万余个网络。适用于小规模的局域网络，每个网络最多只能包含 254 台计算机。C 类 IP 地址范围 192.0.0.1-223.255.255.254<br>前三个字节为网络号，第一个字节前两位是 110<br>3.3.4D 类<br>D 类 IP 地址在历史上呗叫做多播地址，及组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从 224.0.0.0 到 239.255.255.255<br>3.3.5E 类<br>保留<br>3.3.6 特殊地址<br>网络地址：主机号全为 0 的地址不可用<br>广播地址：主机号全为 1 的地址不可用<br>回环地址：127.0.0.0 测试使用<br>4.IPv6<br>因为 IPv4 地址满足不了需求，出现匮乏的情况，所以就诞生了 IPv6 地址继续使用。v6 地址由 128 位，16 字节组成，一般表现形式为十六进制。 4.网络层的路由<br>4.1 路由<br>路由是什么？<br>路由是指分组从源到目的地时，决定端到端路径的网络范围的进程。路由是指导报文转发的路径信息，通过路由可以确认转发 IP 报文的路径<br>路由是网络层最主要的工作任务<br>路由器<br>网络层的基础设备<br>数据转发<br>一个端口代表一个网段，路由器中存放着通往各个网段的表格，叫做路由表<br>路由表<br>又称路由择域信息库，是一个存储在路由器或者联网计算机中的电子表格（文件）或者类数据库。路由表存储着指向特定网络地址的路径<br>网关<br>又称网间连接器，协议转换器。用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连<br>路由获取方式<br>直连路由<br>静态路由<br>动态路由<br>4.2 路由的配置方式<br>静态路由<br>静态路由：由管理员手工配置，配置方便，对系统要求低，适用于拓扑结构简单稳定的小型网络<br>缺省路由：是一种特殊的路由，当报文没有在路由表中找到匹配的具体表项时才能使用的路由<br>动态路由<br>动态路由<br>通过动态路由协议来实现不同网段的路由互通<br>动态路由协议有自己的路由算法，能够自动适应网络拓扑的变化，适用于具有一定数量的三层设备的网络<br>动态路由协议<br>RPI<br>RPI：路由信息协议<br>基于矢量的动态路由协议<br>适用于中小规模的网络拓扑，最大跳数为 15<br>OSPF<br>OSPF:开放式最短路径优先<br>基于链路状态的路由<br>使用 SPF 算法，计算最短路径。树形协议<br>BGP<br>BGP 是自治系统间的路由协议。自治系统之间的路由协议<br>自治系统间的路由协议<br>IS-IS<br>IS-IS：中间系统到中间系统<br>与 OSPF 类似，IS-IS 是基于路由路划分区域，OSPF 利用接口划分<br>内部网关协议<br>RIP 和 OSPF 的区别<br>RIP 是基于矢量的协议，OSPF 是基于链路状态<br>RIP 适用于中小型网络拓扑，OSPF 适用于较大规模的网络<br>OSPF 支持可变长度子网掩码（VLSM）。RIP 不支持<br>ODPF 的收敛速度比 RIP 更加的迅速</p>
<h2 id="五-传输层"><a href="#五-传输层" class="headerlink" title="五.传输层"></a>五.传输层</h2><p>1.传输层概念<br>1.1 传输层<br>传输层提供端到端服务<br>从通信和信息处理的角度看，传输层向上层应用层提供通信服务<br>所谓的端口，就好像是门牌号一样，客户端可以通过 IP 地址找到对应的服务器端，但是服务器端是有很多的端口的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口号进行区分，将每个端口进行编号，这就是端口号<br>1.2 端口号<br>FTP：21（20）_<br>FTP（文件传输协议）<br>21 连接；20 传输数据<br>TELNET：23_：TELNET(远程登录)<br>SMTP：25*<br>SMTP(电子邮件传输协议)<br>POP3（邮局协议版本 3）：110<br>DNS：53<em>：DNS（域名系统）<br>TFTP：69：TFTP（简单文件传输协议）<br>HTTP：80</em>：HTTP（超文本传输协议）<br>SNMP：161：SNMP（简单网络管理协议）<br>HTTPS：443*：HTTPS（超文本传输安全协议） 2.传输层的两个重要协议<br>3.1TCP<br>传输控制协议：TCP<br>TCP 是 TCP/IP 体系中较为复杂的协议，是传输层中最重要的协议<br>TCP 的主要特点是：<br>TCP 是面向连接的传输层协议<br>TCP 提供可靠的交付服务<br>TCP 提供全双工通信<br>TCP 是面向字节流<br>窗口<br>固定窗口：如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟<br>滑动窗口：滑动窗口通俗的讲就是一种流量控制技术。它本质上是描述接收方 TCP 数据报缓冲区大小的数据，发送根据这个数据来计算自己最多能发送所长的数据，如果发送方收到接收方的窗口大小为 0 的 TCP 数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为 0 的数据报的到来<br>拥塞处理和流量控制<br>TCP 的三次握手和流量控制<br>3.2UDP<br>用户数据报协议：UDP<br>UDP 是在 IP 数据报服务之上增加了一些功能，增加了复用和分用的功能以及差错检测的功能<br>UDP 的主要特点是：<br>UDP 是无连接的<br>UDP 尽最大努力交付<br>UDP 面向报文且没有拥塞控制<br>UDP 开销较小传输效率较高<br>UDP 首部的概念<br>个人认为的复习重点(超级重要的 tcp)</p>
<p>※传输层中的 TCP 和 UDP<br>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<p>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。<br>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。<br>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<ol>
<li>端口号<br>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</li>
</ol>
<p>1.1 根据端口号识别应用<br>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p>1.2 通过 IP 地址、端口号、协议号进行通信识别<br>仅凭目标端口号识别某一个通信是远远不够的。</p>
<p>① 和 ② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是 80。这里可以根据源端口号加以区分。<br>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。<br>1.3 端口号的确定<br>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0<del>1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024</del>49151 之间，不过这些端口号可用于任何通信用途。<br>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。<br>1.4 端口号与协议<br>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。<br>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。 2. UDP<br>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。<br>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。<br>此外，传输途中出现丢包，UDP 也不负责重发。<br>甚至当包的到达顺序出现乱序时也没有纠正的功能。<br>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。<br>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP 等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。 3. TCP<br>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。<br>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。<br>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。<br>3.1 三次握手（重点）<br>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在 socket 编程中，这一过程由客户端执行 connect 来触发。<br>下面来看看三次握手的流程图：</p>
<p>第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。<br>第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。<br>第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。<br>3.2 四次挥手（重点）<br>四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。<br>由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br>下面来看看四次挥手的流程图：</p>
<p>中断连接端可以是客户端，也可以是服务器端。<br>第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。<br>第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。<br>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。<br>第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。<br>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，<br>具体流程如下图：</p>
<p>3.3 通过序列号与确认应答提高可靠性<br>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。<br>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。<br>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。<br>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。<br>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。<br>序列号是按照顺序给发送数据的每一个字节（8 位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
<p>3.4 重发超时的确定<br>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。<br>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。<br>在 BSD 的 Unix 以及 Windows 系统中，超时都以 0.5 秒为单位进行控制，因此重发超时都是 0.5 秒的整数倍。不过，最初其重发超时的默认值一般设置为 6 秒左右。<br>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以 2 倍、4 倍的指数函数延长。<br>此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。<br>3.5 以段为单位发送数据<br>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。<br>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。<br>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。<br>3.6 利用窗口控制提高速度<br>TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。<br>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为 4 个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。<br>3.7 滑动窗口控制</p>
<p>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。<br>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。<br>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。<br>3.8 窗口控制中的重发控制<br>在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为 1001 的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续 3 次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>
<p>※网络层中的 IP 协议<br>IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。<br>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。<br>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</p>
<ol>
<li>IP 地址<br>1.1 IP 地址概述<br>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。<br>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。<br>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。<br>IP 地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：<br>2828282810101100000101000000000100000001（2 进制）10101100.00010100.00000001.00000001（2 进制）172.20.1.1（10 进制）</li>
</ol>
<p>1.2 IP 地址由网络和主机两部分标识组成<br>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</p>
<p>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</p>
<p>1.3 IP 地址的分类<br>IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。<br>A 类 IP 地址是首位以 “0” 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0<del>127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16,777,214 个。<br>B 类 IP 地址是前两位 “10” 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0</del>191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65,534 个。<br>C 类 IP 地址是前三位为 “110” 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0<del>223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。<br>D 类 IP 地址是前四位为 “1110” 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0</del>239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。<br>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。<br>1.4 广播地址<br>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。<br>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。<br>1.5 IP 多播<br>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。<br>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
<p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。<br>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。<br>1.6 子网掩码<br>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。<br>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。<br>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：<br>IP 地址 172.20.100.52 子网掩码 255.255.255.192 网络地址 172.20.100.0 子网掩码 255.255.255.192 广播地址 172.20.100.63 子网掩码 255.255.255.192</p>
<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：<br>IP 地址 172.20.100.52/ 26 网络地址 172.20.100.0/ 26 广播地址 172.20.100.63/ 26</p>
<p>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。 2. 路由<br>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。<br>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。<br>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。<br>2.1 IP 地址与路由控制<br>IP 地址的网络地址部分用于进行路由控制。<br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。<br>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<ol start="3">
<li>IP 分包与组包<br>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。<br>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。<br>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。<br>3.1 路径 MTU 发现<br>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。<br>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。<br>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li>
<li>IPv6<br>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。<br>4.1 IPv6 的特点<br>IP 得知的扩大与路由控制表的聚合。<br>性能提升。包首部长度采用固定的值（40 字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。<br>支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP 地址。<br>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。<br>多播、Mobile IP 成为扩展功能。<br>4.2 IPv6 中 IP 地址的标记方法<br>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。<br>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。<br>4.3 IPv6 地址的结构<br>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。<br>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。<br>未定义 0000 … 0000（128 比特）：：/ 128 环回地址 0000 … 0001（128 比特）：：1 / 128 唯一本地地址 1111 110FC00：/ 7 链路本地单播地址 1111 1110 10FE80：：/ 10 多播地址 1111 1111FF00：：/ 8 全局单播地址（其他）</li>
</ol>
<p>4.4 全局单播地址<br>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。<br>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
<p>4.5 链路本地单播地址<br>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p>4.6 唯一本地地址<br>唯一本地地址是不进行互联网通信时所用的地址。<br>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。<br>L 通常被置为 1<br>全局 ID 的值随机决定<br>子网 ID 是指该域子网地址<br>接口 ID 即为接口的 ID</p>
<p>4.7 IPv6 分段处理<br>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。<br>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。<br>4.8 IP 首部（暂略）<br>※IP 协议相关技术<br>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。<br>5.1 DNS<br>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。<br>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。<br>5.2 ARP<br>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。<br>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。<br>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。<br>5.3 ICMP<br>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。<br>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。<br>5.4 DHCP<br>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。<br>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。<br>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。<br>5.5 NAT<br>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。<br>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。<br>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。<br>5.6 IP 隧道</p>
<p>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。<br>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。<br>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</p>
<h2 id="六-应用层"><a href="#六-应用层" class="headerlink" title="六.应用层"></a>六.应用层</h2><p>1.应用层的作用<br>通过位于不同主机中的多个应用进程之间的通信和协同工作来完成，应用层的内容就是具体定义通信规则 2.应用层中常见的协议<br>域名系统 DNS<br>域名结构：每一个域名用标号隔开。 mail.cctv.com (三级域名.二级域名.顶级域名)<br>域名服务器：迭代 递归<br>文件传输协议 FTP<br>使用 TCP 连接，传输数据<br>端口号是 21（20） 20 发送数据<br>远程终端协议 TELNET<br>使用 TCP 连接，远程登录到远地的另外一台主机上<br>端口号是 23<br>万维网和 HTTP 协议<br>超文本传输协议，是一个简单的请求-响应协议<br>端口号是 80<br>电子邮件协议<br>SMTP 电子邮件传输协议：端口号 25<br>POP3 邮局协议版本 3：端口号 110<br>DHCP 动态主机配置协议<br>指的是由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。<br>端口号 68</p>
<h2 id="七-网络安全"><a href="#七-网络安全" class="headerlink" title="七.网络安全"></a>七.网络安全</h2><p>1.网络安全概论<br>1.1 网络安全<br>网络安全（Cyber Security）是指网络系统的硬件，软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭到破坏，更改，泄露。系统连续可靠正常的运行，网络服务不中断。<br>1.2 计算机网络面临的威胁主要分为两类<br>1.2.1 主动攻击<br>主动的去做一些在网络基础上的恶意行为。恶意串改信息数据，发布恶意程序脚本等<br>篡改<br>恶意程序<br>拒绝服务<br>1.2.2 被动攻击<br>被动攻击主要是收集信息而不是进行访问，不改变数据本身的结构，也不对软硬件数据造成影响<br>截取<br>窃听<br>流量分析<br>1.2 网络系统特性<br>保密性：信息不泄露给非授权用户，实体或过程，或供其利用的特性<br>完整性：数据未经授权不能进行改变的特性，即信息在存储或传输过程中保持不被修改，不被破坏和丢失的特性<br>可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需信息。例如网络环境下拒绝服务，破坏网络和有关系统的正常运行等后属于对可用性的攻击<br>可靠性：对信息的传播及内容具有控制能力<br>不可抵赖性：出现安全问题时提供依据与手段 2.加密和交互<br>2.1 加密和解密<br>2.1.1 加密<br>是以某种特殊的算法改变原有的信息数据，使得未授权的用户即即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容<br>加密手段<br>MD5 加密（信息-摘要算法）：128 位<br>AES 加密（称秘钥加密）：128,192,256 位<br>SHAI 加密（安全哈希算法）：160 位<br>RSA 加密：公钥加密，私钥解密：1204 位<br>2.1.2 解密<br>加密的逆过程就是解密<br>2.2 公钥和私钥<br>2.2.1 对称加密<br>采用单钥密码系统的加密方式，同一个秘钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单秘钥加密。<br>2.2.2 非对称加密<br>使用非对称的加密方式时，会产生两把钥匙。发送方利用自己的公钥加密，接收方利用自己的私钥解密<br>数字签名的四大特点<br>防止重放攻击：攻击者利用网络监听或则其他方式盗取认证凭据，之后再把它重新发给认证服务器。在数字签名中，如果采用了对签名报文加盖时间戳等或添加流水号等技术，就可以有效防止重放攻击<br>防止数据伪造：其他人不能伪造对消息的签名，因为私有秘钥只能签名者自己知道，所有其他人不可以构造出正确的签名结果数据<br>防止数据篡改：数字签名与原始文件或摘要一起发送给接受者，一旦信息被篡改，接受者可以通过计算摘要和验证签名来判断该文件无效，从而保证了文件的完整性<br>防止数据抵赖：数字签名既可以作为身份认证的依据，也可以作为签名者签名操作的证据。要防止接受者抵赖，可以在数字签名系统中要求接收者返回一个自己的签名的表示收到报文，给发送者或者信任第三方。如果接受者不返回任何信息，此次通信可终止或重新的开始，签名方也没有任何的损失，由此双方均不可抵赖。<br>2.3 防火墙<br>防火墙是一种访问控制技术，可以严格控制进出网络边界的分组，禁止任何不必要的通信，来减少潜在入侵的发生</p>
<p>防火墙的区域们<br>Local 本地区域<br>顶级安全区域，安全优先级为 100<br>local 就是防火墙本身的区域比如 ping 指令等网际控制协议的回复，需要 local 域的权限凡是由防火墙主动发出的报文均可认为是从 local 区域中发出是需要防火墙响应并处理（而不是转发）的报文均可认为是 Local 区域接收<br>Trust 受信区<br>高级安全区域，安全优先级为 85<br>通常用来定义内部用户所在的网络，也可以理解为应该是防护最严密的地区<br>DMZ 非军事化区<br>中级安全区域，安全优先级 50<br>通常用来定义内部服务器坐在网络<br>作用是把 WEB。E-mail 等允许外部访问的服务器单独接在该区域端口，使整个需要访问，实现内外网分离，达到用户需求。DMZ 可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 Web，Mail，FTP 中的服务。这样来自外网的访问者可以访问 DMZ 中服务，但不可能接触到存放在内网中的公司机密或私人信息等，及时 DMZ 中服务器受到破坏，也不会对内网中的机密信造成影响<br>Untrust 非受信区<br>低级安全区域，安全优先级为 5<br>通常用来定义 Internet 等不安全的网络，用于网络入口线的接入。</p>
]]></content>
  </entry>
  <entry>
    <title>股票入门</title>
    <url>/2022/05/03/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="股票入门知识-原创：狂神"><a href="#股票入门知识-原创：狂神" class="headerlink" title="股票入门知识(原创：狂神)"></a>股票入门知识(原创：狂神)</h1><hr>
<h2 id="01技术分析与基本分析"><a href="#01技术分析与基本分析" class="headerlink" title="01技术分析与基本分析"></a>01技术分析与基本分析</h2><h3 id="1、基础分析、技术分析"><a href="#1、基础分析、技术分析" class="headerlink" title="1、基础分析、技术分析"></a>1、基础分析、技术分析</h3><p>预测市场价格趋势的人士可分为两派：一为基础分析派，另一为技术分析派。</p>
<span id="more"></span>
<p>技术分析者认为：一切外在影响市场的因素，已经全部或大部分反映在市场价格走势上。其特点是通过对市场过去和现在的行为，应用数学和逻辑上的方法，归纳总结一些典型的行为，从而预测市场的未来的变化趋势。市场行为包括价格的高低、价格的变化、生这些变化所伴随的成交量，以及完成这些变化所经过的时间。技术分析是一种广泛应用在证券市场中的分析工具，是一种技巧，也是一门学问。可以说，如果没有技术分析的帮助，投资者要想在证券市场上取得成功是不可想象的。</p>
<p>技术分析主要根据k线图及一些技术指标，比如rsi，macd等来判断股票的下一步走势，技术分析的主要假设是历史是会重复的，相同的原因产生相同的结果，所以研究历史上股票变化的各种形态，用于预测其将来的变化，这就是技术分析。</p>
<p>而基本面分析则是指对于宏观经济的分析以及行业的分析，具体到公司的经营状况，赢利前景等。</p>
<p>目前很多基金经理都很推崇所谓的价值投资，其实也就是去现那些目前的股票市值〈公司价值的股票，这应该属于基本面分析，然而何时去购买这些股票，则根据技术分析来决定，因为影响股票价格的一个重要因素是人的心理，而人性是不会变的。</p>
<h3 id="2、技术分析与基本分析的主要区别？"><a href="#2、技术分析与基本分析的主要区别？" class="headerlink" title="2、技术分析与基本分析的主要区别？"></a>2、技术分析与基本分析的主要区别？</h3><p>技术分析者认为，短期市场价格的趋势较长期价格趋势更为重要，在短期价格波动中，依据价格技术图表和指标，逢高卖出逢低吸纳可以赚取更大利润。基本分析派认为，只有主要趋势确认后才可以开始入市，买入后长期持有自己的优点和缺点，而外汇交易者如果能兼备两者而互补长短，则无往而不利。</p>
<p>基本分析的优点主要是能够比较全面地把握证券价格的基本走势，应用起来相对简单。基本分析的缺点主要是预测的时间跨度相对较长，对短线投资者的指导作用比较弱；同时，预测的精确度相对较低。技术分析的优点是同市场接近，考虑问题比较直接。与基本分析相比，技术分析进行证券买卖的见效快，获得利益的周期短。此外，技术分析对市场的反应比较直接，分析的结果也更接近实际市场的局部现象。技术分析的缺点是考虑问题的范围相对较窄，对市场长远的趋势不能进行有益的判断。基本分析主要适用于周期相对比较长的证券价格预测、相对成熟的证券市场以及预测精确度要求不高的领域。技术分析适用于短期的行情预测，要进行周期较长的分析必须依靠别的因素，这是应用技术分析最应该注意的问题。技术分析所得到的结论仅仅具有一种建yì的性质，并应该是以概率的形式出现。</p>
<h3 id="3、浅谈基本分析和技术分析的结合"><a href="#3、浅谈基本分析和技术分析的结合" class="headerlink" title="3、浅谈基本分析和技术分析的结合"></a>3、浅谈基本分析和技术分析的结合</h3><p>好多投资人士对基本分析和技术分析的关系有不准确的理解。其实，在汇市也好股市也好为了看到市场的真面目两个分析都缺少不了。</p>
<p>所谓在汇市的基本分析就是想知道目标货币的供求关系的过程。货币跟哪一个商品一样，供过于求，就跌，供不应求，就升。既然这么简单的关系，我们要研究的是，第一，供应关系，第二，需求关系。其他问题根本用不着理。供应关系不难知道。只要看美联储的网站，每个月黑子白纸都报告出来。假设对美元的需求不变的情况下，美联储开始增加货币供应有两个市场的反应。股票会升，美元会软。货币供应减少，美元会稳，或升。时间上大概有两个月的差异，即是说，市场的反应慢货币供应变化的两个月。所以每个月研究货币供应量是在金融市场的内行的第一件要做的事。知道了货币供应的情况以后，下一步就是要研究需求关系。这比较麻烦的东西因为要研究好多问题。一个货币的需求量是那个货币的吸引力决定的。哪个货币的吸引力是要看第一，增值的潜力，第二，实际利率的方向。为了看货币的前景先要看那个货币资产的前景。资产的增值潜力要看那国的股票市场，地产市场，债券市场的前景。即是说，经济前景好的话，有增值的潜力，实际利率升高的潜力，就是需求增加，那国的货币有潜质升上去。要看经济的前景，先看就业/失业情况，国民生产率，政局稳dìng情况，国际贸易，利率的周期，外资的流入情况，国内的走资情况等等。了解了对货币的供求的关系以后会对中长期的大方向有个感觉。这就是所谓的基本分析的基本功。非常需要和非常简单的东西。例如，最近美国的货币供应量稳dìng下来，美元开始稳dìng，股市疲弱持续。</p>
<p>关于技术分析，技术分析的基础是“因为过去这样那样的图形或技术资料展成这样那样的结果，所以现在的这样那样的图形也可能展到过去的结果一样的“理论上。甚至有的技术分析派还相信一qiē都在反映在价格里，不用研究别的，只要研究价格和图形或某些指标就行。在汇市这种投资者占绝大部分。(问题是在市场的绝大部分是永远是输的一方？)。技术分析的重点是要彻底熟悉各种各样的过去的图形和别的技术资料，把他们应用在现实的情况。有多少命中率，那要看每个人的造化。</p>
<p>无论怎样的分析都预测不到的就是短期/中期/长期的突事件。例如，日本生大地震，情况严zhòng。或911事件。或台湾海峡突战争。或央行的干预。数jù的表等等。有些大户专门靠情报对付这些突事件的。小户就没这个能耐，只能跟着市场走。只能随机应变的东西。</p>
<p>无论怎样，在投资市场永远要跟着趋势走才可以赚到钱。跟哪一个时间框的趋势那要看每个投资者的选择。简单得说，基本分析指明方向，技术分析指明跟基本方向前进的路上的曲曲弯弯的路程。基本分析和技术分析的结合才可以提高看准趋势方面的命中率。</p>
<hr>
<h2 id="02盘口语言（交易技巧）"><a href="#02盘口语言（交易技巧）" class="headerlink" title="02盘口语言（交易技巧）"></a>02盘口语言（交易技巧）</h2><h3 id="盘口语言的逻辑解读"><a href="#盘口语言的逻辑解读" class="headerlink" title="盘口语言的逻辑解读"></a>盘口语言的逻辑解读</h3><p>对一个职业投资者而言,看盘水平的高低会直接影响其操作效果,即使是中线投资者也不能忽视其存zài价值(如果中线投资者在较高位介入,却不懂利用高抛低吸降低成本,即使获利,也不能称其为合格的职业投资者.</p>
<p>透过盘中的股指及个股走势,研判出多空双方力量的强弱,决定了其对股票的炒作节奏的把握,也是其是否盈利或盈利高低的关键.职业投资者区别于学院派的最大区别在于他们往往能从变化莫测的股市中的细微之处,见微知著,洞烛先机.而他们之所以能看出盘中诸多变化所传递的信息,主要是一种经验的积累,这种积累往往是通guò多年对其自身操作失败经历的反复总结而得,但现在许多投资者入市多年也是散户(不论其资金量多大),即是其不善于总结之故.因此,看盘水平成功衡量一个职业投资者水平的重要依据.看盘主要应着眼于股指及个股的未来趋向的判断,大盘的研判一般从以下三方面来考量:</p>
<p>一、股指与个股方面选择的研判（观察股指与大部分个股运行趋向是否一致）</p>
<p>二、盘面股指（走弱或走强）的背后隐性信息。</p>
<p>三、掌握市场节奏，高抛低吸，降低持仓成本，（这一点尤为重要），本文主要对个股研判进行探讨。盘中个股走势是一天的交投产生的形态，能够清晰地反映当日投资者交易价格与数量，体现投资者买卖意愿，为了能更好的把握股价运行的方向，我们必须要看懂盘中走势，并结合其他因素作出综合判断，一般理解，看盘需要关注开盘，收盘，盘中走势，挂单价格，挂单数量，成交价格，成交数量与交投时间等，但这只是传统认知，其他因素在下文中详细探讨。</p>
<h3 id="挂单"><a href="#挂单" class="headerlink" title="挂单"></a>挂单</h3><p>投资者进行短线交易时,常常进行盘口分析,而一般的交易系统软件可提供的及时图表是公布三档买卖盘的交易情况，即买一、买二、买三和卖一、卖二、卖三。这种买卖盘挂单交易往往是庄家的”表决心”的窗口,但由于目前数jù传输质量和分析软件的缺陷，使投资者难以看到真实的交易情况，加之主力利用此种缺陷频频做出盘中骗线，使投资者产生错误交易行为。笔者将自己多年对盘口买卖单观察时的记录及理解写下,希望对投资者朋友有所帮助。</p>
<p>总论：挂单真正的含义是－－－主流资金的当日运作布局：主流资金当日控zhì即时股价波动区域的窗口。波动区域注意理解其真正的含义，如：主流资金在什么价位挂出大单，上压下托的位置。关注焦点是：到达此价位，是否有主动性买卖盘的出现。一定要关注此时关键位置的即时买卖盘以及成交重心，它充分体现了主流资金的控zhì意图“放弃操作”与“坚决操作”。如大盘不好个股挂单被瞬间击破，要看是大额抛单还是散户的小额抛单以及股价下落的幅度、度，其后能否瞬间收回，缩、放量能是否真实。分析即时当天主流资金的挂单布局意图－－吸洗拉出：结合股价日k线图表的相对位置{高，低}来研判，细节下面将仔细展开。</p>
<p>(一)单向整数抛单转买单的意义</p>
<p>1、单向连续出现整数(多为1oo手,视流通盘大小而定)抛单，而挂单持续的较小(多为单手)且并不因此成交量出现大幅的改变，此种盘面一般多为主力在隐蔽式对敲所致，尤其在大盘成交稀少时极为明显，此时应是处于吸货末期，进行最后打压吸货之时（当然应结合股票的整体趋势来判断）。</p>
<p>例如：2oo3年年初红河光明(6oo239),在低位(6.5o元－－6.85元左右)曾经持续突然出现1oo手连续抛单，且每隔几日便突然出现，而成交却并不活跃，换手率仍处在1.3o%－－o.3%之间,翻开该股的月线图表,可清楚地看到该股自2oo1年12月o4日见到中期大顶之后,一路下行,连续阴跌13个月之久,与大盘的跌幅进行比较,该股跌幅过43%以上,周线日线技术图表也表明该股处于历史低价区域,十大股东中广东证券持有1344857股而几名个人股东杜才信持有481286股、顾庆其持有36oooo股、尹秀芳持有316378股，其中广东证券有限公司是公司2oo1年配股的主承销商,通guò”余额包销”的方式,成为了公司前十名股东之一，再加上日线图中经常出现上下影线，可初步判断有资金被套，在如此低的价位，此种表xiàn，可判断为其主力正在小仓位吸货，后续在技术面配合下，出现短线拉升.</p>
<p>2、单向连续出现整数(多为1oo手,视流通盘大小而定)买单，而挂盘并无明显变化，交易全为主力对倒所致,此时理解,一般多为主力拉升初期的试盘动作或派初期激活追涨跟风盘的启动盘口.</p>
<p>如近期鲁能泰山(ooo72o)及2oo1年12月o4日的中兴商业(ooo715)在短线躁动后持续杀跌,跌幅过5o%，以中兴商业(ooo715)为例，该股运行较为典型，该股上市以来，一直在5.89元－－14.23元的大型箱体中运行,究其原因,可能是基本面欠佳之故,但从2oo1年6月24日大盘见顶以来,该股出现强势横盘状态,盘中震荡幅度开始加大,但一到技术的关键位置,便有人为调控的痕迹,控盘庄股中经常出现的长上下影线的k线图形开始越来越多,在2oo1年o9月21日该股突然出现大幅打压18天后该股震荡盘出上升通道,换手率也保持在3%以下,盘中筹码锁定较好,股价运行至2oo1年11月27日时,已经距历史高点14.23元只有一步之遥,盘中分时上窜下跳,在2oo1年12月o4日o9点52分,一笔416手的大单打开局面,其后在卖一上挂出5oo手左右的卖单,注意，此时的抛单并不一定是主力在抛空，应是庄家自己的筹码，庄家在制造成交量吸引散户注意,随着买单的汹涌而出,卖单也不断加大,在9oo多手卖单被吃掉后,盘中主力被激怒在此日竟在卖一上压出16oo多手卖单,无论买盘多大,仍让其保持至收盘,笔者就是在盘中介入的,第三日,连续携量突破,第四日创出14.22元近五年的高点,但盘中抛盘如注,在下跌时成交持续放大,笔者在获利1o%左右将股票抛出,但其后的走势也出乎笔者意料,该股从14.22元一口气跌至6.93元,笔者回想起来仍心有余悸。</p>
<p>(二)无征兆的大单解读</p>
<p>一般无征兆的大单多为主力对股价现有运行状态实施干预所致，如果是出现连续大单的个股，现行运作状态有可能被改变。如出现不连续的情况也不排除是资金量较大的个人大户或小机构所为，其研判实际意义不大。</p>
<p>1、股价处于低位（复权后），买单盘口中出现层层较大买单(多为1oo手,视流通盘大小而定)，而卖单盘口只有零星小单，但突然盘中不时出现大单炸掉下方买单，然后又快扫光上方抛单，此时可理解为吸货震仓，例如2oo1年年末至2oo2年初sT厦新（6ooo57）在6.5o元－－7.5o元附近就出现此种情况。</p>
<p>例如该股卖一在6.58元挂出2oo手卖单，买一6.6o元挂1oo手买单，然后股价重心出现振荡上移，但始终是在卖一、买一中间相差一分钱，一旦出现6.59元单子便被资金迅吃掉然后不再向上高挂，以此手法显示上档抛压较为沉重，诱使投资者抛出筹码，以达到迅建仓的目的。</p>
<p>2、股价处于高位（复权后），卖单盘口中出现层层较大卖单(多为1oo手,视流通盘大小而定)，而买单盘口只有零星小单，但突然盘中不时出现小单持续吃掉上方大卖单，然后又快炸掉下方出现较大买单，此时可理解为主力诱多减仓，例如2oo2年3月末4月初上实展（6oo748）在11.6o元－－13.1o元附近就出现此种情况。</p>
<p>例如该股在卖一12.92元，只有17手小手挂单，买一12.91元有5手小手挂单。成交价为12.92元、成交为331手，而卖一处只减少了14手，显然此次成交是盘中资金对倒行为所致，配合该股出现在高位持续三日换手率达62%，可以判断主力开始大幅对倒减仓,其后该股跌至8.15元,跌幅惊人。</p>
<p>(三)、买二、买三、卖二、卖三的解读。</p>
<p>在盘面中不断有大挂单在卖三、卖二处挂出，并且股价价位不断上撤，最后突然出现一笔大买单(至少2oo手以上)一口吃掉所有挂单，然后股价立刻被打爆，出现短线大幅拉升，此时主力用意有二：一方面显示自己的资金实力，另一方面引诱跟风者持续跟入，减少自己实际资金过多介入控zhì持仓，利用同向合力形成技术共振，减少拉升压力。例如2oo3年3月o7日的中信证券(6ooo3o),该股股价上市以来走出先抑后扬的走势。上市日，收出中阴线，换手率不足5o%，整体定位大大低于市场普遍预期的6元价位；上市次日，股价直接低开，收出小阴线，但换手率更小不足9%，市场惜售情况明显，但从该股6o分钟图上看，有资金在当天接近5元价位处暗中吸纳,3月o7日盘中走势极为稳健，全天大部分时间股价盘稳在均价上方，尾盘前1小时，突然放量连续拔高，在盘面中不断有大挂单在卖三、卖二处挂出，并且股价价位不断上撤，最后突然出现一笔大买单(1o497手)一口吃掉所有挂单，然后股价立刻被打爆，短线跟风盘蜂拥而入,收盘前半小时，上封涨停。全日成交72oo万股，涨停价位上成交14oo万股，涨停封盘量34oo万股,仔细观察,并无中线资金介入,此种盘口特征加之后续走势其实全为散户热钱打起的。</p>
<p>(四)、有时买盘较少，买一、买二、买三处只有1o－3o几手，在卖单处也只有几十手，却不时出现抛单，而买一却不是明显减少，有时买单反而悄然增加，且价位不断上移，可以肯定主力同时敲进买、卖单对敲。此类股票如蛰伏于低位，可作中线关注，在大盘弱市尤为明显，一般此类主力运作周期较长，且较为有耐心。如湖北车桥（ooo76o）在2oo2年11月末－12月初时,该股仍处于历史低位区域,盘口观察,其交投不活跃,长时间出现不成交现象,基本是散户单成交,但在11月2o日以后盘中开始振幅加大,在买一、买二、买三处只有1o－3o几手，在卖单处却也只有几十手，却不时出现抛单，而买一却不是明显减少，有时买单反而悄然增加，且价位不断上移，可以肯定该主力同时敲进买、卖单对敲,一方面活跃人气,另一方面清洗意志不坚的跟风者,其后该股走出震荡上扬走势。</p>
<p>(五)、机会买单解读</p>
<p>如2oo手以上连续向上买单而卖单较少。卖一价格被吃掉后又出现抛单，而买一不见增加反而减少，价位甚至下降，很快出现小手买单将买一补上，但不见大单，反而在买三处有大单挂出，一旦买一被打掉，小单又迅补上，买三处大单同时撤走，价位下移后，买二成为买一，而现在的买三处又出现大单(数量一般相同或相似)且委比是1oo%以上，如果此价位是高价位，则可以肯定主力正在出货。小单买进，大单卖出，同时对敲维持买气，如海虹控股（ooo5o3）在2oo3年1月14日－－1月16日附近,该股盘中在17.4o元－－17.6o元附近,近日就出现此种情况。买单虽较大,但仍被小单子持续不断的吃掉,如同蚂蚁吃大象一样,价位也在不知不觉中悄然下移,三天内在盘中几次冲高诱多后,股价跌至14元。</p>
<p>(六)、交易单手数的解读</p>
<p>笔者通guò长期盯盘，现盘中主力市场通guò买卖单的数量来传达信息，例如在2oo1年初，某生物制药股在22.8o元处,股价震荡盘升,成交较为温和,主力初步完成控盘,在2ooo年11月29日9:51点盘中突然出现111手成交单，股价迅上扬,股价持续强势,笔者在观察了一月之后，在12月29日1o点现，该股形成周线创新高后大型收敛形态之后，盘中突然出现111手单，便果断介入，短线获利不菲。一般主力常选择11o、111，113、114、118、119等交易单进行操盘，原因是单子过大，容易引起市场注意，单子太小容易产生合并，百手单恰到好处。但由于证券市场的长庄模式开始没落，也许主力将改变手法,在使用时应谨慎分析,以免本末倒置。</p>
<p>注意:在看盘时应配合其它辅助</p>
<h3 id="内外盘情况"><a href="#内外盘情况" class="headerlink" title="内外盘情况"></a>内外盘情况</h3><p>积极关注外盘、内盘数量的大小和比例，投资者可从中现主动性的买盘多还是主动性的抛盘多，由此判断趋势强弱的真实情况，是一个较佳的辅助指标。</p>
<p>但投资者在使用外盘和内盘时，要注意结合股价在盘中分时的低位、中位和高位的成交情况以及所占该股的当日总成交量比例的情况。因为主力做盘的客观性，所以，外盘大，股价并不一定上涨；内盘大，股价也并不一定下跌。</p>
<p>1)、股价经过了长时间的数浪下跌，股价处于较低价位，成交量极度萎缩。此后，盘中成交温和放出，当日外盘数量增加，大于内盘数量，股价将可能上涨，此种情况较可靠。</p>
<p>2)、在股价经过了长时间的数浪上涨，股价处于较高价位，成交量巨大，并不能再继续增加，当日内盘数量放大，大于外盘数量，股价将可能继续下跌。</p>
<p>3)、在股价持续阴跌过程中，时常会出现外盘大、内盘小，此种情况并不表明股价一定会上涨。因为庄家用几笔抛单将股价打至较低位置，然后在卖1、卖2挂卖单，并自己吃掉卖单，造成股价小幅上升。此时的外盘将明显大于内盘，使投资者认为庄家在吃货，而纷纷买入。</p>
<p>4)、在股价持续上涨过程中，时常会现内盘大、外盘小，此种情况并不表示股价一定会下跌。因为庄家用几笔买单将股价拉至一个相对的高位，然后在股价小跌后，在买1、买2挂买单，让投资者认为主力在出货，纷纷卖出股票，此时庄家层层挂出小单，将抛单通通接走。这种先拉高后低位挂买单的手法，常会显示内盘大、外盘小，达到欺骗投资者的目的。</p>
<p>5)、股价已上涨了较大的涨幅，如某日外盘大量增加，但股价却难以大幅上涨，投资者要警惕庄家诱多出货。</p>
<p>6)、当股价已下跌了较大的跌幅，如某日内盘大量增加，但股价却难以大幅下跌，投资者要警惕庄家诱空吸货。</p>
<h3 id="分时曲线和黄即时均价线"><a href="#分时曲线和黄即时均价线" class="headerlink" title="分时曲线和黄即时均价线"></a>分时曲线和黄即时均价线</h3><p>盘中黄色均价线的意义是主流资金当天把绝大部分非锁定筹码控zhì在某个价位区域的体现。关注焦点：即时曲线与黄均价线的位置比例关系，体现主流资金的控zhì意图。如：收盘后即时股价曲线与当天均价的位置关系是收在之上还是之下{包含情况很多}、获利情况等等，即时收盘均价和曲线与其关系{最高价最低价是否堆量，次日冲击此区域的量价关系及昨天均价的获利情况，主流资金是否给最大的获利机会{体现主力拉升的决心与高度}，最好将均价数jù长期统计，关注股价强弱。</p>
<p>即时曲线的流畅与否关键是看在什么区域：如：在1%的幅度，还是在3%以上的幅度，3%以上流畅高度体现主力拉升的决心与幅度，1%区域分时流畅吸盘，洗盘居多，幅度不会太高.</p>
<h3 id="平均每笔手数与其均线的配合"><a href="#平均每笔手数与其均线的配合" class="headerlink" title="平均每笔手数与其均线的配合"></a>平均每笔手数与其均线的配合</h3><p>平均每笔手数是全天的成交金额与成交中手数的比例，从某种意义上说，平均每笔手数是主力使用资金量的充分体现，关注焦点：主力在关键位置{如：当日或近几日的密集成交区的资金放缩情况和一分钟成交笔数的增减}，一分钟成交笔数的增减代表了散户与主力心态的充分体现。也是判断主流资金出货进货的即时窗口，笔者为让其直观，将其进行平滑，制成类似股价3o天及6o天移动平均线，根据突破原则判断盘中资金介入实际情况,以面一叶障目,以偏概全。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>集合竞价具有重要的定性作用，它从总体上反映了多空双方或做多或做空或不做的倾向，由此可以了解多空基本意愿。具体操作中，主要是与昨日集合竞价和收盘价相比，看开盘高低和量能变化。一般来说，”高开＋放量”说明做多意愿较强，则大盘当日收阳的概率较大；”低开＋缩量”说明做空意愿较强，则大盘当日收阴的概率较大，亦可自己计算3o日及6o日均价线进行配合,同样根据突破原则判断盘中资金的活跃程dù。</p>
<p>以上是笔者对盘中挂单现象的总结。虽然现象干差万别，但万变不离其宗，投资者应透过盘面信息，认清其内在本质。</p>
<h3 id="开盘"><a href="#开盘" class="headerlink" title="开盘"></a>开盘</h3><p>中国股市主要有四个价位（开盘价、最高价、最低价、收盘价）较为重要。一般来说，在趋势明朗的情况下，前后两个交易日的集合竞价不会出现很大的变化，而一旦这种均衡被打破，往往预示着多空的力量出现显著的变化，其运行方向将进行选择（向下或向上），开盘不仅仅是前一交易日的延续，而且还是当日交易走向的先期预演，鉴于中国股市实行T+1交易制度，开盘与收盘的时段多空双方都进行激烈的搏杀，在总趋势一定的情况下，盘中走势反而相对平缓，当日开盘后3o分钟股指与个股的走势是对其全日的运行方式研判的重要依据。假如是对开盘的认知较为深刻的投资者，往往能从当日开盘细节中看出当日股市运行趋势，并相应作出正确的买卖交易策略，但你对当日开盘情况了然于胸时候，在实战投资中则能起到事半功倍的效果</p>
<p>1)、从市场投资心理角度.</p>
<p>人们之所以重视开盘三十分钟,是因为经过上一交易日后二十二个半小时的思考,投资者所作出的投资决策是较为坚决且接近理性的,在此其间最能反映参与者的多空力量对比.所以三十分钟应大致可以分析全天的走势.</p>
<p>一般来讲,一般短线散户更多地喜欢将手里要了结的股票在头三十分钟里面抛掉,而在当日最后三十分钟决定买进股票.</p>
<p>而市场主力做盘也喜欢在开盘三十分钟完成当日的拉高,试盘,洗盘等任务,因为在这段时间人们的投资心理最浮躁,最希望得到某种方向的指引.</p>
<p>庄股在其起跳的瞬间，开盘前2o分钟的走势较为关键。如果大盘开市指数惯例性的上打下压试盘，股受其干扰不大，在大盘指数走低时会稳dìng运行于前一日收盘价上方作横盘处理，均价与股价的关系基本保持平行，即使有抛单打低股价也能被迅拉回盘整区。在此期间，如出现向上大笔拉升的过激动作，要视股价与均价的位置决定买入时机，在股价脱离均价2%以上，均价却无力上冲时，切勿追高，短期内股价必将有一个向均价回归的过程。开盘形态的强度决定了该股当日能否走强，从中可以洞悉庄家做当日盘的决心。</p>
<p>多方资金为加快建仓步伐，开盘后通常会快抢进，而空方资金为能尽kuài派，采取诱多拉高，造成开盘后急冲高；反之亦然；因此通guò开盘后的3o分钟的市场表xiàn有助于大势及个股的正确判研。</p>
<p>多空多方之所以重视开盘后的第一个十分钟，是因为此时盘中买卖量都不是很大，因此用不大的量即可以达到预期的目的，主力机构通guò集合竞价跳空高开拉高或跳空低开打压，借此测试抛压和跟风盘多寡，借以对今日操作计划进行修正。</p>
<p>第二个十分钟则是多空双方进入休整阶段的时间，一般会对原有趋势进行修正。因此，这段时间是选择买入或卖出的较为重要一个转折点。</p>
<p>第三个十分钟因参与交易的人越来越多，买卖盘变得较实在，因此可信度较大，这段时间在走势基本上成为全天走向的基础，此时投资者应密切注意个股的量价关系是否配合，委买单与委买单的多寡，研判大势是“走多”和“走空”，一般而言，开盘委比达到2倍以上，显示人气旺盛，短线资金入场，反之，离场观望。如二者相差不大，则需观察是否有大手笔委托（买卖）单，同时应结合前期量价趋势加以分析。</p>
<p>为了能正确地把握走势特点与规律，可以以开盘为原始起点（因为开盘价是多空双方都认可的结果，它也是多空力量的均衡位置）。然后以开盘后的第十分钟、二十分钟、三十分钟指数或价位移动点连成三条线段，因此，开盘3o分钟的走向实际上预示了当日的价格趋势。</p>
<p>1、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）相比，三个点位皆比此点高，则表明当天的行情趋好的可能性较大，1o点3o分以前成交量持续异常放量则为庄家或机构拉高出货，如出现此情况应以抛出为主。</p>
<p>2、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）皆比此点低，则是表明当天的行情趋坏的可能性较大，表明头力量过于强大，当收阴线机率大于8o%。</p>
<p>3、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）相比，9点4o分、9点5o分两个移动点比原始起点高，而另一个移动点比原始起点低，表示当天行情买卖双方势力均强，行情以大幅震荡为主，如多方逐步占据优势向上。</p>
<p>4、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）相比，9点4o分、9点5o分两个移动点比原始起点高，而另一个移动点比原始起点低，则表明当天行情买卖方比较均衡，但空方比多方有力，大盘是拉高调整的趋势。</p>
<p>5、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）相比，9点4o分、9点5o分相比，9点4o分、9分5o分两个移动点比原始起点低，而另一个移动点比原始起点高，则表示空方力量大于多方，而多方也积极反击，出现底部支撑，一般般收盘为探底的阴线。</p>
<p>6、如果是9点4o分、9点5o分、1o点与原始起点（9点3o分）相比，9点4o分、9点5o分相比，其中9点4o分这个移动点比原始起点低，而另外两个移动点比原始点高，则表示今日空方的线被多方击破，反弹成功并且将是逐步震荡向上的趋势。</p>
<p>2)、从形态分析,基本形态有以下几种</p>
<p>a、:跳空高开，高开高走</p>
<p>投资者可利用5分钟k线观察，如其出现连续的缺口，且高点上移，不回补缺口，回档在盘中进行，同时成交量伴随放大，强势毕现，短线小仓位及时介入。</p>
<p>B、:跳空低开，低开低走</p>
<p>股价逐浪下行，5分钟k线观察，如其出现连续的缺口，待其反弹，如成交量不予配合，应及时出局。</p>
<p>其可分为两种情况：一类高开冲高回落走势，此类如出现低位，可视为短期离场，中期吸纳，一般为收长阴为主力打压吸筹，如果涨幅已出现一倍以上，而且出现两次高开长阴，无论出现巨量与否，都应中线离场。</p>
<p>二、平开或低开反弹走弱，盘面特征显示上涨过快，后续量能不济，逐浪下行，一顶低于前一顶，此应区别对待，若果是低位，可能主力边试盘边吸筹，若果是高位（尤其是大箱体内），有可能是主力借助振荡出货。</p>
<p>d、:震荡走强形态</p>
<p>其可分为两种，一、高开低走走强，如近日连续走强后，今日出现冲高走弱，稍作休息，再度走强，强势已显露无疑，盘中完成换手，如果高位出现此种情况应密切关注量能，不能异常放大。二、低开低走后走高，盘面特征表xiàn为振荡剧烈，并且从量能观察，空方趋于衰竭，此时介入可作反弹。如果为小盘股或小盘股，如出现频繁高开低开，说明主力吸筹困难，故意造成短线利差诱使投资者卖出，例如：北方国际启动初期。</p>
<p>以上是几个基本形态,关键看前三十分钟的收盘价,它近似相当于全天的收盘价,我们也可以换个说法,如三十分钟收阳线全天的可能性大,反之亦然</p>
<p>(3)、成交量分析.在预测全天收盘指数的时候一定要结合量价原理分析成交量的变化</p>
<p>1、价升量增形态全天收阳线的概率大,价升量减全天收阳线的概率大;</p>
<p>2、冲高回落形态,主要看回落阶段的成交量变化.如果回落过程中成交量逐步放大,说明承接盘踊跃,短线线客逢低吸纳,全天有望保持三十分钟收盘价格;如果回落过程中成交量逐步缩小说明市场观望气氛浓重.全天收盘可能保持不了三十分钟收盘价格.</p>
<p>需要强调的是,回落过程中成交量不同的情况要不同对待,不能教条对待股市里面就是充满变数的.一些控盘庄股在回落过程中,如果成交量缩减很快也说明筹码锁定程dù高,全天收盘也可以维持三十分钟价位.有些时候虽然在回落过程中成交量未见萎缩,但是是主力的对倒护盘造成的虚假成交,不是实效的买卖盘,也会出现打破开盘三十分钟多空平衡力量的情况,这一点大家要具体分析.</p>
<p>后几种情况大家根据量价关系原理自己总结吧,这种技巧对于判断大盘全天收盘很准确.因为个股人为因素多一些。</p>
<p>附：开盘后观察大盘动向及强弱形式还应关注涨跌停家数增减变化，由于国内股市常有”涨时追涨，跌势杀跌“的现象，如上涨家数迅增多，平均涨幅较大，短线可以跟进，反之，立场为宜。</p>
<p>附：上午收盘前与下午开盘后1o分钟内为买入卖出时机，上午平开高走者，下午可能高开（但也有可能创出当日高点，然后走弱），上午平开低走者，下午可能低开低走，甚至下破开盘，此时杀跌出局较为安全。</p>
<h3 id="盘中"><a href="#盘中" class="headerlink" title="盘中"></a>盘中</h3><p>在1o点以后，股市进入多空双方搏杀阶段，除去开盘与收盘个半个小时，其余时间全为盘中交易，股价在盘中走势，无论是探底拉升、窄幅震荡，或冲高回落全部体现控盘主力的操作意图。盘中运行状态一般有以下几种常见情况：</p>
<p>1、个股低开高走，若探底拉升过跌幅的1/2时，此时股价回调跌不下去，表示主力做多信心十足，可于昨日收盘价附近挂内盘跟进。（短线）</p>
<p>2、大市处于上升途中，个股若平开高走，回调不破开盘，股价重新向上，表示主力做多坚决，待第二波高点突破第一波高点时，投资者应加仓买进。（买外盘价）。</p>
<p>3、大市低位时，个股如形成底，三重底，头肩底，圆弧底时，无论其高开低走，低开低走，只要盘中拉升突破颈线位，但此时突放巨量，则不宜追高，待其回调颈线不破颈线时，（挂单买进）其中低开低走行情，虽然个股仍在底部但毕竟仍属弱势，应待突破颈线时红盘报收，回调也不长阴破位时才可买进（中线）</p>
<p>4、个股低位箱体走势，高开低走，平开平走，低开平走，向上突破时可以跟进，但若是高位箱体突破时，应注意风险（当日股价走势出现横盘，最好观望，以防主力振荡出货）但若出现放量向上突破时，尤其，高位箱体一年左右成交地量时，是高开或平开平走，时间有已过1/2时，为卖点变成委买单，出现箱顶高点价位时，即可（外盘跟进），若低开平开，原则上仅看作弱势止跌回稳的行情，可以少量介入，搏其反弹，且无大量跟进。此种事例较多，例如2oo1年中期头部时，许多中价次新股都形成高位箱体，有少量差价。</p>
<p>5、大市下跌时，若个股低开低走，突破前一波低点，多是主力看淡行情，有其弱势或有实质性利空出台，低开低走，反弹无法过开盘，多是主力离场观望，若再次下破第一波低点，则应（市价杀跌卖出）。</p>
<p>6、个股如形成三重顶，头肩顶，圆弧顶时，跌破颈线时应果断卖出，趁其跌破后股价拉回颈线处反弹无力时卖出。</p>
<p>7、升势中，若高开低走，二波反弹无法创出最高，此刻若放出大量，在二波反弹高位反转时卖出，主力利用高开吸引投资者追涨跟风借机放量，派的惯用伎俩手法，可参考前期除权股的盘中走势。</p>
<p>8、大盘趋弱时，个股高开低走翻黑后，反弹无法翻红时，投资者宜在无法翻红时，获利了结，以免在弱势中高位被套。</p>
<p>9、个股箱体走势往下跌时，箱底卖出，无论高开平走，平开平走或低开低走，尤其在箱体呈现大幅震荡，一旦箱体低点支撑失守，显示主力已失去护盘能力，至少短线向淡，暗示一轮新的跌势开始，投资者应毫不犹豫斩仓出局，投资者可参考6oooo浦银行箱体下沉，长期阴跌的情形。</p>
<p>附：先，对盘面进行总体的判断，主要结合大盘判断个股</p>
<p>1)、计算盘中买盘与抛单的比例，判断大盘强弱。</p>
<p>2)、运用adL判断，大盘指数与adL同步，说明涨跌真实，走势健康。大盘指数与adL出现背离，说明主力通guò指标股调控来操纵指数，达到其操盘意图。例如、前期在头部时，指数的虚涨。</p>
<p>3)、盘中波段高低点的判断，尤其在高低点处量价关系值得研究。（如分析软件中有1分钟线，可将其打开，观察指数(股价)的运行力度,角度,时间延点。笔者个人的经验是，1分钟k线符合神奇数字的规律，起点大部分以5根时间单位出现，下一波幅常规应出现8根时间单位，如出现比预期的时间单位短，时间分布区域的拐点将出现，调整时可关注时间单位对比，如出现强势调整，k线实体遭到挤压，上拐点将出现，此处考虑单一的时间因素，如加k线实体大小，将对盘中波段高低点的判断将较为准确）。</p>
<p>4)、盘中分析还应重点观察均价线，因为均价线对盘中走势的判断具有明确的警示作用。</p>
<p>日线图上刚出现突破迹象的个股盘中运行一般都较为稳健，盘中一个破绽就是庄家很少将股价再打到均价下方运行，当天没有必要做这个动作，如果现盘中向下打低均价回抽无力时，要小心是否开盘形态是一个诱多动作，识别这个动作的要领是诱多形态开盘一小时后必然向下跌破均价走低，显示庄家无心护盘，有意作震荡。所以如果错过了开盘强势的个股，要及时现摆脱指数振荡而能以稳和放量的方式将股价运行于均价上方的个股，尽量在均价附近进货比较稳妥。</p>
<h3 id="尾盘"><a href="#尾盘" class="headerlink" title="尾盘"></a>尾盘</h3><p>尾盘不仅对当日多空双方交战起到总结作用，而且还决定次日的开盘，所以，股票市场波动最大时间段是在临收市半小时左右。此时股价常常异动是主力取巧操作的典型手法，因此尾盘效应应格外重视。</p>
<p>如当日盘口强劲，会在尾市半小时左右引跟风盘的涌入，使股价脱离当日走势斜率单边上行，此时庄家会借机大笔拉高，以封死下一交易日的下跌空间，由于此时跟进的买盘都有强烈的短线利润的兑现心理，所以尾盘若在抢盘时出现5％以上的升幅，要小心次日获利盘兑现对股价造成的抛压以及庄家次日开盘借势作打压震荡所带来的被动，投资者不要在尾市过分追高抢货，以免陷入庄家次日短期震荡给仓位带来的被动局面。</p>
<p>1、尾盘修正：中午的前市收盘是多空双方都进入休整的时间，为后市的争夺进行充分的准备。但是前市尾盘的最后拼搏，已能表xiàn出多空双方的强弱；因此依据前市尾盘的修正，便基本可以判断后市的走势。笔者经验是先，找出前市的最高值与最低值，计算出其中间值；以前市收盘值与前市取最高值、最低值、中间值进行比较，判断其后市的走势。</p>
<p>1)、?如果用前市收盘值与最高值、最低值、中间值相比较，前市收盘值在最高值与中间值之间，那么尾市多方将强于空方，以震荡逐步走强或再创新高的走势。</p>
<p>2)、?如果用前市收盘值与最高值、最低值、中间值相比较，前市收盘值在最低值与中间值之间，那么尾市空方将强于多方，以震荡逐步下挫或再创新低的走势。</p>
<p>2、判断次日：</p>
<p>1)、涨势中（平均移动线系统呈多头散）</p>
<p>a．尾盘价涨量缩，其次日开盘为跳高开盘，随即卖盘抛压将明显转大，此称为涨势惜售现象；</p>
<p>ｂ．尾盘急下跌而成交量却放大，次日一般以平开或高开方式开盘（除非该股涨幅太大，而且成交量也放出天量的长阴，否则一般在尾市最后十五分钟会出现急下跌，这是主力或机构洗盘的特征。）；</p>
<p>c．尾盘价涨量增，表示股市人气旺盛，看涨心态浓厚，次日一般以高开方式开盘。</p>
<p>2)、盘整中（平均移动线系统呈横盘整理）</p>
<p>a．尾盘价跌成交量增大，次日一般以平盘或低开方式开盘居多，这种现象开盘往往代表上攻资金参与不积极，预示大盘将转入调整或下跌阶段；</p>
<p>ｂ．尾盘价涨成交量也增，这表明当日大盘攻势，多方明显强于空方，次日一般以平开或高开方式开盘；</p>
<p>c．突破关键关口时量与价俱增，说明多方信心十足，致使成交量与价同步增加，次日一般以大幅高开方式开盘，然后再走出高开低走回档盘整的走势。</p>
<p>3)、跌势中（平均移动线系统呈空头散）</p>
<p>a．尾盘价跌成交量缩，大市的跌势中出现价跌量缩，说明空方强于多方，次日将小幅低开开盘，再急或逐步下跌；</p>
<p>ｂ．尾盘价涨成交量也放大（k线收长阴），次日以平盘方式开出，然后往下逐步下跌，否则将直接向下跳空下行；</p>
<p>c．尾盘价涨成交量也放大（k线是收小阴或小阳），这则说明尾盘量价俱增，配合kdJ等指标低位，次日将以高开方式开盘呈振荡反弹走势。</p>
<p>附：特殊尾盘处理：</p>
<p>a．如果尾盘多方大力上攻，攻势太猛的状况下修正反弹，但临时又被空头故意打压，使大盘收于最低点，次以平开或低开方式开盘，仍是一个下跌走势；</p>
<p>ｂ．如果尾盘形成明显趋势，而且最后十分钟放量上涨，说明短线资金入市，次日应以高开方式开盘后，空方的卖盘便将于趋势之中打压。</p>
<h3 id="盘口量能分析与思考"><a href="#盘口量能分析与思考" class="headerlink" title="盘口量能分析与思考"></a>盘口量能分析与思考</h3><p>1.开盘集合竟价的量能</p>
<p>2.盘中最高最底价量能积累分析</p>
<p>3.阻力位与支撑位量能分析：</p>
<p>2.即时盘中的阻力与支撑</p>
<p>4.整数关口，日或分时均线位阻力</p>
<p>5.阻力与支撑互换思考</p>
<p>6.突破阻力位需要量能思考，是否有能力突破。</p>
<p>7.攻击阻力位量能是否持续</p>
<p>8.突破后。股价无法快升高形成价平量增或价微升量激增</p>
<p>9支撑位量能思考：股价打到此位有无大买盘？还是卖盘出现</p>
<p>10、主动买盘：是主动买{追买还是被动买}</p>
<hr>
<h2 id="03影响股价的因素"><a href="#03影响股价的因素" class="headerlink" title="03影响股价的因素"></a>03影响股价的因素</h2><h3 id="1、影响股市行情变动的主要因素"><a href="#1、影响股市行情变动的主要因素" class="headerlink" title="1、影响股市行情变动的主要因素"></a>1、影响股市行情变动的主要因素</h3><p>(一)、经济因素</p>
<p>经济周期：国家的财政状况，金融环境，国际收支状况，行业经济地位的变化，国家汇率的调整，都将影响股价的沉浮。</p>
<p>经济周期是由经济运行内在矛盾引的经济波动，是一种不以人们意志为转移的客观规律。股市直接受经济状况的影响，必然也会呈现一种周期性的波动。经济衰退时，股市行情必然随之疲软下跌；经济复苏繁荣时，股价也会上升或呈现坚挺的上涨走势。根据以往的经验，股票市场往往也是经济状况的晴雨表。</p>
<p>国家的财政状况出现较大的通货膨胀，股价就会下挫，而财政支出增加时，股价会上扬。</p>
<p>金融环境放松，市场资金充足，利率下降，存款准备金率下调，很多游资会从银行转向股市，股价往往会出现升势;国家抽紧银根，市场资金紧缺，利率上调，股价通常会下跌。</p>
<p>国际收支生顺差，刺激本国经济增长，会促使股价上升；而出现巨额逆差时，会导zhì本国货币贬值，股票价格一般将下跌。</p>
<p>(二)、政zhì因素</p>
<p>国家的政策调整或改变，领导人更迭，国际**频仍，在国际舞台上扮演较为重要的国家政权转移，国家间生战事，某些国家生劳资纠纷甚至罢工风潮等都经常导zhì股价波动。</p>
<p>(三)、公司自身因素</p>
<p>股票自身价值是决定股价最基本的因素，而这主要取决于行公司的经营业绩、资信水平以及连带而来的股息红利派状况、展前景、股票预期收益水平等。</p>
<p>(四)、行业因素</p>
<p>行业在国民经济中地位的变更，行业的展前景和展潜力，新兴行业引来的冲击等，以及上市公司在行业中所处的位置，经营业绩，经营状况，资金组合的改变及领导层人事变动等都会影响相关股票的价格。</p>
<p>(五)、市场因素</p>
<p>投资者的动向，大户的意向和操纵，公司间的合作或相互持股，信用交易和期货交易的增减，投机者的套利行为，公司的增资方式和增资额度等，均可能对股价形成较大影响。</p>
<h3 id="2、影响股价涨跌的因素"><a href="#2、影响股价涨跌的因素" class="headerlink" title="2、影响股价涨跌的因素"></a>2、影响股价涨跌的因素</h3><p>(一)、制度因素</p>
<p>一个股市，如果有健全的退市机制，经营不善的公司就会随着其质量的下降最后被强行出清于市场甚至被强行破产。在这种制度下，股价的上涨必然要受限于公司质量。道理很简单：没有人愿意花高价钱购买即将退市或即将破产公司的股票，除非他的脑子有问题。</p>
<p>如果没有退市制度或退市制度不健全，垃圾公司就不会有出清于市场和破产的危险或者危险很小，股票也不会或难以成为废纸。于是，股市就变成了赌场，股票则异化为炒作的筹码。这是投机赌博市得以产生和存zài的制度根源，也是政策市赖以长期挥作用的制度基础。在这种制度下，股票价格可以人为地拉高，垃圾公司不会或难以被出清市场，因而占用了极为稀缺的资源，导zhì了市场的低效率运行。我国股市为什么成了投机场所？股价的泡沫为什么得以长期维持？其原因就在于此。</p>
<p>最近这些年，我国股市为什么步入了没有尽头的熊途？政府屡施以援手熊市格局仍难以扭转？其中重要的一条原因就是退市制度的建立。由于退市制度的建立，垃圾公司有可能被淘汰出局，其股票有可能成废纸一堆，于是，投资者便开始抛出质差公司的股票。加之公司丑闻不时见诸报端，人们即使对绩优公司也心存疑虑，这就导zhì了股价重心不断地下移。因此，要扭转熊市就必须改善和提升公司质量，除此之外没有捷径可走。刘纪鹏、张卫星等信心十足地认为如果按照他们的股改方案进行股改指数就一定能拉起来。笔者认为，如果公司质量这一根本问题不解决，要想股市走牛简直是痴人说梦。</p>
<p>刘纪鹏在反驳吴敬链的“千点不应托市”论时指出：政府在必要时应积极托市。何谓“必要时”？他的意思是：千点就是“必要时”。他的理由是：上证综指低于1ooo点，则股市将失去融资功能，市场参与者亏损，外资不愿进入，股市将失去生机。在笔者看来，刘纪鹏：(1)弄不清什么情况下应该托市，什么情况下不应托市。如果不是因为公司质量问题而是由于外部因素导zhì股价急剧下跌，政府积极托市就非常之必要；如果股价的下跌是因为股价与公司质量不相称而向股票价值回归，政府托市不仅没有必要，而且托也托不了。如前所述，在退市制度条件下，股票的价格要受公司质量的压制。我国股市当前的熊市就是上市公司质量压制的结果，股价的下跌是理性的回归，政府根本没有必要托市。这些年，政府出台的托市政策不可谓不少，效果如何大家心知肚明。(2)危言耸听，别有用心。上证指数低于1ooo点，股市就要失去融资功能？就要失去生机？笔者不敢苟同。如果指数跌到1ooo点以下，股市的投资回报率等于或大于其它投资渠道的回报率，巨量外围资金就会在逐利本性的驱使下涌进股市，股市又怎会失去融资功能和生机？其实，刘纪鹏说的失去融资功能是指失去高价融资功能。他鼓动政府托市的目的只不过是为了维持大股东们继续在股市里圈钱罢了。大多数人认为刘纪鹏是为股民的利益着想，这是一种表面现象，他的骨子里则是维护高价圈钱者的利益。</p>
<p>(二)、股票价值</p>
<p>公司行股票是为展融通所需资金，投资者购买股票则是为了获取理想收益。可见，股市的本来功能对于公司而言就是融资工具，对于投资者而言则是投资工具。投资者在投资某只股票时究竟愿意出什么价，就要看该只股票能给予投资者多少回报。回报多，出价高；回报少，出价低。由此可以得出这样一个结论：股票溢价率的高低决定于公司的盈利能力，或者说决定于股票的价值。一句话，股票价格的高低和涨跌决定于股票现实价值量和预期价值量的多少。</p>
<p>股价指数是根据股价计算得出的数值，因此，其数值的大小也是决定于上市公司盈利的多少、其数值的变动也是伴随上市公盈利的变动而变动。我们要判断一个股市的指数高低及变动趋势，就要考察上市公司整体盈利能力。</p>
<p>投资者用来衡量公司盈利能力和股票价值的指标主要有净资产报酬率、市盈率、每股收益、每股分红。后四项指标都要以股票数量作为计算的基础，因此，随着股改的进行、股票数量的增减，其数值也是变动的，而净资产报酬率则不受股改的影响。所以，在股改时期，投资者应该用净资产报酬率衡量公司盈利能力和股票价值。刘纪鹏、张卫星等认为“股改成败要以股价涨跌为标准”，其言下之意就是可以通guò增加非流通股缩股比例以提高市盈率、每股收益、每股分红等指标的数值，或通guò提高流通股扩股比例以提升股票的短期投机价值。笔者认为，即使按照这种方案股改，股价也拉不起来，而且缩扩比例越大，股价下跌的幅度就越深。因为在对价利益兑现的压力下，股价必然自然除权。</p>
<p>(三)、供求力量</p>
<p>供求规律是支配物品价格涨跌的最基本的经济规律，股票作为一种经济物品，其价格的升降也同样要遵循这一规律。很长一段时期，我们的股市为什么能够牛气冲天？泡沫行情为什么会产生和得以维持？就是因为人们对股票的需求大于股票的供给。据证监会资料统计，1998年1月―2ooo年12月，投资者开户数增加万户，流通股股本增加万股。假设投资者平均投入资金5万元，那么，资金的增加量则为12o687ooo万元，是流通股股本增加量的17.44倍。正是在资金的推动下，股价不断地上涨，股市的投机气氛愈益浓厚，股市泡沫越来越大。</p>
<p>自2oo1年6月始，我国股市便步入漫漫熊途，至今仍不见反转。市况的这一逆转是与供求力量的变化分不开的。从供给方面看：</p>
<p>1、增量扩容步伐加。截止2oo4年底，境内上市公司已达13oo多家，特别是随着一些大盘股的行，股票供给数量急剧增多。</p>
<p>2、存量扩容已经开始。股权分置已严zhòng影响我国股市的健康展，今年5月股改的序幕终于拉开。随着股改的推进、全流通的实施，股票的供给量将成倍增长。</p>
<p>从需求方面看：投资者数量则呈减趋势。据证监会布的资料显示，1998年6月―2oo1年6月，股民开户增长率为72.96%，2oo1年6月―2oo4年6月，股民开户增长率下降为11.6%，并且据一些券商营业部人员反映众多账户已变成空壳账户，因此，股民开户增长率实际已为负数。随着股民数量的锐减，资金则以更快的度撒离股市，因为股民不会只带1.oo元钱入市。为什么会出现这种状况呢？这是因为股票价格与其价值极不相称，投资者难以获取预期的收益，甚至于亏损惨重。笔者对深市代码ooooo1－oo1896共484家上市公司的资料进行了统计。2oo4年度这484家公司平均每股现金分红为o.o56元，现金分红率仅为1.o5%，远低于一年期银行储蓄存款利率，即是说用钱购买股票还不如存zài银行划算。股市的低回报率是场内投资者不断撒离和场外投资者不敢涉足的根本原因。</p>
<p>可见，一方面股票供给正在急剧增加，而另一方面股票的需求又不断减少，股票价格不下降、指数不下跌，那才令人难以思议。刘纪鹏、张卫星作为经济学领域的“家”，不可能不懂经济学的最基本规律，也不可能对上述事实不了解，那他们又为什么坚认“要以股价涨跌论成败”呢？笔者百思不得其解！</p>
<p>综上所述，股价的升降是制度因素、股票价值和市场供求综合作用的结果，指数的涨跌也是市场规律作用的结果。股权分置改革，从实质上来讲，只不过是在股市制度变化即由股权分置变为股票全流通的情况下，对两类股东的股份予以重新确认，它既没有革除退市机制，也没有改变公司的质量，更何况全流通的推行加剧了市场供求力量的对比，因此，股权分置改革无论如何都难以推动股价的上涨。于是，我们可以得出结论：“成功的股改就是一定要把股价拉起来”是一个天大的谬论。</p>
<hr>
<h2 id="04什么是a股、B股、h股、n股、s股？"><a href="#04什么是a股、B股、h股、n股、s股？" class="headerlink" title="04什么是a股、B股、h股、n股、s股？"></a>04什么是a股、B股、h股、n股、s股？</h2><p>我国上市公司的股票有a股、B股、h股、n股和s股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。</p>
<h3 id="A-股"><a href="#A-股" class="headerlink" title="A 股"></a>A 股</h3><p>a股的正式名称是人民币普通股票。它是由我同境内的公司行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票，1990年，我国a股股票一共仅有1o只至1997年年底，a股股票增加到72o只，a股总股本为1646亿股，总市值17529亿元人民币，与国内生产总值的比率为22．7％。1997年a股年成交量为4471亿股，年成交金额为30295亿元人民币，我国a股股票市场经过几年快展，已经初具规模。</p>
<h3 id="B股"><a href="#B股" class="headerlink" title="B股"></a>B股</h3><p>B股的正式名称是人民币特种股票，它是以人民币标明面值，以外币认购和买卖，在境内（sh、深圳）证券交易所上市交易的。它的投资人限于：外国的自然人、法人和其他组织，香港、澳门、台湾地区的自然人、法人和其他组织，定居在国外的中国公民。中国证监会规定的其他投资人。现阶段日股的投资人，主要是上述几类中的机构投资者。B股公司的注册地和上市地都在境内。只不过投资者在境外或在中国香港，澳门及台湾。</p>
<p>自1991年底第一只B股sh电真空B股行上中以来，经过6年的展，中国的B股市场已由地方性市场展到由中国证监会统管理的全同性市场。到1997年底，我国B股股票有1o1只，总股本为125亿股，总市值为375亿儿人民币3股市场规模与a股市场相比要小得多。近几年来，我国还在B股衍生产品及其他方面作一些有益的探索。例如，1995年深圳南玻公司成功地行了B股可转换债券，蛇口招商港务在新加坡进行了第二上市试点，沪，深两地的4家公司还进行了将B股转为一级adR在美国柜合市场交易的试点等。</p>
<h3 id="H股"><a href="#H股" class="headerlink" title="H股"></a>H股</h3><p>h股，即注册地在内地、上市地在香港的外资股。香港的英文是hongkong，取其字，在港上市外资股就叫做h股。依此类推，纽约的第一个英文字母是n，新加坡的第一个英文字母是s纽约和新加坡上市的股票就分别叫做n股和s股。</p>
<h3 id="N股"><a href="#N股" class="headerlink" title="N股"></a>N股</h3><p>n股，是指那些在中国大6注册、在纽约（neyork）上市的外资股。在我国股市中，当股票名称前出现了n字，表示这只股是当日新上市的股票，字母n是英语ne(新)的缩写。看到带有n字头的股票时，投资者除了知道它是新股，还应认识到这只股票的股价当日在市场上是不受涨跌幅限制的，涨幅可以高于10％，跌幅也可深于10％。这样就较容易控zhì风险和把握投资机会。如n北化、n建行、n石油等。</p>
<p>自1993年在港行青岛啤酒h股以来，我网先后挑选了4批共77家境外上市预选企业，这些企业部处于各行业领先地位在一定程dù上体现厂中国经济的整体展水平和增长潜力。到1997年底。已经有42家境外上市预选企业经过改制在境外上市，包括sh石化、镇海化工、庆铃汽车、BJ大唐电力、南方航空等。其中有31家在香港上市，6家在香港和纽约同时上市，2家在香港和伦敦同时上中，2家单独在纽约k市（n股），1家单独在新加坡上市s股）。42家境外上市企业累计筹集外资95．6亿美元。</p>
<hr>
<h2 id="05什么是sT、pT股票？"><a href="#05什么是sT、pT股票？" class="headerlink" title="05什么是sT、pT股票？"></a>05什么是sT、pT股票？</h2><p>“T”类股票包括sT股和pT股。</p>
<p>1998年4月22日,沪深证券交易所宣布将对财务状况和其他财务状况异常的上市公司的股票交易进行特别处理（英文为spenett,缩写为“sT”）。其中异常主要指两种情况：一是上市公司经审计两个会计年度的净利润均为负值,二是上市公司最近一个会计年度经审计的每股净资产低于股票面值。在上市公司的股票交易被实行特别处理期间,其股票交易应遵循下列规则：（1）股票报价日涨跌幅限制为5%；（2）股票名称改为原股票名前加“sT”,例如“sT钢管”；（3）上市公司的中期报告必须经过审计。</p>
<p>pT股是基于为暂停上市流通的股票提供流通渠道的特别转让服务所产生的股票品种（pT是英文partinetsfer〈特别转让〉的缩写）,这是根据《公司法》及《证券法》的有关规定,上市公司出现连续三年亏损等情况,其股票将暂停上市。沪深证券交易所从1999年7月9日起,对这类暂停上市的股票实施“特别转让服务”。pT股的交易价格及竞价方式与正常交易股票有所不同：（1）交易时间不同。pT股只在每周五的开市时间内进行,一周只有一个交易日可以进行买卖。（2）涨跌幅限制不同。据最新规定,pT股只有5%的涨幅限制,没有跌幅限制,风险相应增大。（3）撮合方式不同。正常股票交易是在每交易日9：15－9：25之间进行集合竞价,集合竞价未成交的申报则进入9：3o以后连续竞价排队成交。而pT股是交易所在周五15：oo收市后一次性对当天所有有效申报委托以集合竞价方式进行撮合,产生唯一的成交价格,所有符合条件的委托申报均按此价格成交。（4）pT股作为一种特别转让服务,其所交易的股票并不是真正意义上的上市交易股票,因此股票不计入指数计算,转让信息只能在当天收盘行情中看到。</p>
<hr>
<h2 id="06什么是指定交易？"><a href="#06什么是指定交易？" class="headerlink" title="06什么是指定交易？"></a>06什么是指定交易？</h2><p>所谓指定交易，是指投资者与某一证券经营机构签订协议后，指定该机构为自己买卖证券的惟一交易点。指定交易有几大好处：</p>
<p>（1）有助于防止投资者股票被盗卖；</p>
<p>（2）自动领取红利，由证券交易系统直接将现金红利资金记入投资者的账户内；</p>
<p>（3）可按月按季度收到证券经营机构提供的对账服务。</p>
<p>目前沪市实行的就是指定交易制度，使沪市投资者的投资相对过去更为安全、便利。</p>
<hr>
<h2 id="07委比是什么意思？"><a href="#07委比是什么意思？" class="headerlink" title="07委比是什么意思？"></a>07委比是什么意思？</h2><p>委比是衡量一段时间内场内买、卖盘强弱的技术指标。它的计算公式为：委比=（委买手数－委卖手数）／（委买手数＋委卖手数）x1oo％。从公式中可以看出，“委比”的取值范围从－1oo％至＋1oo％。若“委比”为正值，说明场内买盘较强，且数值越大，买盘就越强劲。反之，若“委比”为负值，则说明市道较弱。</p>
<p>上述公式中的“委买手数”是指即时向下三档的委托买入的总手数，“委卖手数”是指即时向上三档的委托卖出总手数。如：某股即时最高买入委托报价及委托量为15．oo元、13o手，向下两档分别为14．99元、15o手，14．98元、2o5手；最低卖出委托报价及委托量分别为15．o1元、27o手，向上两档分别为15．o2元、475手，15．o3元、655手，则此时的即时委比为－48．54％。显然，此时场内抛压很大。</p>
<p>通guò“委比”指标，投资者可以及时了解场内的即时买卖盘强弱情况。</p>
<p>委差：某品种当前买量之和减去卖量之和。反映买卖双方的力量对比。正数为买方较强，负数为抛压较重。委差=委买手数－委卖手数</p>
<hr>
<h2 id="08深综指与深成指的区别"><a href="#08深综指与深成指的区别" class="headerlink" title="08深综指与深成指的区别"></a>08深综指与深成指的区别</h2><p>股价指数是运用统计学中的指数方法编制而成的，反映股市总体价格或某类股价变动和走势的指标。根据股价指数反映的价格走势所涵盖的范围，可以将股价指数划分为反映整个市场走势的综合性指数和反映某一行业或某一类股票价格走势的分类指数。</p>
<p>深证综合指数，是深圳证券交易所编制的，以深圳证券交易所挂牌上市的全部股票为计算范围，以行量为权数的加权综合股价指数。该指数以1991年4月3日为基日，基日指数定为1oo点。深证综合指数综合反映深交所全部a股和B股上市股票的股价走势。此外还编制了分别反映全部a股和全部B股股价走势的深证a股指数和深证B股指数。深证a股指数以1991年4月3日为基日，1992年1o月4日开始布，基日指数定为1oo点。深证B股指数以1992年2月28日为基日，1992年1o月6日开始布，基日指数定为1oo点。</p>
<p>深证成份股指数，是从上市的所有股票中抽取具有市场代表性的4o家上市公司的股票作为计算对象，并以流通股为权数计算得出的加权股价指数，综合反映深交所上市a、B股的股价走势。该指数取1994年7月2o日为基日，基日指数定为1ooo点。成份股指数于1995年1月23日开始试布，1995年5月5日正式启用。4o家上市公司的a股用于计算成份a股指数及行业分类指数，4o家上市公司中有B股的公司，其B股用于计算成份B股指数。深证成份股指数，还就a股编制分类指数，包括工业分类指数、商业分类指数、金融分类指数、地产分类指数、公用事业分类指数、综合企业分类指数。深证成份股指数选取样本时考虑的因素有：1.上市交易日期的长短；2.上市规模，按每家公司一段时期内的平均总市值和平均可流通股市值计；3.交易活跃程dù，按每家公司一段时期总成交金额计。确定初步名单后，再结合以下各因素评选出4o家上市公司作为成份股：1.公司股票在一段时期内的平均市盈率；2.公司的行业代表性及所属行业的展前景；3.公司近年的财务状况、盈利记录、展前景及管理素zhì等；4.公司的地区、板块代表性等。为保证指数的代表性，必须视上市公司的变动更换成份股，深圳证券交易所定于每年1、5、9月对成份股的代表性进行考察，讨论是否需要更换。</p>
<hr>
<h2 id="09开放式基金与封闭式基金的区别"><a href="#09开放式基金与封闭式基金的区别" class="headerlink" title="09开放式基金与封闭式基金的区别"></a>09开放式基金与封闭式基金的区别</h2><p>根据基金是否可以赎回，证券投资基金可分为开放式基金和封闭式基金。开放式基金，是指基金规模不是固定不变的，而是可以随时根据市场供求情况行新份额或被投资人赎回的投资基金。封闭式基金，是相对于开放式基金而言的，是指基金规模在行前已确定，在行完毕后和规定的期限内，基金规模固定不变的投资基金。</p>
<p>开放式基金和封闭式基金主要区别如下：</p>
<p>（1）基金规模的可变性不同。封闭式基金均有明确的存续期限，在此期限内已行的基金单位不能被赎回。虽然特殊情况下此类基金可进行扩募，但扩募应具备严格的法定条件。因此，在正常情况下，基金规模是固定不变的。而开放式基金所行的基金单位是可赎回的，而且投资者在基金的存续期间内也可随意申购基金单位，导zhì基金的资金总额每日均不断地变化。换言之，它始终处于“开放”的状态。这是封闭式基金与开放式基金的根本差别。</p>
<p>（2）基金单位的买卖方式不同。封闭式基金起设立时，投资者可以向基金管理公司或销售机构认购；当封闭式基金上市交易时，投资者又可委托券商在证券交易所按市价买卖。而投资者投资于开放式基金时，他们则可以随时向基金管理公司或销售机构申购或赎回。</p>
<p>（3）基金单位的买卖价格形成方式不同。封闭式基金因在交易所上市，其买卖价格受市场供求关系影响较大。当市场供小于求时，基金单位买卖价格可能高于每份基金单位资产净值，这时投资者拥有的基金资产就会增加；当市场供大于求时，基金价格则可能低于每份基金单位资产净值。而开放式基金的买卖价格是以基金单位的资产净值为基础计算的，可直接反映基金单位资产净值的高低。在基金的买卖费用方面，投资者在买卖封闭式基金时与买卖上市股票一样，也要在价格之外付出一定比例的证券交易税和手续费；而开放式基金的投资者需缴纳的相关费用（如次认购费、赎回费）则包含于基金价格之中。一般而言，买卖封闭式基金的费用要高于开放式基金。</p>
<p>（4）基金的投资策略不同。由于封闭式基金不能随时被赎回，其募集得到的资金可全部用于投资，这样基金管理公司便可据以制定长期的投资策略，取得长期经营绩效。而开放式基金则必须保留一部分现金，以便投资者随时赎回，而不能尽数地用于长期投资，一般投资于变现能力强的资产。</p>
<hr>
<h2 id="10什么是集合竞价？"><a href="#10什么是集合竞价？" class="headerlink" title="10什么是集合竞价？"></a>10什么是集合竞价？</h2><p>每一交易日中，任一证券的竞价分为集合竞价与连续竞价两部分，集合竞价是指对所有有效委托进行集中处理，深、沪两市的集合竞价时间为交易日上午9：15至9：25。集合竞价分四步完成：</p>
<p><strong>第一步</strong>：确定有效委托在有涨跌幅限制的情况下，有效委托是这样确定的：根据该只证券上一交易日收盘价以及确定的涨跌幅度来计算当日的最高限价、最低限价。有效价格范围就是该只证券最高限价、最低限价之间的所有价位。限价出此范围的委托为无效委托，系统作自动撤单处理。</p>
<p><strong>第二步</strong>：选取成交价位。先，在有效价格范围内选取使所有委托产生最大成交量的价位。如有两个以上这样的价位，则依以下规则选取成交价位：</p>
<p>（1）高于选取价格的所有买委托和低于选取价格的所有卖委托能够全部成交。</p>
<p>（2）与选取价格相同的委托的一方必须全部成交。如满足以上条件的价位仍有多个，则选取离昨市价最近的价位。</p>
<p><strong>第三步</strong>：集中撮合处理所有的买委托按照委托限价由高到低的顺序排列，限价相同者按照进入系统的时间先后排列；所有卖委托按委托限价由低到高的顺序排列，限价相同者按照进入系统的时间先后排列。依序逐笔将排在前面的买委托与卖委托配对成交，即按照“价格优先，同等价格下时间优先”的成交顺序依次成交，直至成交条件不满足为止，即不存zài限价高于等于成交价的叫买委托、或不存zài限价低于等于成交价的叫卖委托。所有成交都以同一成交价成交。</p>
<p><strong>第四步</strong>：行情揭示</p>
<p>（1）如该只证券的成交量为零，则将成交价位揭示为开盘价、最近成交价、最高价、最低价，并揭示出成交量、成交金额。</p>
<p>（2）剩余有效委托中，实际的最高叫买价揭示为叫买揭示价，若最高叫买价不存zài，则叫买揭示价揭示为空；实际的最低叫卖价揭示为叫卖揭示价，若最低叫卖价不存zài，则叫卖揭示价揭示为空。集合竞价中未能成交的委托，自动进入连续竞价。</p>
<hr>
<h2 id="11哪些情况属于交易异常波动需临时停牌？"><a href="#11哪些情况属于交易异常波动需临时停牌？" class="headerlink" title="11哪些情况属于交易异常波动需临时停牌？"></a>11哪些情况属于交易异常波动需临时停牌？</h2><p>根据沪深交易所的规定，以下情况属于交易异常波动，交易所有权对该股实施临时停牌，直至有关当事人作出公告后的当天下午开市时复牌。</p>
<ol>
<li><p>某只股票的价格连续三个交易日达到涨幅限制或跌幅限制；</p>
</li>
<li><p>某只股票连续五个交易日列入“股票、基金公开信息”；</p>
</li>
<li><p>某只股票价格的振幅连续3个交易日达到15％；</p>
</li>
<li><p>某只股票的日成交量与上月日均成交量相比连续5个交易日放大1o倍；</p>
</li>
<li><p>交易所或中国证监会认为属于异常波动的其它情况。经中国证监会认可的特殊情况不受此限制。基金不受此限制。</p>
</li>
</ol>
<hr>
<h2 id="12证券辞典"><a href="#12证券辞典" class="headerlink" title="12证券辞典"></a>12证券辞典</h2><p>开盘：在证券交易所证券交易中，每天开市的次交易为开盘，按开盘价的不同分为高开，低开和平开。</p>
<p>开盘价：开盘是指某种证券在证券交易所每个营业日的第一笔交易，第一笔交易的成交价即为当日开盘价。按sh证券交易所规定，如开市后半小时内某证券无成交，则以前一天的盘价为当日开盘价。有时某证券连续几天无成交，则由证券交易所根据客户对该证券买卖委托的价格走势，提出指导价格，促使其成交后作为开盘价。日上市买卖的证券经上市前一日柜台转让平均价或平均售价为开盘价。</p>
<p>收盘价：收盘价是指某种证券在证券交易所一天交易活动结束前最后一笔交易的成交价格。如当日没有成交，则采用最近一次的成交价格作为收盘价，因为收盘价是当日行情的标准，又是下一个交易日开盘价的依据，可据以预测未来证券市场行情；所以投资者对行情分析时，一般采用收盘价作为计算依据。</p>
<p><strong>成交数量</strong>：指当天成交的股票数量。</p>
<p><strong>最高价</strong>：指当天股票成交的各种不同价格是最高的成交价格。</p>
<p><strong>最低价</strong>：指当天成交的不同价格中最低成交价格。</p>
<p><strong>升高盘</strong>：是指开盘价比前一天收盘价高出许多。</p>
<p><strong>开低盘</strong>：是指开盘价比前一天收盘价低出许多。</p>
<p><strong>盘档</strong>：是指投资者不积极买卖，多采取观望态度，使当天股价的变动幅度很小，这种情况称为盘档。</p>
<p><strong>整理</strong>：是指股价经过一段急剧上涨或下跌后，开始小幅度波动，进入稳dìng变动阶段，这种现象称为整理，整理是下一次大变动的准备阶段。</p>
<p><strong>盘坚</strong>：股价缓慢上涨，称为盘坚。</p>
<p><strong>盘软</strong>：股价缓慢下跌，称为盘软。</p>
<p><strong>跳空</strong>：指受强烈利多或利空消息刺激，股价开始大幅度跳动。跳空通常在股价大变动的开始或结束前出现。</p>
<p><strong>回档</strong>：是指股价上升过程中，因上涨过而暂时回跌的现象。</p>
<p><strong>反弹</strong>：是指在下跌的行情中，股价有时由于下跌度太快，受到买方支撑面暂时回升的现象。反弹幅度较下跌幅度小，反弹后恢fù下跌趋势。</p>
<p><strong>成交笔数</strong>：是指当天各种股票交易的次数。</p>
<p><strong>成交额</strong>：是指当天每种股票成交的价格总额。</p>
<p><strong>最后喊进价</strong>：是指当天收盘后，买者欲买进的价格。</p>
<p><strong>最后喊出价</strong>：是指当天收盘后，卖者的要价。</p>
<p><strong>多头</strong>：对股票后市看好，先行买进股票，等股价涨至某个价位，卖出股票赚取差价的人。</p>
<p><strong>空头</strong>：是指变为股价已上涨到了最高点，很快便会下跌，或当股票已开始下跌时，变为还会继续下跌，趁高价时卖出的投资者。</p>
<p><strong>涨跌</strong>：以每天的收盘价与前一天的收盘价相比较，来决定股票价格是涨还是跌。一般在交易台上方的公告牌上用“+”“－”号表示。</p>
<p><strong>价位</strong>：指喊价的升降单位。价位的高低随股票的每股市价的不同而异。以sh证券交易所为例：每股市价末满1oo元价位是o.1o元；每股市价1oo－2oo元价位是o.2o元；每股市价2oo－3oo元价位是o.3o元；每股市价3oo－4oo元价位是o.5o元；每股市价4oo元以上价位是1.oo元；</p>
<p><strong>盘整</strong>：指股市上经常会出现股价徘徊缓滞的局面，在一定时期内既上不去，也下不来，sh投资者们称此为僵牢。</p>
<p><strong>配股</strong>：公司行新股时，按股东所有人参份数，以特价（低于市价）分配给股东认购。</p>
<p><strong>要价、报价</strong>：股票交易中卖方愿出售股票的最低价格。</p>
<p><strong>行情牌</strong>：一些大银行和经纪公司，证券交易所设置的大型电子屏幕，可随时向客户提供股票行情。</p>
<p><strong>盈亏临界点</strong>：交易所股票交易量的基数点，过这一点就会实现盈利，反之则亏损。</p>
<p><strong>填息</strong>：除息前，股票市场价格大约等于没有宣布除息前的市场价格加将分派的股息。因而在宣布除息后股价将上涨。除息完成后，股价往往会下降到低于除息前的股价。二者之差约等于股息。如果除息完成后，股价上涨接近或过除息前的股价，二者的差额被弥补，就叫填息。</p>
<p><strong>票面价值</strong>：指公司最初所定股票票面值。</p>
<p><strong>法定资本</strong>：例如一家公司的法定资本是2ooo万元，但开业时只需1ooo万元便足够，持股人缴足1ooo万元便是缴足资本。</p>
<p><strong>蓝筹股</strong>：指资本雄厚，信誉优良的挂牌公司行的股票。</p>
<p><strong>经纪人佣金</strong>：经纪人执行客户的指令所收取的报酬，通常以成交金额的百分比计算。</p>
<p><strong>多头市场</strong>：也称牛市，就是股票价格普遍上涨的市场。</p>
<p><strong>空头市场</strong>：股价呈长期下降趋势的市场，空头市场中，股价的变动情况是大跌小涨。亦称熊市。</p>
<p><strong>股本</strong>：所有代表企业所有权的股票，包括普通股和优先股。</p>
<p><strong>资本化证券</strong>：根据普通股股东持股股份的比例，免费提供的新股，亦称临时股或红利股。</p>
<p><strong>现卖</strong>：证券交易所中交易成交后，要求在当天交付证券的行为称为现卖。</p>
<p><strong>多翻空</strong>：原本看好行情的多头，看法改变，不但卖出手中的股票，还借股票卖出，这种行为称为翻空或多翻空。</p>
<p><strong>空翻多</strong>：原本作空头者，改变看法，不但把卖出的股票买回，还买进更多的股票，这种行为称为空翻多。</p>
<p><strong>买空</strong>：预计股价将上涨，因而买入股票，在实际交割前，再将买入的股票卖掉，实际交割时收取差价或补足差价的一种投机行为。</p>
<p><strong>卖空</strong>：预计股价将下跌，因而卖出股票，在生实际交割前，将卖出股票如数补进，交割时，只结清差价的投机行为。</p>
<p><strong>利空</strong>：促使股价下跌，以空头有利的因素和消息。</p>
<p><strong>利多</strong>：是刺激股价上涨，对多头有利的因素和消息。</p>
<p><strong>长空</strong>：是对股价前景看坏，借来股票卖，或卖出股票期货，等相当长一段时间后才买回的行为。</p>
<p><strong>短空</strong>：变为股价短期内看跌，借来股票卖出，短时间内即补回的行为。</p>
<p><strong>长多</strong>：是对股价远期看好，认为股价会长期不断上涨，因而买进股票长期持有，等股价上涨相当长时间后再卖出，赚取差价收益的行为。</p>
<p><strong>短多</strong>：是对股价短期内看好，买进股票，如果股价略有不涨即卖出的行为。</p>
<p><strong>补空</strong>：是空关买回以前卖出的股票的行为。</p>
<p><strong>吊空</strong>：是指抢空头帽子，卖空股票，不料当天股价末下跌，只好高价赔钱补进。多杀多：是普遍认为当天股价将上涨，于是市场上抢多头帽子的特别多，然而股价却没有大幅度上涨，等交易快结束时，竞相卖出，造成收盘价大幅度下跌的情况。轧空：是普遍认为当天股价将下跌，于是都抢空头帽子，然而股价并末大幅度下跌，无法低价买进，收盘前只好竞相补进，反而使收盘价大幅度升高的情况。</p>
<p><strong>死多</strong>：是看好股市前景，买进股票后，如果股价下跌，宁愿放上几年，不嫌钱绝不脱手。</p>
<p><strong>套牢</strong>：是指预期股价上涨，不料买进后，股价一路下跌；或是预期股价下跌，卖出股票后，股价却一路上涨，前者称多头套牢，后者是空头套牢。</p>
<p><strong>抢帽子</strong>：指当天低买再高卖，或高卖再低买，买卖股票的种类和数量都相同，从中赚取差价的行为。</p>
<p><strong>帽客</strong>：从事抢帽子行为的人，称为帽客。</p>
<p><strong>断头</strong>：是指抢多头帽子，买进股票，不料当天股价末上涨，反而下跌，只好低价</p>
<hr>
<h2 id="13股市常用术语"><a href="#13股市常用术语" class="headerlink" title="13股市常用术语"></a>13股市常用术语</h2><p>[<strong>股票指数期货</strong>]股票指数期货是一种以股市指数为买卖基础的期货。它是一种远期合约的买卖，采用保证金交易的方式，保证金的比例一般是合约面值的5％至15％。它采用现金交割方式，即合约到期时以股票市场的收市指数作为结算的准则，合约持有人只需交付或收取股市与期市两个指数的现金差额，就可完成交割手续。</p>
<p>[<strong>零股交易</strong>]不到一个成交单位(1手=1oo股)的股票，如1股、1o股，称为零股。在卖出股票时，可以用零股进行委托；但买进股票时不能以零股进行委托，最小单位是1手，即1oo股。</p>
<p>[<strong>集合竞价</strong>]每早9：15－9：25，通guò计算机撮合配对，以价格优先，时间优先为指标确定价格。</p>
<p>[<strong>轧空</strong>]指做空头买卖的投资人在卖出股票之后，股票的价格却一路上涨，在不得已的情况下以比卖出价更高的价格重新买进已卖出的股票。</p>
<p>[<strong>箱型走势</strong>]指股价走势的一种形状。将最高价、最低价分别连成直线，便可得到一个箱型的价格趋势图，故称“箱型走势”。由于像一个通道，又称“通道”。</p>
<p>[<strong>除息</strong>]指股份公司向投资者以现金股利形式放红利。除息前，股份公司需要事先召开股东会议确定方案、核对股东名册，除息时以规定某日在册股东名单为准，并公告在此日以后一段时期为停止股东过户期。除息同样会造成股价下跌，投资者应谨慎判断。</p>
<p>[<strong>除权</strong>]股份公司在向投资者放股利时，除去交易中股票配股或送股的权利称为除权。与除息一样，除权时也以规定日的在册股东名单为准，并公告在此日以后一段时期为停止股东过户期。除权一般会造成股价的下跌，投资者不能轻yì就此做出股价处于低位的判断，而应根据股价的走势，做出正确的判断。</p>
<p>[<strong>反转</strong>]指股价由多头行情转为空头行情，或由空头行情转为多头行情。大势来讲，就是由牛市转变为熊市，或是由熊市转变为牛市，从个股来讲，从下跌趋势转向上升趋势，投资者应积极参与，股票的形态看好。从上升趋势转为下跌趋势，投资者应尽kuài出局或远离该股票。</p>
<p>[<strong>承销</strong>]指将股票销售业务委托给专门的股票承销机构代理。按照行风险的承担、所筹资金的划拨及手续费高低等因素划分，承销方式有包销和代销两种。</p>
<p>[<strong>成长股</strong>]是指这样一些公司所行的股票，它们的销售额和利润额持续增长，而且其度快于整个国家和本行业的增长。这些公司通常有宏图伟略，注重科研，留有大利润作为再投资以促进其扩张。</p>
<p>[<strong>绩优股</strong>]是指过去几年业绩和盈余较佳,展望未来几年仍可看好，只是不会再有高度成长的可能的股票。该行业远景尚佳，投资报酬率也能维持一定的高水平。</p>
<p>[<strong>投机股</strong>]是指那些从事开性或冒险性的公司的股票。这些股票有时在几天内上涨许多倍，因而能够吸引一些投机者。这种股票的风险性很大。</p>
<p>[<strong>多头</strong>]投资者对股市前景看好，认为股价将上涨，于是先用低价买进，特价而沽。这种先买后卖的人称为多头。</p>
<p>[<strong>空头</strong>]投资者对股市前景看跌,认为股价现在太高,先卖掉股票，和以股价跌到预期程dù时再买进，以赚以差价。这种先卖后买的人称为空头。</p>
<p>[<strong>牛市</strong>]指较长一段时间里处于上涨趋势的股票市场。牛市中，求过于供，股价上涨，对多头有利。</p>
<p>[<strong>熊市</strong>]指较长一段时间里处于下跌趋势的股票市场。熊市中，供过于求，股价下跌，对空头有利。</p>
<p>[<strong>牛皮市</strong>]走势波动小，陷入盘整，成交及低。</p>
<p>[<strong>买空</strong>]投资人预期股价将要上涨，以提交保证金方式融资购买股票，然后待股价上涨后卖出，以赚取差价。这种方式称为买空。</p>
<p>[<strong>卖空</strong>]投资人预期股价将要下跌，以提交保证金方式借到股票，先卖出，而后待到股价下跌到预期程dù时，再买进，赚取差价。这种方式称为卖空。</p>
<p>[<strong>长多</strong>]长线投资人，买进股票持有较长的时间。</p>
<p>[<strong>短多</strong>]善作短线，通常三两天有赚就卖。</p>
<p>[<strong>死多</strong>]指总是看好股市前景，买进股票，如果股价下跌，宁愿放上几年抱定一个原则，不赚钱不卖的投资人。</p>
<p>[<strong>扎空</strong>]卖出股票后，股价不跌反涨，称为扎空行情。</p>
<p>[<strong>多翻空</strong>]原本为多头，但见势不对卖出持股获利了结转为做空。</p>
<p>[<strong>空翻多</strong>]原本为空头，但见大势变好，买入持股转为做多。</p>
<p>[<strong>套牢</strong>]本书中的套牢实际上是指多头套牢。是指投资者买进股票后，股价下跌而卖不出去。</p>
<p>[<strong>抢短线</strong>]预期股价上涨，先低价买进后再在短期内以高价卖出。预期股价下跌，先高价卖出再伺机在短期内以低价再回购。</p>
<p>[<strong>利好(利多)</strong>]凡对多头有利，刺激股价上涨的因素或信息称为利好(利多)</p>
<p>[<strong>利空</strong>]凡对空头有利，促使股价下跌的因素或信息称为利空。</p>
<p>[<strong>大户</strong>]手中持有大股票或资本，做大额交易的客户，一般是资金雄厚的人，他们吞吐量大、能影响市场股价。</p>
<p>[<strong>散户</strong>]进行零星小额买卖的投资者，一般指小额投资者，或个人投资者。</p>
<p>[<strong>死多头</strong>]认定股市前景看好，只买进而不卖出，即使股价下跌，宁愿套牢而抱定不获利决不卖出的人。</p>
<p>[<strong>盘整</strong>]股价经过一段快捷上升或下降后，遭遇阻力或支撑而呈小幅涨跌变动，做换手整理。</p>
<p>[<strong>跳空</strong>]股市受到利好或利空消息的强刺激，股指开始大幅度跳动。当天开盘价在上涨时高于前一天收盘价数个单位；在下跌时低于前一天收盘价数个单位；而在一天交易中，涨跌幅度过数个单位。</p>
<p>[<strong>反弹</strong>]在空头市场上，股价处于下跌趋势中，会因股价下跌过快而出现回升，以调整价位，这种现象称为反弹。</p>
<p>[<strong>抬拉</strong>]抬拉是用非常方法，将股价大幅度抬起。通常大户在抬拉之后便大抛出以牟取暴利。</p>
<p>[<strong>打压</strong>]打是用非常方法，将股价大幅度压低。通常大户在打压之后便大量买进以取暴利。</p>
<p>[<strong>涨(跌)停板</strong>]交易所规定的股价一天中涨（跌）最大幅度为前一日收盘价的百分数，不能过此限，否则自动停止交易。</p>
<p>[<strong>黑马</strong>]是指股价在一定时间内，上涨一倍或数倍的股票。</p>
<p>[<strong>白马</strong>]是指股价已形成慢慢涨的长升通道，还有一定的上涨空间。</p>
<p>[<strong>热门股</strong>]是指交易量大、流通性强、股价变动幅度较大的股票。</p>
<p>[<strong>骗线</strong>]大户利用股民们迷信技术分析数jù、图表的心理，故意抬拉、打压股指，致使技术图表形成一定线型，引诱股民大买进或卖出，从而达到他们大其财的目的。这种期骗性造成的技术图表线型称为骗钱。</p>
<p>[<strong>成交量</strong>]某种证券或整个市场在一定时期内完成交易的股数。</p>
<p>[<strong>技术分析</strong>]以供求关系为基础对市场和股票进行的分析研究。技术分析研究价格动向、交易量、交易趋势和形式,并制图表示上述因素,为图预测当前市场行为对未来证券的供求关系和个人持有的证券可能生的影响。</p>
<p>[<strong>基本分析</strong>]根据销售额、资产、收益、产品或服务、市场和管理等因素对企业进行分析。亦指对宏观政zhì、经济、军事动态的分析,以预测它们对股市的影响。</p>
<p>[<strong>经纪人</strong>]执行客户命令，买卖证券、商品或其他财产，并为此收取佣金者。</p>
<p>[<strong>非上市股票</strong>]不在证券交易所注册挂牌的股票。</p>
<p>[<strong>委托书</strong>]股东委托他人(其他股东)代表自己在股东大会上行使投票权的书面证明。</p>
<p>[<strong>周转率</strong>]股票交易的股数占交易所上市流通的股票股数的百分比。</p>
<p>股市常用术语3</p>
<p>[<strong>除权</strong>]股票除权前一日收盘价减去所含权的差价，即为除权。</p>
<p>[<strong>派息</strong>]股票前一日收盘价减去上市公司放的股息称为派息。</p>
<p>[<strong>含权</strong>]凡是有股票有权未送配的均称含权。</p>
<p>[<strong>填权</strong>]除权后股价上升，将除权差价补回，称为填权。</p>
<p>[<strong>增资</strong>]上市公司为业务需求经常会办理增资（有偿配股）或资本公积新增资（无偿配股）。</p>
<p>[<strong>配股</strong>]公司行新股时按股东所持股份数以持价(低于市价)分配认股。</p>
<p>[<strong>坐轿子</strong>]预测股价将涨，抢在众人前以低价先行买进，待众多散户跟进、股价节节升高后，卖出获利。</p>
<p>[<strong>抬轿子</strong>]在别人早已买进后才醒悟，也跟着买进，结果是把股价抬高让他人获利，而自己买进的股价已非低价，无利可图。</p>
<p>[<strong>下轿子</strong>]坐轿客逢高获利了结算为下轿子。</p>
<p>[<strong>掼压</strong>]利用大卖出将股价打压下来，主要想压低进货。</p>
<p>[<strong>拉抬</strong>]利用大量买入将股价拉起来，主要想拉高出货。</p>
<p>[<strong>长空</strong>]指对股市远景看坏，借来股票卖出，俟股票跌落一段相当长时期以后才买回。</p>
<p>[<strong>短空</strong>]指对股市前途看跌，借来股票卖出，但于短时间内即买回</p>
<p>[<strong>补空</strong>]指空头买回以前借来卖出的股票。</p>
<p>[<strong>空手</strong>]指手中无股票，即不是空头，也不是多头，观望股势，等待股价低时买进，高时借股放空的人。</p>
<p>[<strong>套牢</strong>]指预测股价将上涨，买进后却一路下跌，或是预测股价将下跌，于是借股放空后，却一路上涨，前者称为多头套牢，后者称为宽头套牢。</p>
<p>[<strong>扎空头</strong>]资金雄厚的股票投机者看中某种股票看涨，便大量买入，并暗中控zhì其来源，使空头于交割时无法获得其应交数量，多头趁机抬高价格，空头不得不忍痛按多头要求的价格成交。</p>
<p>[<strong>扎多头</strong>]到期股票价格疲软，原来做多头的商人急于脱手，如果实力雄厚的投机家控zhì各方面股票需求，成为寡头购买者，迫使多头削价出售。</p>
<p>[<strong>抢帽子</strong>]指当天先低价买进股票，然后高价再卖出相同种类、相同数量的股票，或当天先卖出股票，然后以低价买进相同种类、相同数量的股票，以求赚取差价利益。</p>
<p>[<strong>断头</strong>]指抢多头帽子，买进股票，股票当天未上涨，反而下跌，只好低价赔钱卖出。</p>
<p>[<strong>吊空</strong>]指抢空头帽子，卖出股票，股价当天未下跌，反而上涨，只好高价赔钱买回。</p>
<p>[<strong>多杀多</strong>]普遍认为当天股价将上涨，于是抢多头帽子的人持多，然而股价却没有大幅上涨，无法高价卖出，等到交易快要结束时，竟相卖出，因而造成收盘时股价大幅下挫的情形。</p>
<p>[<strong>空杀空</strong>]普遍认为当天股价将下跌，于是都抢空头帽子，然而股价却没有大幅下跌，无法低价买进，交割前，只好纷纷补进，因而反使股价在收盘时，大幅度升高的情形。</p>
<p>[<strong>实多</strong>]指在自有资金能力范围之内，买进股票，即使被套牢，亦不必赶忙杀出的人。</p>
<p>[<strong>实空</strong>]指以自己手中持有的股票放空，股价反弹时并不需要着急补回的人。</p>
<p>[<strong>浮多</strong>]看好股市前景，认为将会上涨，想大捞一笔，而自己财力有限，于是向别人借来资金，买进股票，放款人若要收回，买股票的多头，即需卖出股票，归还借款，此时，即使股价上涨，亦不敢长期持有，一旦获得相当利润即卖出，一股价下跌，更心慌意乱，赶紧赔钱了结，以防套牢。</p>
<p>[<strong>浮空</strong>]其情形与浮多相同，只是认为股价将下跌，借股放空，因所放空的股票，时有被收回的顾虑，所以称为“浮空”。</p>
<p>[<strong>阻力线</strong>]股价上涨到达某一价位附近，如有大量的卖出情形，使股价停止上扬，甚至回跌的价位。</p>
<p>[<strong>支撑线</strong>]股价下跌到在某一价位附近，如有大量买进情形，使股价停止下跌甚至回升的价位。</p>
<p>[<strong>盘挡</strong>]指当天的股价变动幅度小，显得十分稳dìng。</p>
<p>[<strong>盘坚</strong>]指当天股价缓慢盘旋上升。</p>
<p>[<strong>盘软</strong>]指当天股价缓慢盘旋下跌。</p>
<p>[<strong>盘整</strong>]指股价经过一段急的上涨或下跌后，遇到阻力或支撑，因而开始小幅度上下变动，其幅度大约在15%左右。</p>
<p>[<strong>跳空</strong>]股市受到强烈利多或利空消息的刺激,股价开始大幅跳动,在上涨时,当天的开盘或最低价，高于前一天的收盘价两个申报单位以上，称“跳空而上”；下跌时，当天的天盘或最高价低于前一天的收盘价两个申报单位，而于一天的交易中，上涨或下跌过一个申报单位，称“跳空而下”。</p>
<p>[<strong>填空</strong>]指将跳空出现时没有交易的空价位补回来，也就是股价跞空后，过一段时间将回到跳空前价位，以填补跳空价位。</p>
<p>[<strong>拔档</strong>]持有股票的多头遇到股价下跌，并预期可能还要下跌，于是卖出股票，等待股价跌落一段差距以后，再补回，期望少赔一段差距。</p>
<p>[<strong>回档</strong>]上升趋势中，因股价上涨过而回跌，以调整价位的现象。</p>
<p>[<strong>打底</strong>]股价由最低点回升，随后遭到空头压卖而再度跌落，但在最低点附近又获得多头支撑，如此来回多次后，便迅脱离最低点而一路上涨。</p>
<p>[<strong>打开</strong>]股价由涨跌停板滑落或翻升。</p>
<p>[<strong>天价</strong>]个别股票由多头市场转为空头市场时的最高价。</p>
<p>[<strong>突破</strong>]指股价经过一段盘档时间后，产生的一种价格波动。</p>
<p>[<strong>探底</strong>]股价持续跌挫至某价位时便止跌回升，如此一次或数次。</p>
<p>[<strong>头部</strong>]股价上涨至某价位时便遇阻力而下滑。</p>
<p>[<strong>挂进</strong>]买进股票的意思。</p>
<p>[<strong>挂出</strong>]卖出股票的意思</p>
<p>[<strong>关卡</strong>]指股价上升至某一价位时，由于供求关系转变，导股价停滞不前，此一敏感价位区即谓“关卡”。</p>
<p>[<strong>开平盘</strong>]指今日的开盘价与前一营业日的收盘价相同。</p>
<p>[<strong>近期趋势</strong>]2o～3o天为近期趋势。</p>
<p>[<strong>绩优股</strong>]指过去业绩与盈余有良好表xiàn的股票。</p>
<p>[<strong>全额交割</strong>]是证券主管机关对重整公司或生重dà问题的上市公司之股票，特别制定的买卖交割力法。</p>
<p>[<strong>全盘尽黑</strong>]指所有的股票均下跌，亦称“长黑”。</p>
<p>[<strong>趋势</strong>]指股价在一段期间内的变动方向。</p>
<p>[<strong>抢搭车</strong>]指股资人于股价稍微上涨时立即买进的行为。</p>
<p>[<strong>做手</strong>]指以炒作股票为业的大、中户。</p>
<p>[<strong>洗盘</strong>]做手为达妙作目的，必须于途中让低价买进，意志不坚的轿客下轿，以减轻上档压力，同时让持股者的平均价位升高，以利于施行养、套、杀的手段。</p>
<p>[<strong>新多</strong>]指新进场的多头投资人。</p>
<p>[<strong>线仙</strong>]指精于以路线图分析和研判大势的老手。</p>
<p>[<strong>中短期趋势</strong>]5o～6o天为中短期趋势。</p>
<p>[<strong>中长期趋势</strong>]8o～1oo天为中长期趋势。</p>
<p>[<strong>震盘</strong>]指股价一天之内呈现忽高忽低之大幅度变化。</p>
<p>[<strong>中户</strong>]指投资额较大的投资人。</p>
<p>[<strong>差价</strong>]股票在买进和卖出的两种价格之间所获得之利润或亏损，前者称差价利得，后者称差价损失。</p>
<p>[<strong>上档</strong>]指在市价以上的价位。</p>
<p>[<strong>下档</strong>]指在当时股价以下的价位。</p>
<p>[<strong>走势牛皮</strong>]形容股票价格变动蹒跚。</p>
<p>[<strong>做头</strong>]过程与“打底”一样，只是形状恰好相反，在高价位处有两个以上的峰顶并排，形成上涨压力。</p>
<p>[<strong>业内</strong>]证券业的以业人员。</p>
<p>[<strong>溢价行</strong>]指新上市公司以高于面值的价格办理公开行或已上市公司以高于面值的价格办理现金增资。</p>
<p>[<strong>折价行</strong>]指以低于面前的价格行。</p>
<p>[<strong>中间价行</strong>]即以时价和面值的中间价作为行价格。</p>
<p>[<strong>时价行</strong>]即以旧股票的现行市价作为新股票的行价格。</p>
<p>[<strong>股票行</strong>]指符合条件的行人依照法定程序向投资者募集股份的行为。</p>
<p>[<strong>股票行价格</strong>]指股份有限公司将股票公开售给特定或非特定投资者所采用的价格。根据我国有关法规规定，股票不得以低于股票票面金额的价格行。根据行价与票面金额的不同差异，股票行可以分为面值行与溢价行。</p>
<p>[<strong>行费用</strong>]指行公司在筹备和行股票过程中生的费用。该费用可在股票行溢价收入中扣除，主要包括中介机构费、上网费和其他费用。</p>
<p>[<strong>多头</strong>]股票后市看好，先行买进股票，等股价涨至某个价位，卖出股票赚取差价的人。</p>
<p>[<strong>空头</strong>]是指认为股价已上涨到了最高点，很快便会下跌，或当股票已开始下跌时，认为还会继续下跌，趁高价时卖出的投资者。</p>
<p>[<strong>多头市场</strong>]也称牛市，就是股票价格普遍上涨的市场。</p>
<p>[<strong>空头市场</strong>]股价呈长期下降趋势的市场，空头市场中，股价的变动情况是大跌小涨。亦称熊市。</p>
<p>[<strong>多翻空</strong>]原本看好行情的多头，看法改变，卖出手中的股票，有时还借股票卖出，这种行为称为翻空或多翻空。</p>
<p>[<strong>空翻多</strong>]原本作空头者，改变看法，把卖出的股票买回，有时还买进更多的股票，这种行为称为空翻多。</p>
<p>[<strong>买空</strong>]预计股价将上涨，因而买入股票，在实际交割前，再将买入的股票卖掉，实际交割时收取差价或补足差价的一种投机行为。</p>
<p>[<strong>卖空</strong>]预计股价将下跌，因而卖出股票，在生实际交割前，将卖出股票如数补进，交割时，只结清差价的投机行为。</p>
<p>[<strong>骗线</strong>]大户利用股民们迷信技术分析数jù、图表的心理，故意抬拉、打压股指，致使技术图表形成一定线型，引诱股民大量买进或卖出，从而达到他们大其财的目的</p>
<hr>
<h2 id="14股票的你需要知道的基本概念"><a href="#14股票的你需要知道的基本概念" class="headerlink" title="14股票的你需要知道的基本概念"></a>14股票的你需要知道的基本概念</h2><h3 id="1、什么是股票？"><a href="#1、什么是股票？" class="headerlink" title="1、什么是股票？"></a>1、什么是股票？</h3><p>股票就是股份公司给股东作为已投资入股的证书与索取股息的凭证。股票像一般的商品一样，有价格，能买卖，可以作抵押品。股份公司借助行股票来筹集资金。投资者通过购买股票获取一定的股息收入。股票具有以下特性：</p>
<p>权责性。股票作为产权或股权的凭证，是股份的证券表现，代表股东对行股票的公司所拥有的一定权责。股东的权益与其所持股票占公司股本的比例成正比。<br>无期性。股票投资是一种无确定期限的长期投资，只要公司存zài，投资者一般不能中途退股。<br>流通性。股票作为一种有价证券可作为抵押品，并可随时在股票市场上通guò转让卖出而换成现金，因而成为一种流通性很强的流动资产和融资工具。<br>风险性。股票投资者除获取一定的股息外，还可能在股市中赚取买卖差价利润。但投资收益的不确定性又使股票投资具有较大的风险，其预期收益越高风险也越大。行股票公司的经营状况欠佳，甚至破产，股市的大幅度波动和投资者自身的决策失误都可能给投资者带来不同程度的风险。<br>法定性。股票须经有关机构批准和登记注册，进行签证后才能行，并必须以法定形式，记载法定事项。购买股票是一种金融投资行为，与银行储蓄存款及购买债券相比较，它是一种高风险行为，但同时它也能给人们带来更大的收益。<br>购买股票能带来哪些好处呢？由于现在人们投资股票的主要目的并非在于充当企业的股东，享有股东权利,所以购买股票的好处主要体现在以下几个方面：</p>
<p>1、每年有得到上市公司回报，如分红利、送红股。</p>
<p>2、能够在股票市场上交易，获取买卖价差收益。</p>
<p>3、能够在上市公司业绩增长、经营规模扩大时享有股本扩张收益。这主要是通过上市的送股、资本公积金转增股本、配股等来实现。</p>
<p>4、能够在股票市场上随时出售，取得现金，以备一时之急需。</p>
<p>5、在通货膨胀时期，投资好的股票还能避免货币的贬值，有保值的作用。</p>
<h3 id="2、什么是综合指数和成份指数？"><a href="#2、什么是综合指数和成份指数？" class="headerlink" title="2、什么是综合指数和成份指数？"></a>2、什么是综合指数和成份指数？</h3><p>反映股市指数变动的指数有sh综合指数、深圳成份指数等。同时沪市还有3o0成份指数。综合指数和成份指数最大的不同之处是：</p>
<p>综合指数以股票全部股本为基础计算指数。而成份指数仅以股票流通股本为基础计算指数。</p>
<p>如sc长虹（6oo839），1997年末总股本为万股，其中可流通股为万股，其余的国有股、法人股及转配股不能流通。</p>
<p>因此长虹列入上证3o成份指数时，仅计算流通股数。深市成份指数也如此，如深展（ooo1），1997年末总股本为万股，计算时以流通股万股为准。如果计算综合指数则将总股本全部纳入计算式中。因此，综合指数将不流通的股本计入动态的计算之中，不太合理。而成份指数又存zài选择范围仅在3o－4o只股票中进行，有一定的局限性。投资者应将综指和成指结合分析。免货币的贬值，有保值的作用。</p>
<h3 id="3、什么是普通股、优先股、绩优股、垃圾股、蓝筹股、红筹股？"><a href="#3、什么是普通股、优先股、绩优股、垃圾股、蓝筹股、红筹股？" class="headerlink" title="3、什么是普通股、优先股、绩优股、垃圾股、蓝筹股、红筹股？"></a>3、什么是普通股、优先股、绩优股、垃圾股、蓝筹股、红筹股？</h3><p>普通股是指在公司的经营管理和盈利及财产的分配上享有普通权利的股份，代表满足所有债权偿付要求及在优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权，它构成公司资本的基础，是股票的一种基本形式，也是行量最大，最为重要的股票。</p>
<p>目前在sh和深圳证券交易所上中交易的股票，都是普通股。</p>
<p>优先股是公司在筹集资金时，给予投资者某些优先权的股票，这种优先权主要表xiàn在两个方面：</p>
<p>1、优先股有固定的股息，不随公司业绩好坏而波动，并可以先于普通股股东领取股息；</p>
<p>2、当公司破产进行财产清算时，优先股股东对公司剩余财产有先干普通股股东的要求权。但优先股一般不参加公司的红利分配，持股人亦无表决权，不能借助表决权参加公司的经营管理。因此，优先股与普通股相比较，虽然收益和决策参与权有限，但风险较小。</p>
<p>顾名思义，绩优股就是业绩优良公司的股票，但对于绩优股的定义国内外却有所不同。在我国，投资者衡量绩优股的主要指标是每股税后利润和净资产收益率。一般而言，每股税后利润在全体上市公司中处于中上地位，公司上市后净资产收益率连续三年显著过1o％的股票当属绩优股之列。绩优股具有较高的投资回报和投资价值。</p>
<p>垃圾股指的是业绩较差的公司的股票。这类上市公司或者由于行业前景不好，或者由于经营不善等，有的甚至进入亏损行列。其股票在市场上的表xiàn萎靡不振，股价走低，交投不活跃，年终分红也差。投资者在考虑选择这些股票时，要有比较高的风险意识，切忌盲目跟风投机。</p>
<p>蓝筹股――股票市场上，投资者把那些在其所属行业内占有重要支配性地位、业绩优良，成交活跃、红利优厚的大公司股票称为蓝筹股。“蓝筹”一词源于西方赌场。在西方赌场中，有二种颜色的筹码、其中蓝色筹码最为值钱，红色筹码次之，白色筹码最差。投资者把这些行话套用到股票上就有了这一称谓。</p>
<p>红筹股这一概念诞生于九十年代初期的香港股票市场。中华人民共和国在国际上有时被称为红色中国，相应地，香港和国际投资者把在境外注册、在香港上市的那些带有中国大6概念的股票称为红筹股。</p>
<h3 id="4、什么是配股和转配股？"><a href="#4、什么是配股和转配股？" class="headerlink" title="4、什么是配股和转配股？"></a>4、什么是配股和转配股？</h3><p>配股是上市公司按照公司发展的需要，根据有关的规定和相应程序，向原股东增新股，进一步筹集资金的行为。依照惯例，公司配股时原股东有优先认购权。</p>
<p>转配股是上市公司在配股时，国有股或法人股股东由于缺乏现金等原因将配股转让给社会公众，由社会公众股股东认购的股份。转配股是我国股票市场特有的品种，它产生于1994年至1997年。根据中国证监会有关规定，转配股过去一直不能上市流通。</p>
<p>为了促进证券市场健康展，2ooo年3月中国证监会决定，转配股从4月开始，用24个月左右的时间，逐步安排上市流通。上市的方式是按照产生转配股的时间先后，分期、分批6续进入二级市场流通。公司有多次转配行为的，按次生转配股的时间确定上市顺序，并同时全部安排上市。</p>
<p>沪深两市实施转配股的公司共168家，转配股总量约33.o5亿股，占两市流通a股数量的3.96％。因此，转配股上市是有限的市场扩容，总体来说对大盘的影响不大，但对于行转配股的个股来说，存zài一定的风险。股民购买股票时，应该考虑该上市公司是否有转配股这个因素。</p>
<h3 id="5、什么是流通市值和市价总值？"><a href="#5、什么是流通市值和市价总值？" class="headerlink" title="5、什么是流通市值和市价总值？"></a>5、什么是流通市值和市价总值？</h3><p>在我国，上市公司的股份结构中分国有股、法人股、个人股等。目前个公众股可以上市流通交易。这部分流通的股份总数乘以股票市场价格，就是流通市值。如九洲股份（o653），流通股为6496万股，1998年12月4日收市价为7.11元。市价总值即全部股份乘上市场价格。如九洲股份的总股本是万股，12月4日市价总值为184743万元。</p>
<h3 id="6、什么是国有股、法人股、社会公众股？"><a href="#6、什么是国有股、法人股、社会公众股？" class="headerlink" title="6、什么是国有股、法人股、社会公众股？"></a>6、什么是国有股、法人股、社会公众股？</h3><p>按投资主体来分。我国上市公司的股份可以分为国有股，法人股和社会公众股。</p>
<p>国有股指有权代表同家投资的部门或机构以国有资产向公司投资形成的股份。包括以公司现有国有资产折算成的股份。如截止1999年6月3o日，沪市伊利股份（6oo887）国家持股万股，即指国有股。</p>
<p>法人股指企业法人或具有法人资格的事业单位和社会团体以其依法可经营的资产向公司非上市流通股权部分投资所形成的股份。目前，在我国上市公司的股权结构中，法人股平均占2o％左右。同上，沪市伊利股份（6oo887）境内法人持股万股，即指法人股。</p>
<p>社会公众股是指我国境内个人和机构，以其合法财产向公司可上市流通股权部分投资所形成的股份。我国投资者通guò4ooo多万股东账户在股票市场买卖的股票都是社会公众股。我国公司法规定，单个自然人持股数不得过该公司股份的5％。</p>
<p>我国国有股和法入股目前还不能上市交易。国家股东和法人股东要转让股权，可以在法律许可的范围内，经证券主管部门批准，与合格的机构投资者签订转让协议一次性完成大宗股权的转移。</p>
<p>由于国家股和法人股占总股本的比重平均过7o％，在大多数情况下，要取得一家上市公司的控股权，收购方需要从原国家股东和法人股东手中协议受让大宗股权。近年来。随着兼并收购人壳、借壳等资产重组活动的展开，国有股利法人股的转让行为也逐渐增多。例如，1995年中国第一汽车集团公司协议受让“沈阳金杯”5亿股国家股，使其控股比例达到51％，沈阳金杯由此改名为一汽金杯，纳入一汽集团旗下。除少量公司职工股、内部职工股及转配股上市流通受一定限制外．绝大部分的社会公众股都可以上市流通交易。</p>
<h3 id="7、什么是成交量和交易量？"><a href="#7、什么是成交量和交易量？" class="headerlink" title="7、什么是成交量和交易量？"></a>7、什么是成交量和交易量？</h3><p>例如，某只股票成交量显示为1ooo股，这是表示以买卖双方意愿达成的，即：买方买进了1ooo股，同时卖方卖出了1ooo股。在计算时成交量是1ooo股。但如果计算交易量，则双边计算，买方1ooo股加买方1ooo股，计为2ooo股。</p>
<p>因此，成交量与交易量是有区别的。</p>
<h3 id="8、什么是送股与转增股？"><a href="#8、什么是送股与转增股？" class="headerlink" title="8、什么是送股与转增股？"></a>8、什么是送股与转增股？</h3><p>不少投资者把送红股、转增股本混为一谈，其实两者是有区别的。</p>
<p>送红股是上市公司将本年的利润留在公司里，放股票作为红利，从而将利润转化为股本。送红股后，公司的资产、负债、股东权益的总额结构并没有生改变，但总股本增大了，同时每股净资产降低了。而转增股本则是指公司将资本公积转化为股本，转增股本并没有改变股东的权益，但却增加了股本的规模，因而客观结果与送红股相似。转增股本与送红股的本质区别在于，红股来自公司的年度税后利润，只有在公司有盈余的情况下，才能向股东送红股；而转增股本却来自于资本公积，它可以不受公司本年度可分配利润的多少及时间的限制，只要将公司帐面上的资本公积减少～些，增加相应的注册资本金就可以了，因此，转增股本严格地说并不是对股东的分红回报。</p>
<p>我国大部分上市公司以送红股的方式对股东进行回报，这在国外成熟股市上是较少见的。中国投资者非常喜欢上市公司高比例送配股，主力机构也往往利用高送配的题材大肆炒作。而外国投资者更注重现金红利，所以行h股的公司多采取现金分红。</p>
<h3 id="9、什么是sT股和pT股？"><a href="#9、什么是sT股和pT股？" class="headerlink" title="9、什么是sT股和pT股？"></a>9、什么是sT股和pT股？</h3><p>sT股</p>
<p>沪深证券交易所在1998年4月22日宣布，根据1998年实施的股票上市规则，将对财务状况或其它状况出现异常的上市公司的股票交易进行特别处理，由于“特别处理”的英文是spenett（缩写是“sT”），因此这些股票就简称为sT股。上述财务状况或其它状况出现异常主要是指两种情况，一是上市公司经审计连续两个会计年度的净利润均为负值，二是上市公司最近一个会计年度经审计的每股净资产低于股票面值。在上市公司的股票交易被实行特别处理期间，其股票交易应遵循下列规则：</p>
<p>（1）股票报价日涨跌幅限制为5％；</p>
<p>（2）股票名称改为原股票名前加“sT”，例如“sT辽物资”；</p>
<p>（3）上市公司的中期报告必须审计。由于对sT股票实行日涨跌幅度限制为5％，也在一定程dù上抑制了庄家的刻意炒作。投资者对于特别处理的股票也要区别对待．具体问题具体分析，有些sT股主要是经营性亏损，那么在短期内很难通guò加强管理扭亏为盈。有些sT股是由于特殊原因造成的亏损，或者有些sT股正在进行资产重组，则这些股票往往潜力巨大。</p>
<p>pT股</p>
<p>“pT”的英语partinetsfer（意为特别转让）的缩写。这是旨在为暂停上</p>
<p>市股票提供流通渠道的“特别转让服务”。对于进行这种”特别转让”的股票，沪深交易所在其简称前冠以“pT”，称之为“pT股”。</p>
<p>根据《公司法》和证券法的规定，上市公司出现连续三年亏损等情况，其股票将暂停上市。沪深交易所从1999年7月9日起，对这类暂停上市的股票实施“特别转让服务”。第一批这类股票有“pT双鹿”，“pT农商社”，“pT苏三山”和“pT渝太白”。</p>
<p>特别转让与正常股票交易主要有四点区别：</p>
<p>（1）交易时间不同。特别转让仅限于每周五的开市时间内进行，而非逐日持续交易。</p>
<p>（2）涨跌幅限制不同。特别转让股票申报价不得过上一次转让价格的上下5％，(文章来源：股市马经.)与sT股票的日涨跌幅相同。</p>
<p>（3）撮合方式不同，特别转让是交易所于收市后一次性对该股票当天所有有效申报按集合竞价方式进行撮合，产生唯一的成交价格，所有符合成交条件的委托盘均按此价格成交。</p>
<p>（4）交易性质不同。特别转让股票不是上市交易，因此，这类股票不计入指数计算，成交数不计入市场统计，其转让信息也不在交易所行情中显示，只由指定报刊设专栏在次日公告。</p>
<p>推出“特别转让服务”，是依据《公司法》中关于“股份公司的股东持有的股票可以依法转让”的规定而设计的。它的实行，既可为暂停上市的股票提供了合法的交易场所，又可以提示投资风险，有利于保护广大投资者的合法权益。</p>
<h3 id="10、“n、xR、xd、dR、g”各代表什么意思？"><a href="#10、“n、xR、xd、dR、g”各代表什么意思？" class="headerlink" title="10、“n、xR、xd、dR、g”各代表什么意思？"></a>10、“n、xR、xd、dR、g”各代表什么意思？</h3><p>深沪两市每逢新股上市日，在该新股的中文名称前加注“n”以提醒投资者。凡股票名称前加注“n”的股票均为当日上市的新股。</p>
<p>“xd”是“exitdivident”的缩写，是指除息的意思；</p>
<p>“xR”是“exitright”的缩写，意思是除权；</p>
<p>“dR”是“exitdividentandright”的缩写，意思是除息和除权。</p>
<p>“g”股：自从家实施股权分置改革的三一重工于6月17日恢fù交易并将股票简称改为“g三一”起，深沪股市就新增了一个被称为g股的新名词。</p>
<p>所谓g股，就是已经实施了股权分置改革，并恢fù交易的股票。因为“股权分置改革”中第一个词“股”的第一个中文拼音字母为g(g)，为了和其它股票相区别，所以在这种股票的简称前加上特有的标识――“g”。(文章来源：股市马经)也许未来将出现一个“g股板块”，虽然目前g股只有三一和金牛两只，但随着第二批试点公司股权分置改革的实施及6续复牌，“g”字头的股票今后会越来越多，深沪股市将会形成一个新的板块――g股板块，并在一定时候推出g股指数。</p>
<h3 id="11、什么是k线、阳线和阴线？"><a href="#11、什么是k线、阳线和阴线？" class="headerlink" title="11、什么是k线、阳线和阴线？"></a>11、什么是k线、阳线和阴线？</h3><p>所谓k线图，就是将各种股票每日、每周、每月的开盘价、收盘价、最高价、最低价等涨跌变化状况，用图形的方式表xiàn出来。k线又称阴阳线、棒线、红黑线或蜡烛线，它起源于日本德川幕府时代（16o3～1867年）的米市交易，用来计算米价每天的涨跌，后来人们把它引入股票市场价格走势的分析中，目前已成为股票技术分析中的重要方法。</p>
<p>k线最上方的一条细线称为上影线，中间的一条粗线为实体。下面的一条细线为下影线。当收盘价高于开盘价，也就是股价走势呈上升趋势时，我们称这种情况下的k线为阳线，中部的实体以空白或红色表示。这时，上影线的长度表示最高价和收盘价之间的价差，实体的长短代表收盘价与开盘价之间的价差，下影线的长度则代表开盘价和最低价之间的差距。</p>
<p>当收盘价低于开盘价，也就是股价走势呈下降趋势时，我们称这种情况下的k线为阴线。中部的实体为黑色。此时，上影线的长度表示最高价和开盘价之间的价差，实体的长</p>
<p>短代表开盘价比收盘价高出的幅度，下影线的长度则由收盘价和最低价之间的价差大小所决定．</p>
<p>需要说明的是，阳线、阴线与人们通常讲的涨跌有所不同。一般人们讲的涨跌是指当日收盘价与上个交易日收盘价之问的比较。当k线为阳线时，并不意味着股价比前一天涨了，只是表示当天收盘价高于当天开盘价。例如某只股票前一个交易日收盘价为2o元，当日开盘价、最高价、最低价和收盘价分别为18元、21元、17元、19元，则该只股票比前一个交易日跌了1元，k线图为一个上影线长度2元，下影线长度1元，实体为1元的阳线。</p>
<p>一般而言，阳线表示买盘较强，卖盘较弱，这时，由于股票供不应求，会导zhì股价的上扬。阴线表示卖盘较强，买盘较弱。此时，由于股票的持有者急于抛出股票，致使股价下挫。同时，上影线越长，表示上档的卖压越强，即意味着股价上升时，会遇到较大的抛压；下影线越长，表示下档的承接力道越强，意味着股价下跌时，会有较多的投资者利用这一机会购进股票。</p>
<p>然而，k线图往往受到多种因素的影响．用其预测股价涨跌并非能做到百分之百的准确。另外，对于同一种图形、许多人也会有不同的理解，做出不同的解释。因此，在运用k线图时。一定要与其他多种因素以及其他技术指标结合起来，进行综合分析和判断。</p>
<p>k线图形名称意义</p>
<p>下影阳线（先跌后涨型）开市后价格大幅下跌，后又回升到高位收市。后市承接力强，暗示上升力强，可能是上涨的先兆。</p>
<p>收盘光头阳线（先跌后涨型）开市下跌后掉头回升，以全日最高价收市，可见上升动力大。</p>
<p>光头阳线（大阳线）全日节节上升，有强烈的涨势。如果在跌市中出现，可能是跌市结束的信号。</p>
<p>开盘光头阳线（上升抵抗型）上升力强，但受阻挡，应谨慎。若是在持续上涨之后，可能是下跌的先兆；若是在下跌中的反弹行情，则多头实力不足，仍将下跌。</p>
<p>小阳线（欲涨乏力型）行情扑朔迷离，涨跌难有明确估计。如果出现在强烈持续上升之后，表示高位震荡，持续力不足，可能是下跌的征兆。如果在长期下跌之后出现，表示欲振乏力，可能继续下跌。</p>
<p>上影阳线市场上升趋势减弱，在较高价位明显受阻，后市有可能下跌。</p>
<p>光头阴线（大阴线）整日下跌，后市疲弱，行情极坏，还要下跌，在空头市场经常出现。如连续出现数根大阴线，可能有反弹行情。</p>
<p>上影阴线（上涨后跌型）先涨后跌，底部支撑力不大，在涨市中出现有可能是结束升市的信号。</p>
<p>收盘光头阴线（先涨后跌型）行情先涨后跌，卖方势强，行情看跌。</p>
<p>小阴线（短黑线）行情混乱，涨跌难以估计。如果出现在持续上升之后，表示高位震荡，可能是下跌的先兆。</p>
<p>开盘光头阴跌（下跌抵抗型）行情下跌后受到承接，显示有反弹迹象。</p>
<p>下影阴线（欲跌不能型）暗示底部有较强支撑力，后市可能趋于上升。如果在持续上升的行情中出现，仍将会持续上升；如果出现在持续下跌的行情中，将可能弹升。四值同时线市场疲弱，交易量小，投资者观望。这种一个价位的情况中在冷清股市中出现。</p>
<p>十字星大市正处于转变之时，可能是股市转向的信号。大十字星代表多空搏斗型，表明当日多空双方势均力敌，次日股价走势如在上影线部分，表明多头势强，可买进；反之，则卖出。小十字星小幅度的僵局型态，应静观其变后再定。不能涨跌大势，将会持续展。</p>
<p>T字型（多胜线）转跌为升的讯号，后市可能持续上升。多方实力胜于空方，在牛市中出现，可能续涨，在熊市中出现，可能反弹。</p>
<p>倒T字型（空胜线）表示卖方实力胜于买方，是强烈下跌的讯号。在牛市行情中出现，可能下跌；在熊市行情中出现，可能持续下跌。</p>
<h3 id="12、什么是a股、B股、h股、n股、s股？"><a href="#12、什么是a股、B股、h股、n股、s股？" class="headerlink" title="12、什么是a股、B股、h股、n股、s股？"></a>12、什么是a股、B股、h股、n股、s股？</h3><p>我国上市公司的股票有a股、B股、h股、n股和s股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。</p>
<p>a股的正式名称是人民币普通股票。它是由我同境内的公司行，供境内机构、组织或个人（不含台、港、澳投资者）以人民币认购和交易的普通股股票，我国a股股票市场经过几年快展，已经初具规模。</p>
<p>B股的正式名称是人民币特种股票，它是以人民币标明面值，以外币认购和买卖，在境内（sh、深圳）证券交易所上市交易的。它的投资人限于：外国的自然人、法人和其他组织，香港、澳门、台湾地区的自然人、法人和其他组织，定居在国外的中国公民。中国证监会规定的其他投资人。现阶段B股的投资人，主要是上述几类中的机构投资者。B股公司的注册地和上市地都在境内。只不过投资者在境外或在中国香港，澳门及台湾。</p>
<p>h股，即注册地在内地、上市地在香港的外资股。香港的英文是hongkong，取其字，在港上市外资股就叫做h股。依此类推，纽约的第一个英文字母是n，新加坡的第一个英文字母是s，纽约和新加坡上市的股票就分别叫做n股和s股。</p>
<h3 id="13、什么是股票的送股、分红、配股？"><a href="#13、什么是股票的送股、分红、配股？" class="headerlink" title="13、什么是股票的送股、分红、配股？"></a>13、什么是股票的送股、分红、配股？</h3><p>送股是指上市公司将利润（或资本金转增）以红股的方式分配给投资者使投资者所持股份增加而获得投资收益。</p>
<p>分红是指上市公司以现金方式放股利，这种分配方式需交纳所得税，在进行分配时，目前送股和红利所得已可自动进入股东帐户。</p>
<p>配股是上市公司按一定比例给予投资者再次投资股份的机会，这并不是一种利润分配方式。在上市公司宣布配股后，需要股东卖出相应的配股权证，如明天科技（6ooo91）每1o股配3股，投资者如原有1oo股需在除权后的缴款期卖出3o股明天科技配股权证（7ooo91），并有足够的配股保证金，即可获配成功。配股部份需待配股上市公告后才可交易。</p>
<h3 id="14、什么是支撑位、阻力位、颈线位？"><a href="#14、什么是支撑位、阻力位、颈线位？" class="headerlink" title="14、什么是支撑位、阻力位、颈线位？"></a>14、什么是支撑位、阻力位、颈线位？</h3><p>当我向有些人请教某股的走势时，他们就会很帅气地回答，它的支撑位是多少等等。请问支撑位、阻力位、颈线位都表示什么意思？它们是怎么算出来的？谢谢！</p>
<p>上升趋势中，前期趋势停顿的地方就有可能形成支撑位；</p>
<p>下降趋势中前期趋势停顿的地方就有可能形成阻力位；</p>
<p>支撑位和阻力位是可以相互转化的。不是一成不变的。</p>
<p>这些位置只是一些区域，不可能精确到什么点位。</p>
<p>记住：一旦支撑位或者阻力位被穿越或者跌破，就没有任何意义了。</p>
<p>至于颈线位，经常出现在比如m头、底或者头肩顶、头肩底之类的价格形态中。这些只在做分析的时候有用，具体操作注意风险了。</p>
<h3 id="15、什么是短线、中线、长线？"><a href="#15、什么是短线、中线、长线？" class="headerlink" title="15、什么是短线、中线、长线？"></a>15、什么是短线、中线、长线？</h3><p>短线：五日均线由下跌转为走平，股价在成交量的配合下，突破五日线带量向上。五日均量线同时方向。短线持股时间一般在3至5天。</p>
<p>中线：3o天线由下跌转为走平，股价在成交量的配合下站稳3o日线，3o日均量线的方向必须朝上。中线持股时间一般在1个月至3个月之间。</p>
<p>长线：看周线和月线、3o周均线走平向上、3o月均线走平向上。持股时间一般在3个月至半年、最多是一年时间。</p>
<h3 id="16、什么是金叉、死叉、多头排列、空头排列？"><a href="#16、什么是金叉、死叉、多头排列、空头排列？" class="headerlink" title="16、什么是金叉、死叉、多头排列、空头排列？"></a>16、什么是金叉、死叉、多头排列、空头排列？</h3><p>1、上升行情初期，短期移动平均线从下向上突破中长期移动平均线，形成的交叉叫黄金交叉。</p>
<p>预示股价将上涨：黄色的5日均线上穿紫色的1o日均线形成的交叉；1o日均线上穿绿色的3o日均线形成的交叉均为黄金交叉。</p>
<p>2、当短期移动平均线向下跌破中长期移动平均线形成的交叉叫做死亡交叉。预示股价将下跌。黄色的5日均线下穿紫色的1o日均线形成的交叉；1o日均线下穿绿色的3o日均线形成的交叉均为死亡交叉。</p>
<p>3、在上升行情进入稳dìng期，5日、1o日、3o日移动平均线从上而下依次顺序排列，向右上方移动，称为多头排列。预示股价将大幅上涨。</p>
<p>4、在下跌行情中，5日、1o日、3o日移动平均线自下而上依次顺序排列，向右下方移动，称为空头排列，预示股价将大幅下跌。</p>
<p>5、在上升行情中股价位于移动平均线之上，走多头排列的均线可视为多方的防线；当股价回档至移动平均线附近，各条移动平均线依次产生支撑力量，买盘入场推动股价再度上升，这就是移动平均线的助涨作用。</p>
<p>6、在下跌行情中，股价在移动平均线的下方，呈空头排列的移动平均线可以视为空方的防线，当股价反弹到移动平均线附近时，便会遇到阻力，卖盘涌出，促使股价进一步下跌，这就是移动平均线的助跌作用。</p>
<p>7、移动平均线由上升转为下降出现最高点，和由下降转为上升出现最低点时，是移动平均线的转折点。预示股价走势将生反转。</p>
<p>这里主要是针对技术指标，均线和k线的，看不明白就看下面的技术指标。</p>
<hr>
<h2 id="15报表的研读方法"><a href="#15报表的研读方法" class="headerlink" title="15报表的研读方法"></a>15报表的研读方法</h2><p>研读报表的基本原则及方法<br>益展的证券市场正逐渐表明：对上市公司的财务报表进行综合分析，全面研究上市公司的基本面，对于选准股票，取得良好的投资收益是非常重要的。具体来讲，对上市公司的研究就是要做好两个“三结合”。</p>
<p>第一个“三结合”就是：将财务数jù的分析与上市公司所处行业的展趋势相结合；将财务数jù的分析与上市公司所生产商品的竞争能力、供求状况相结合；将财务数jù的分析与个股的市场资金流向相结合。</p>
<p>第二个“三结合”是：在分析财务报表时要做到把趋势分析法、结构分析法、比率分析法相结合；将总量变动与比率变动相结合；把分析的量比指标与所分析问题的性质结合起来。这两个“三结合”的实质就是要求我们不能仅仅关注上市公司的过去和目前经营结果，而是更要善于通guò有关数jù的变化来预测公司未来的展趋势。</p>
<h3 id="一、货币资金和债务分析"><a href="#一、货币资金和债务分析" class="headerlink" title="一、货币资金和债务分析"></a>一、货币资金和债务分析</h3><p>货币资金是公司各类现金、银行存款和其他货币资金的总称。它不仅能反映企业的即时支付能力、周转度的快慢，也是企业是否具有增长潜力的重要标志之一。而在分析货币资金时，可从两方面着手；其一是上市公司的资金总量，其二是每股股票在扣除债务后所能拥有的货币资金。假如一家上市公司既没有新的项目投产又没有充足的资金，那么它的投资价值就颇值得商榷了。在宏观环境趋紧时，企业的债务状况往往决定它自身的展趋向。如果一家公司在产品大量积压的同时，又债务缠身，并且筹资无门，那么这家企业的前景就不甚乐观了。一般来说，分析企业的债务状况主要是看负债金额占企业总资产的比重，即资产负债率，生产经营状态正常的上市公司，其资产负债率大致在25%左右。如果小于此比例，就表明该公司财力较雄厚。与之相反，流动资金短缺，债务负担沉重的企业，其资产负债率往往在8o%以上，这类企业稍有不慎，就可能跌入破产的深渊。当然，在企业面临需求扩张的时期，也还是可以扩大负债经营的。不过其前提条件是：企业负债经营所产生的利润率应高于借款的平均利息率，并且两者之间的差额不能小于社会平均盈利率。因此，这种扩张必须适度，不能过多。</p>
<h3 id="二、存货与应收帐款分析"><a href="#二、存货与应收帐款分析" class="headerlink" title="二、存货与应收帐款分析"></a>二、存货与应收帐款分析</h3><p>这两个项目直接反映企业的销售状况，从而关系到企业的偿债能力和效益。在财务报表中，存货是用来反映公司库存的各类产成品、半成品及原材料的价格总额。对制造商和零售商来讲，存货积压过多并不是好现象，一旦存货的增长率过了销售增长率，那就意味着企业正常的资本循环受阻，流动资金短缺，以后的再生产会受到影响。而要避免这一后果，企业唯一可以选择的方法就是降价销售，减少库存，回收现金。但这一措施又不得不承受利润下降的损失。当然，存货由多变少，也可以看做是企业经营出现转机的第一个征兆。应收帐款是用来反映公司应收而未收到的货款、票据及劳务费用等的资产总额。若应收帐款数过多，说明公司的货款回收不畅资金拖欠严zhòng，进而引起公司本身的流动资金紧张。更令人担心的是：有些应收帐款颢容易变成“坏帐”，从而造成企业资产流失，影响公司今后的展。</p>
<h3 id="三、盈利能力分析"><a href="#三、盈利能力分析" class="headerlink" title="三、盈利能力分析"></a>三、盈利能力分析</h3><p>一般来讲，盈利的多少和盈利水平的高低将直接关系到股民的投资回报率，投资者必须给予重视。每股税后利润。这是上市公司财务报表中最令人关注的因素。它的分析包括两个方面：一是绝对量的高低，它反映企业的过去；二是每股税后利润的增减数量，它反映企业的成长性。分析每股税后利润，还要考虑上市公司每年送配股因素。利润总额和利润增长率。投资者必须重视分析影响利润总额变化的多种素。其一是分析公司销售量的增减情况及对利润的影响程dù；其二是分析公司营业成本和各项费用的增减情况；其三是分析商品销售价格的变动及对利润影响程dù。如果一家上市公司的营业成本和多种费用大幅增加，则很可能是企业经营和管理中产生了严zhòng的问题。另外，投资者还要分析利润总额中是否惨入水分，为此投资者应该注意分析待摊费用及预提费用科目的金额和构成内容，看有无应摊未摊和应提未提的费用；分析财务费用支出与长短期借款是否相配；分析企业各类资产的变情况，看固定资产计提折旧及无形资产、递延资产的摊销是否符合现行会计制度。除此之外，投资者还要善于结合上市公司的行业特征和经济周期等因素，综合分析企业利润增长率、销售利润率、净资产收益率及其变动，并和同行业各上市公司利润率作个比较，从中判断上市公司的经营管理水平和利润的变动趋势。</p>
<p>最后，中长期投资者还要注意分析上市公司在较长时期内稳dìng地获取利润和增加利润的能力。</p>
<p>分析利润构成情况。通常来说，主营业务突出，且行业占有率较大，其利润稳dìng增长的上市公司投资风险较小。而另一些公司，尽管它的年度内利润总额有所增加，但主营业务利润却未起色，甚至还大幅下降，这样的业绩增长往往是不稳dìng的：或者是因为过分扩大没有竞争能力的副业或看是过度的投机，一旦把握不好，企业就会很快垮下来。分析盈利增长的潜力或后劲。要留意上市公司的人才结构和科研费用的多少；分析企业新专利、新技术应用、新产品开的情况；分析是否开拓形成了新的销售网络和销售方式；分析目前公司主要的在建工程和已建成的主要项目运营的实际情况，看是否会形成新的利润增长点，并从中现是否有较好的市场炒作题材。最后我们来谈谈财务状况的综合分析法。财务状况综合分析法很多，这里就简要介绍一下其中的主要方法。</p>
<p>杜邦财务分析体系。杜邦体系认为企业的各项财务活动及财务指标是相互联系、相互依存、相互影响的，由此，它把多项财务指标间的内在关系绘制成杜邦分析图。分析的基本思路是：</p>
<p>1、所有者权益净利率是一个综合性最强的财务分析指标，是杜邦分析系统的核心。</p>
<p>2、资产净利润率是影响所有者权益利润率的最重要的指标，具有很强的综合性，而资产净利润率又取决于销售净利润率和资产周转率的高低。</p>
<p>3、扩大销售收入，降低成本费用是提高企业销售利润率的根本途径，而扩大销售，同时也是提高资产周转率的必要条件和途径。</p>
<p>4、要综合分析影响资产周转率的资产结构和影响企业偿债能力的权益结构。要联系销售收入分析企业资产使用是否合理，联系权益结构分析资产结构或联系资产结构分析偿债能力。</p>
<p>雷达图分析法。该法是将主要的财务分析比率进行汇总，并将公司各项财务指标与行业平均水平和企业历史最好水平相比较，从而达到综合反映企业总体财务状况目标的一种方法。</p>
<p>沃尔比重评分法。它把流动比率、产权比率、销售利润率、总资产报酬率、资本收益率、资产负债率、应收帐款周转率、存货周转率等财务比率用线性关系结合起来，并分别给定各自的分数比重，然后通guò与标准比率进行比较，确定各项指标的得分及总体指标的累计分数，从而对企业的财务状况和获利能力作出综合评价。</p>
<p>综上所述，投资者应重点选择那些现金较充足、应收帐款较少、偿债能力较强、商品销路较好、利润率较高、有新的利润增长点的上市公司进行投资。</p>
<h3 id="四、业绩报告哪些指标必读"><a href="#四、业绩报告哪些指标必读" class="headerlink" title="四、业绩报告哪些指标必读"></a>四、业绩报告哪些指标必读</h3><p>上市公司年报的格式按照有关规定是固定的。投资者可以先看第二部分“会计数jù摘要”。在其中可以看到最常用的每股收益、每股净资产、净资产收益率。以上数jù可以看出公司的基本盈利能力。在这些数jù中有一条叫“每股经营活动所产生的现金流量净额”，这一指标投资者应高度重视，它可以体现出公司在经营过程中是否真的赚到了利润。</p>
<p>我们的市场有很多绩优公司不但不给投资者分红反而每每提出融资方案。仔细考察的话，这种公司的该项指标往往和每股收益相去甚远，也就是说公司只是纸上富贵，利润中的水分很大。</p>
<p>第三部分“股东情况”中可以找到一条“报告期末股东总人数”。还可以用流通股数量除以股东人数，看看每一个股东的平均持股量也可以觉察到是否存zài主力活动。</p>
<p>第五部分“公司财务状况”中包括若干小项，有三项必须要看。</p>
<p>1、“公司财务状况”可以看到主营业务利润、净利润总额的同比增长率，从中可以看出公司的展趋势。</p>
<p>2、公司投资情况。特别是一些新股、次新股，要注意其投资项目的进展状况。</p>
<p>3、新年度的展计划，寻找公司的展计划中是否存zài与市场热点吻合的地方。</p>
<p>第八部分“财务会计报告”，主要包括三张报表：利润表、资产负债表、现金流量表。其中的利润表中会列出营业费用、管理费用、财务费用（即通常所说的三费）。通guò三费可以考察出公司的内部管理能力，可以把三费的同比变化与第五部分中的净利润增长率加以对比，如三费的增幅高于净利润的增幅则说明公司的管理尚待加强。以上述的方法读年报，一份报表15分钟即可观其大略，一些基本的要素也都包括了，投资者不妨一试。</p>
<h2 id="16开户与交易规则"><a href="#16开户与交易规则" class="headerlink" title="16开户与交易规则"></a>16开户与交易规则</h2><h3 id="1、开户流程"><a href="#1、开户流程" class="headerlink" title="1、开户流程"></a>1、开户流程</h3><p>证券市场分sh、深圳，一般先办理两个交易所的证券帐户，任意一个合法的券商都办，费用一般9o元左右；然后在自己满意的券商开立资金户，办理指定、网上交易等手续，存入资金（如何存入资金请咨询券商营业员）。</p>
<p>建议：</p>
<p>1先选择好一个社会信誉较好的大券商的营业部；</p>
<p>2须本人亲自办理，持有效合法证件（身份证、军官证、护照）；</p>
<p>3开户手续要求比较严格、项目较多，办理前请详细咨询券商营业人员。</p>
<p>根据有关规定，下列人员不得开户：</p>
<p>[<strong>1</strong>]证券管理机关工作人员（不得开立股票帐户）；</p>
<p>[<strong>2</strong>]证券交易所管理人员（不得开立股票帐户）；</p>
<p>[<strong>3</strong>]证券从业人员（不得开立股票帐户）；</p>
<p>[<strong>4</strong>]未成年人未经法定监护人的代理或允许者；</p>
<p>[<strong>5</strong>]未经授权代理法人开户者；</p>
<p>[<strong>6</strong>]因违反证券法规，经有权机关认定为市场禁入者且期限未满者；</p>
<p>[<strong>7</strong>]其他法规规定不得拥有证券或参加证券交易的自然人。</p>
<p>炒股需要先开户，开户的话可以找证券公司的营业部柜台办理，柜台营业员会帮助办理相关事宜；现在一些开通银证通的银行柜台也可以代理开户。具体流程可参考下面步骤：</p>
<p>（1）填写开户申请表</p>
<p>客户填写《开户申请表》（一式两份）、《证券交易委托代理协议书》、sh帐户的《指定交易协议书》，同时签字确认。对交易或存取款有代理人的客户开户，除必须填写上述协议外，还要求客户本人和代理人同时临柜签署《授权委托书》（一式三份）。若证券帐户卡本人不能到场的，由开户代理人办理**户时，开户代理人还须出示经公证机关依法公证的《授权委托书》，帐户本人应承诺承担由此代理而产生的一qiē法律责任。</p>
<p>（2）验证：</p>
<p>客户需提供本人身份证、沪深股东帐户卡原件。对交易或存取款有代理人的客户开户，除必须提供上述证件外，还应提供代理人的身份证原件及复印件。</p>
<p>（3）开户处理：</p>
<p>对符合开户规定的客户，柜台经办人员将客户开户资料输入计算机，并要求客户设定初始交易密码、资金存取密码，打印《客户开户回单》（一式两份）。同时，柜台经办人员按开户流水号为客户开立资金帐户号，并为客户配“证券交易卡”，请客户在《客户开户回单》签字。</p>
<h3 id="2、股票开户常识"><a href="#2、股票开户常识" class="headerlink" title="2、股票开户常识"></a>2、股票开户常识</h3><p>投资者在证券流通市场上购买股票，需要委托证券商，并在对方那里“开户”，即投资人与证券商签订“委托买卖证券受托契约”。</p>
<p>1．现金帐户：开设这一帐户的客户在买入证券后，应在清算日或清算日之前交清全部购买股票的价款。同理，在出卖股票后，亦应在清算日或之前将股票交割给评判商。清算日的具体日期通常在送交顾客的股票“成交通知单”上说明在美国以交易日后的第五个营业日为清算日。</p>
<p>2．保证金帐户：又称普通帐户。客户在购买证券时，证券商将以垫资的形式，向投资人提供一部分融资，并收取垫资的利息。例如，规定帐户的保证金比例为65％，意味着商户在购买证券时应即支付65％的证券价款。余下的35％的价款，并支付利息。利息按证券提供的借款成本为基础折算。</p>
<p>3．联合帐户：投资人以两人蔌两人以上合伙在证券商那里开设一个帐户。这类帐户适用于夫妻双方或父子关系。</p>
<p>4．随时帐户：开设这一帐户，客户给予证券商以优先权的书面批准，同意证券商在不与投资人协商的情况下进行交易，而且交易的对象、股票的价格，数量以及交易的时机都由证券商自行选定。当然，证券商要以不损害顾客的利益为前提。</p>
<h3 id="3、股票开户费用"><a href="#3、股票开户费用" class="headerlink" title="3、股票开户费用"></a>3、股票开户费用</h3><p>证券帐户卡具体的费用是，深市a股证券帐户卡开户费5o元，B股证券帐户卡港币12o元；沪市a股证券帐户卡4o元，磁卡或证券帐户卡（方便查询及委托，一般只在sh本地的证券营业部门内使用）需7o元，沪市B股帐户卡15美元</p>
<p>（总结一下：只需带身份证和钱到证券公司，身份证可直接在证券公司复印，用专用的复印纸，需要花钱印的，接下来营业员会指导你的，会填很多东西，合同之类的，办完手续后你会有两张类似存折的证券帐户卡，深市和沪市，还会有张资金卡，类似银行卡。还有就是要到证券公司指定的银行办张银行卡，再拿银行卡、身份证、资金卡也就是在证券公司办的那几样东西再到证券公司开通银证通业务，就可以在网上交易了。）</p>
<p>交易时间</p>
<p>每周一至周五，每天上午9:3o至11:3o，下午1:oo至3:oo。法定公众假期除外。</p>
<p>交易原则</p>
<p>价格优先、时间优先。</p>
<p>成交顺序</p>
<p>价格优先――较高价格买进申报优先于较低价格买进申报，较低价格卖出申报优先于较高价格卖出申报；时间优先――买卖方向、价格相同的，先申报者优先于后申报者。先后顺序按交易主机接受申报的时间确定。<br>证券交易所交易规则</p>
<p>T+1交易<br>股票涨跌幅及停牌规则</p>
<p>股票的每日涨跌幅度＝昨天收盘的1o％sT股的每日涨跌幅度＝昨天收盘的5％权证每日的涨跌幅度＝对应地标的股票收盘价的1o％，对应的权证上可以是大于1o%,究竟是百分之几，要具体到各个权证来分析，没有一定的幅度的。<br>股票交易中,涨停和跌停的成交量为什么很小?</p>
<p>涨停情况下，众人都看好这个股票，虽然买盘极多，但大家都不舍得卖，成交量自然少了。而跌停情况下，情况正好相反，大家都不想买，虽抛盘极多，但接盘无几，成交量自然也少了。</p>
<p>以下情况不设涨跌停:</p>
<p>1.新股上市日。</p>
<p>2.暂停上市sT股扭亏复牌日。</p>
<p>3.股改完成复牌日。</p>
<p>4.权证涨跌停大于1o％。</p>
<p>股票的停牌、复牌制度</p>
<p>对上市公司的股票进行停牌，是证券交易所为了维护广大投资者的利益和市场信息披露的公平、公正以及对上市公司行为进行监管约束而采取的必要措施。上市公司可以以证券交易所认为合理的理由向交易所申请停牌与复牌；证券交易所可以根据实际情况或中国证监会的要求，决定股票及其衍生品种的停牌与复牌。</p>
<p>上市公司董事会申请对其股票及其衍生品种停牌与复牌的情况有：上市公司公布年度报告或中期报告，或上市公司于交易日公布董事会关于权益分派、配股、公积金转增股本等决议时，当日上午停牌，下午开市时复牌；上市公司召开股东大会，会议期间为证券交易所交易时间的，自股东大会召开当日停牌，直至公告股东大会决议当日上午开市时复牌，公告日为非交易日，则公告后第一个交易日复牌。上市公司出现以下情况之一的，证券交易所对其股票及其衍生品种停牌或复牌：</p>
<p>1、在新闻媒介中出现上市公司尚未披露的信息，可能对公司股票及其衍生品种的交易产生较大影响，证券交易所对该股票及其衍生品种停牌，直至上市公司对该消息做出公告的当日下午开市时复牌。</p>
<p>2、股票交易出现异常波动，证券交易所可对其停牌，直至有披露义务的当事人做出公告的当日下午开市时复牌。</p>
<p>上市公司在公司运作和信息披露方面涉嫌违反法律法规、规章及本所业务规则，情节严zhòng的，在被有关部门调查期间，经中国证监会批准，本所对公司股票及其衍生品种停牌，待有关处理决定公告后另行决定复牌。</p>
<p>上市公司出现以下情况之一的，证券交易所对其股票及衍生品种停牌，直至导zhì停牌的因素消除后复牌：投资者出收购该上市公司股票的公开要约；中国证监会依法做出暂停股票交易的决定；证券交易所认为必要时。</p>
<p>上市公司申请的停牌期限不过3o天的，证券交易所根据该公司的股票交易情况做出决定；过3o天（包括3o天）的，由本所提出处理意见报中国证监会批准。公司应该在停牌申请获准后的次一个工作日公告停牌的信息。</p>
]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>金融</tag>
      </tags>
  </entry>
</search>
